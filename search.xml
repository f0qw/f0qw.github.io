<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Springboot和git和docker</title>
    <url>/2022/08/22/SpringBoot/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ol>
<li>只要SpringBoot父工程中帮助我们管理当前你需要使用的jar的依赖版本，开发人员则无需添加版本。</li>
<li>SpringBoot官方提供了大量stater场景启动器的目的：快速进入对应的服务，让开发人员将重点放在<strong>业务逻辑</strong>上。</li>
</ol>
<div style="background-color:orange">步骤1:导入SpringBoot起步依赖</div>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springboot工程需要继承的父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--web开发的起步依赖   场景启动器依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="background-color:orange">步骤2:编写引导类</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引导类。 SpringBoot项目的入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="background-color:orange">步骤3:定义HelloController</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.sh.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="background-color:orange">步骤4:启动测试，访问浏览器: http://localhost:8080/hello</div>



<h2 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h2><h3 id="1、读取配置数据"><a href="#1、读取配置数据" class="headerlink" title="1、读取配置数据"></a>1、读取配置数据</h3><p><font color="red">步骤：</font></p>
<p>1、定义实体类 Man和Woman</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;man&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String userName;</span><br><span class="line">   <span class="keyword">private</span> Boolean boss;</span><br><span class="line">   <span class="keyword">private</span> Date birth;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="keyword">private</span> String[] address;</span><br><span class="line">   <span class="keyword">private</span> List&lt;String&gt; addressList;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Object&gt; hobbies;  <span class="comment">// 爱好</span></span><br><span class="line">   <span class="keyword">private</span> Woman woman;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Woman&gt; wifes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; addresses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、添加配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">company2:</span> <span class="string">itcast</span></span><br><span class="line"><span class="attr">company1:</span> <span class="string">itheima</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">man:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">laowang</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">1980</span><span class="string">/09/09</span> <span class="number">01</span><span class="string">:01:01</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">41</span></span><br><span class="line">  <span class="attr">address:</span> [<span class="string">beijing</span>, <span class="string">shanghai</span>]</span><br><span class="line">  <span class="attr">addressList:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">北京</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">上海</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">深圳</span></span><br><span class="line">  <span class="attr">hobbies:</span></span><br><span class="line">    <span class="attr">sports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">badminton</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">basketball</span></span><br><span class="line">    <span class="attr">musics:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dj</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">23</span></span><br><span class="line">  <span class="attr">woman:</span></span><br><span class="line">    <span class="attr">userName:</span> <span class="string">xiaohua</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">北京</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">上海</span></span><br><span class="line">  <span class="attr">wifes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">userName:</span> <span class="string">xiaosan1</span></span><br><span class="line">       <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line">       <span class="attr">addresses:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">北京</span></span><br><span class="line"></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">userName:</span> <span class="string">xiaosan2</span></span><br><span class="line">       <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">       <span class="attr">addresses:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">上海</span></span><br></pre></td></tr></table></figure>

<p>3、依赖注入测试</p>
<p><strong>方式1：引导类开启注解支持(推荐)</strong></p>
<p>@ConfigurationProperties(prefix = “man”)+ @EnableConfigurationProperties(Man.class)</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220015426.png" alt="image-20210503001542063"></p>
<p><strong>方式2：@ConfigurationProperties(prefix = “man”)+@Component</strong></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220015956.png" alt="image-20220822001548916"></p>
<h3 id="2、多环境切换"><a href="#2、多环境切换" class="headerlink" title="2、多环境切换"></a>2、多环境切换</h3><p>profile配置方式：</p>
<p>​    多profile文件方式：提供多个配置文件，每个代表一种环境。</p>
<p>​        application-dev.properties/yml 开发环境</p>
<p>​        application-test.properties/yml 测试环境</p>
<p>​        application-pro.properties/yml 生产环境</p>
<p><strong>profile激活方式</strong></p>
<ul>
<li><strong>配置文件： 再配置文件中配置：spring.profiles.active=dev</strong></li>
<li>虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev</li>
<li><strong>命令行参数：java -jar XXX.jar –spring.profiles.active=dev</strong></li>
</ul>
<h3 id="3、项目内部配置文件加载顺序"><a href="#3、项目内部配置文件加载顺序" class="headerlink" title="3、项目内部配置文件加载顺序"></a>3、项目内部配置文件加载顺序</h3><p><strong>优先级：由高到底</strong></p>
<ul>
<li>file:./config/：当前项目下的/config目录下</li>
<li>file:./           ：当前项目的根目录</li>
<li>classpath:/config/：classpath的/config目录</li>
<li>classpath:/  ：classpath的根目录</li>
</ul>
<h3 id="4、项目外部配置文件加载顺序"><a href="#4、项目外部配置文件加载顺序" class="headerlink" title="4、项目外部配置文件加载顺序"></a>4、项目外部配置文件加载顺序</h3><ol>
<li>命令行</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar app.jar --name=&quot;Spring“ --server.port=<span class="number">9000</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指定配置文件位置</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.location=e://application.properties</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>外部不带profile的properties文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classpath:/config/application.properties</span><br><span class="line">classpath:/application.properties</span><br></pre></td></tr></table></figure>

<p><font color="red">小结：</font></p>
<ul>
<li><p><strong>整体加载优先级： jar包外  到  jar包内</strong></p>
</li>
<li><p>如果jar和配置文件在同一级，配置文件会生效，会被自动的加载</p>
</li>
<li><p>打包的时候 只会去打包classpath(src|main/resources)的配置文件，项目的根目录下的配置文件不会被打包到jar包中。</p>
</li>
</ul>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add * <span class="comment">#添加所有文件进入暂存区</span></span><br><span class="line"></span><br><span class="line">git reset <span class="comment">#将暂存区的文件取消暂存活着是切换到制定版本</span></span><br><span class="line"></span><br><span class="line">git reset --hard 3e83300001236f435942434a262e7bd04b345696<span class="comment">#回滚到某个版本</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;注释信息&quot;</span> hello.txt <span class="comment">#提交hello.txt到版本库</span></span><br><span class="line"></span><br><span class="line">git status <span class="comment">#查看状态</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">#查看日志 按q退出</span></span><br><span class="line">-----------------------------------------------<span class="comment">#下面是远程仓库的操作</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/f0qw/kkktest.git</span><br><span class="line"></span><br><span class="line">git remote -v <span class="comment">#查看远程仓库</span></span><br><span class="line"></span><br><span class="line">git remote add origin http://github.com/f0qw/kkktest.git<span class="comment">#添加远程仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment">#从远程仓库克隆</span></span><br><span class="line"></span><br><span class="line">git pull origin master<span class="comment">#从远程仓库拉取</span></span><br><span class="line"></span><br><span class="line">git push origin master<span class="comment">#推送到master分支  origin远程仓库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------<span class="comment">#下面是分支的操作</span></span><br><span class="line">git branch <span class="comment">#查看本地分支</span></span><br><span class="line">git branch -r <span class="comment">#查看远程仓库的分支</span></span><br><span class="line">git branch -a <span class="comment">#列出本地和远程的所有分支</span></span><br><span class="line"></span><br><span class="line">git branch [name]  <span class="comment">#创建分支</span></span><br><span class="line">git checkout [name] <span class="comment">#切换分支</span></span><br><span class="line">git push [远程仓库别名][分支名称]  <span class="comment">#推送至远程仓库分支</span></span><br><span class="line">git merge [name]  <span class="comment">#合并分支</span></span><br><span class="line"><span class="comment">#遇到合并分支冲突时可能会有 cannot do a partial comit during merge</span></span><br><span class="line"><span class="comment">#此时加个-i就可以解决问题</span></span><br><span class="line">git comit -m <span class="string">&quot;注释&quot;</span> a.txt -i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------<span class="comment">#标签的操作</span></span><br><span class="line">git tag <span class="comment">#列出已有的标签</span></span><br><span class="line">git tag [name] <span class="comment">#创建标签</span></span><br><span class="line">git push [远程仓库名][分支名称] <span class="comment">#将标签推送至远程仓库</span></span><br><span class="line">git checkout -b [branch][name] <span class="comment">#创建新分支检出标签</span></span><br></pre></td></tr></table></figure>







<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p>
</li>
<li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p>
</li>
</ul>
<p>如图：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220031938.png" alt="image-20210731154257653"></p>
<h2 id="二、Docker的基本操作"><a href="#二、Docker的基本操作" class="headerlink" title="二、Docker的基本操作"></a>二、Docker的基本操作</h2><h3 id="1、镜像命令"><a href="#1、镜像命令" class="headerlink" title="1、镜像命令"></a>1、镜像命令</h3><p>常见的镜像操作命令如图：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220032066.png" alt="image-20210731155649535"></p>
<p>注意：可以利用docker xx –help命令查看docker命令</p>
<p>例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220034373.png" alt="image-20210731161104732"></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>



<h3 id="2、容器操作"><a href="#2、容器操作" class="headerlink" title="2、容器操作"></a>2、容器操作</h3><p>容器操作的命令如图：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220035781.png" alt="image-20210731161950495"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run </span><br><span class="line">--name nacos \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">--<span class="built_in">link</span> mysql:mysql \   </span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \    </span><br><span class="line">-e  MYSQL_SERVICE_HOST=mysql \</span><br><span class="line">-e MYSQL_SERVICE_PORT=3306 \     </span><br><span class="line">-e MYSQL_SERVICE_DB_NAME=nacos \    </span><br><span class="line">-e MYSQL_SERVICE_USER=root \ 　　　　</span><br><span class="line">-e MYSQL_SERVICE_PASSWORD=root \　　</span><br><span class="line">-p 8848:8848 -d nacos/nacos-server:latest</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p>docker run：创建并运行一个容器，处于运行状态</p>
</li>
<li><p>docker pause：让一个运行的容器暂停</p>
</li>
<li><p>docker unpause：让一个容器从暂停状态恢复运行</p>
</li>
<li><p>docker stop：停止一个运行的容器</p>
</li>
<li><p>docker start：让一个停止的容器再次运行</p>
</li>
<li><p>docker rm：删除一个容器</p>
</li>
</ul>
<h3 id="3、数据卷"><a href="#3、数据卷" class="headerlink" title="3、数据卷"></a>3、数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220038290.png" alt="image-20210731173541846"></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p>
<h3 id="4、数据卷基本操作"><a href="#4、数据卷基本操作" class="headerlink" title="4、数据卷基本操作"></a>4、数据卷基本操作</h3><p>数据卷操作的基本语法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> [COMMAND]</span></span><br></pre></td></tr></table></figure>

<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="5、挂载数据卷"><a href="#5、挂载数据卷" class="headerlink" title="5、挂载数据卷"></a>5、挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>

<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
</ul>
<h3 id="6、创建mysql容器实例"><a href="#6、创建mysql容器实例" class="headerlink" title="6、创建mysql容器实例"></a>6、创建mysql容器实例</h3><p><strong>创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</strong></p>
<p>步骤如下：</p>
<p>1）获取mysql镜像</p>
<p>2）创建目录/tmp/mysql/data</p>
<p>3）创建目录/tmp/mysql/conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p>
<p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">拉取镜像:</span><br><span class="line">	docker pull mysql:5.6</span><br><span class="line">进入tmp目录,创建/tmp/mysql/data和/tmp/mysql/conf</span><br><span class="line">  <span class="built_in">mkdir</span> -p /tmp/mysql/data   // 存放生成的数据信息</span><br><span class="line">  <span class="built_in">mkdir</span> -p /tmp/mysql/conf   // 存放共享的配置文件信息</span><br><span class="line">将配置文件拷贝到/tmp/mysql/conf</span><br><span class="line">创建mysql容器,并绑定对应的文件夹和文件:</span><br><span class="line">  docker run \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -d \</span><br><span class="line">  -v /tmp/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/my.cnf \</span><br><span class="line">  --privileged \</span><br><span class="line">  mysql:5.6</span><br><span class="line">---------------------</span><br><span class="line">  docker run \   // 创建容器</span><br><span class="line">  --name mysql \ // 给容器起名</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=root \ // 设置root账户密码</span><br><span class="line">  -p 3306:3306 \ // 端口映射</span><br><span class="line">  -d \ // 后台运行</span><br><span class="line">  -v /tmp/mysql/data:/var/lib/mysql \ // 绑定宿主机上的文件夹</span><br><span class="line">  -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/my.cnf \ // 绑定宿主机上的文件</span><br><span class="line">  --privileged \ // 设置超级管理员远程访问权限</span><br><span class="line">  mysql:5.6 // 镜像名称</span><br></pre></td></tr></table></figure>

<h2 id="三、Dockerfile自定义镜像"><a href="#三、Dockerfile自定义镜像" class="headerlink" title="三、Dockerfile自定义镜像"></a>三、Dockerfile自定义镜像</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220044335.png" alt="image-20210731175806273"></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h3 id="1、Dockerfile语法"><a href="#1、Dockerfile语法" class="headerlink" title="1、Dockerfile语法"></a>1、Dockerfile语法</h3><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208220045874.png" alt="image-20210731180321133"></p>
<p>更新详细语法说明，可以参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h3 id="2、构建Java项目"><a href="#2、构建Java项目" class="headerlink" title="2、构建Java项目"></a>2、构建Java项目</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>

<p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>









]]></content>
  </entry>
  <entry>
    <title>Springboot学习笔记</title>
    <url>/2022/08/16/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>图片1:</p>
<p><img src="http://123.207.48.145:9001/kueen/202307081911758.png" alt="506182cd388c4f81b0c037ad3dbaa918"></p>
]]></content>
  </entry>
  <entry>
    <title>JavaTest</title>
    <url>/2023/03/13/test-fen-lei/</url>
    <content><![CDATA[<h1 id="JavaTest1"><a href="#JavaTest1" class="headerlink" title="JavaTest1"></a>JavaTest1</h1><p>hello</p>
<p><code>d </code></p>
<p>==aaad==</p>
<hr>
<blockquote>
<p>d d df </p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/13/test%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="自我介的绍"><a href="#自我介的绍" class="headerlink" title="自我介的绍"></a>自我介的绍</h1><p>hello等等</p>
]]></content>
  </entry>
  <entry>
    <title>Spring和SpringMVC学习笔记</title>
    <url>/2022/08/22/Spring%E5%92%8CSpringMVC/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="一、IOC"><a href="#一、IOC" class="headerlink" title="一、IOC"></a>一、IOC</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul>
<li>IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源；</li>
<li>Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器；</li>
<li>spring容器中存储的对象称为bean对象；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IOC(inversion of control): 控制反转,反转的是对象的创建权,用于削减程序之间的耦合关系,底层使用反射技术实现</span><br><span class="line">	传统方式创建对象:  <span class="keyword">new</span> 对象(); (主动创建)</span><br><span class="line">	IOC方式创建对象: 找容器(被动接收),本质上就是一个Map集合</span><br><span class="line"></span><br><span class="line">	作用：解耦</span><br><span class="line">		通过标记(标记就是配置文件中的key)找工厂,工厂帮我们创建对应的类对象,并返回给我们使用</span><br><span class="line">		当前类可以选择主动出击（<span class="keyword">new</span>的方式）创建对象，但是此时耦合度高。</span><br><span class="line">		把主动式改成被动接收，由工厂对象为当前类生产所必须的关联对象，此时降低了两个类的依赖关系。</span><br><span class="line">控制反转：资源创建的权限（比如dao）由应用方（service）转移到工厂去创建（factory,spring容器去创建）   </span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208211649128.png" alt="image-20220821164921028"></p>
<div style="background-color:orange">1.导入Spring的核心jar包的坐标:</div>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="background-color:orange">2.创建applicationContext.xml,并导入约束:</div>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- id: 容器中的唯一标识  class:被创建的类的全限定名(包名+类名) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="background-color:orange">3.获取IOC容器:</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.从类路径下解析xml配置文件,获取容器</span><br><span class="line"><span class="comment">// 将配置文件中放在resources</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">b.从磁盘路径下解析xml配置文件</span><br><span class="line"><span class="comment">// 将配置文件方法磁盘目录下</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;C:\Users\Administrator.DESKTOP-NG3ICNP\Desktop\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ApplicationContex</code>t: 当解析完applicationContext.xml文件后,立即创建类对象(饿汉加载模式)<br>    它是一个接口。是spring中的IOC容器接口,可以通过该接口的方法来获取想要的bean对象。需要提供bean的id。<br>    它有3个常用的实现类<br>         ClassPathXmlApplicationContext★:<br>                    它是用于读取类路径(resources)下的xml配置文件，不在类路径下读取不到<br>         FileSystemXmlApplicationContext:<br>                    它是读取文件系统中的配置文件，只要有访问权限，在文件系统中都能读取的到<br>         AnnotationConfigApplicationContext:<br>                    它是用于根据注解配置 创建容器的。</p>
<p>(★★)ApplicationContext它是在一读取完配置文件，就马上创建配置文件中所配置的所有对象。(得到IOC容器)</p>
<p><code>BeanFactory</code>:<br>     它是spring中ioc容器的顶层接口，ApplicationContext只是它的子接口。<br>     它提供创建容器中对象的时机，使用延迟加载(懒加载)的思想。而ApplicationContext不仅继承了它的加载方式，而且还扩展出来了立即加载思想的创建容器的方式。<br>     它是每次在使用时才真正的创建对象。</p>
</blockquote>
<h3 id="2、创建Bean对象的三种方式"><a href="#2、创建Bean对象的三种方式" class="headerlink" title="2、创建Bean对象的三种方式"></a>2、创建Bean对象的三种方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方式1: 无参构造创建对象,存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;AccountService1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式2: 调用工厂的静态方法创建类对象,存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        调用工厂的静态方法,将方法的返回值存放到IOC容器中</span></span><br><span class="line"><span class="comment">           id: 存放到IOC容器时,对象的唯一标识</span></span><br><span class="line"><span class="comment">           class: 工厂的全限定名</span></span><br><span class="line"><span class="comment">           factory-method: 指定静态方法名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;AccountService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.factory.MethodFactory&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-method</span>=<span class="string">&quot;createObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式3: 调用工厂的非静态方法创建类对象,存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.1: 创建工厂类对象,并存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.MethodFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.2: 调用工厂实例的非静态方法创建类对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        调用工厂的非静态方法,将非静态方法的返回值存放到IOC容器中</span></span><br><span class="line"><span class="comment">            id:存放到IOC容器时,对象的唯一标识</span></span><br><span class="line"><span class="comment">            factory-bean:工厂对象实例的引用</span></span><br><span class="line"><span class="comment">            factory-method:调用实例工厂的非静态方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;AccountService3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;methodFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createObject1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3、Bean对象的作用范围"><a href="#3、Bean对象的作用范围" class="headerlink" title="3、Bean对象的作用范围"></a>3、Bean对象的作用范围</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">class</span>=<span class="string">&quot; &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">bean的作用范围调整：</span><br><span class="line">    调整bean的作用范围，使用的是bean标签的scope属性。</span><br><span class="line">    它的属性取值有以下5个</span><br><span class="line">      singleton           : 单例对象      用的最多的           它是默认值(最常用)</span><br><span class="line">      prototype           ：多例对象       用的最多的</span><br><span class="line">      ------------------------------------</span><br><span class="line">      request             ：请求范围      (存入了请求域)</span><br><span class="line">      session             ：会话范围      (存入了会话域)</span><br><span class="line">      global-session      ：全局会话范围   当非集群环境下，它就是session</span><br><span class="line">-------------</span><br><span class="line">如果是有状态的bean选择多例；</span><br><span class="line">如估无无状态的bean选择单例；</span><br></pre></td></tr></table></figure>

<h3 id="4、Bean对象的生命周期"><a href="#4、Bean对象的生命周期" class="headerlink" title="4、Bean对象的生命周期"></a>4、Bean对象的生命周期</h3><p>bean对象的生命周期: 从加载到内存哪一刻起对象就出生了,当对象从内存中移除时,对象的生命就完结了</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">bean的生命周期:</span><br><span class="line">    单例对象: 将创建的bean放入容器</span><br><span class="line">    	出生:容器创建，对象出生</span><br><span class="line">    	活着:只要容器在，对象就一直活着</span><br><span class="line">    	死亡:容器销毁，对象消亡</span><br><span class="line">    特点: 生命周期与容器相同</span><br><span class="line">	&lt;!--</span><br><span class="line">        单例对象:</span><br><span class="line">            init-method: 初始化方法（构造器初始化对象之后被调用）</span><br><span class="line">            destroy-method: 销毁时调用的方法（对象被销毁之前被调用）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=&quot;AccountService&quot; class=&quot;com.study.service.impl.AccountServiceImpl&quot;</span><br><span class="line">          init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">多例对象：</span><br><span class="line">    出生：每次使用时创建</span><br><span class="line">    活着：在使用过程中</span><br><span class="line">    死亡：使用完成之后，等待垃圾回收器回收。gc，也就是说多例模式下spring不负责对象的销毁，不会执行destroy方法；</span><br><span class="line">    	多实例bean对象的生命周期</span><br><span class="line">            scope的值必须为: prototype</span><br></pre></td></tr></table></figure>



<h2 id="二、依赖注入DI"><a href="#二、依赖注入DI" class="headerlink" title="二、依赖注入DI"></a>二、依赖注入DI</h2><h3 id="1、依赖注入概述"><a href="#1、依赖注入概述" class="headerlink" title="1、依赖注入概述"></a>1、依赖注入概述</h3><ul>
<li><p>IoC与DI是同一件事站在不同角度看待问题</p>
<p>​    在<font color='red'>应用程序的角度</font>看程序需要被动等待Spring提供资源（注入资源）是DI;</p>
<p>​    但是在<font color='red'>Spring容器的角度</font>看是，是将资源的创建权利做了翻转，且由容器提供数据，是IOC;</p>
</li>
</ul>
<h3 id="2、注入数据的方式和类型"><a href="#2、注入数据的方式和类型" class="headerlink" title="2、注入数据的方式和类型"></a>2、注入数据的方式和类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spring中的依赖注入：</span><br><span class="line">    注入的方式有三种：</span><br><span class="line">        第一种：使用构造方法注入</span><br><span class="line">            要求：必须有对应参数列表的构造函数</span><br><span class="line">        第二种：使用setter方法注入（XML开发主流）</span><br><span class="line">            要求：提供被注入对象的set方法（不需要get方法）</span><br><span class="line">        第三种：使用注解注入</span><br><span class="line"></span><br><span class="line">    注入的数据类型有三类：</span><br><span class="line">        第一类：基本类型和String</span><br><span class="line">        第二类：其他bean类型</span><br><span class="line">            要求：其他bean指的是在spring的配置文件中定义过的bean，或者是用注解注释过的类。</span><br><span class="line">        第三类：复杂类型（集合类型）</span><br><span class="line">            Array: 数组</span><br><span class="line">            List:</span><br><span class="line">            Map:</span><br><span class="line">            Properties:</span><br></pre></td></tr></table></figure>

<div style="background-color:orange">示例代码:</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖注入:</span><br><span class="line">            在创建对象时,给对象中的属性赋值</span><br><span class="line">         依赖注入方式:</span><br><span class="line">            方式<span class="number">1</span>: 有参构造</span><br><span class="line">            方式<span class="number">2</span>: setter方法</span><br><span class="line">            方式<span class="number">3</span>: 注解</span><br><span class="line">         依赖注入的数据类型:</span><br><span class="line">            基本类型和String</span><br><span class="line">            其他bean对象</span><br><span class="line">            数组</span><br><span class="line">            List</span><br><span class="line">            Map</span><br><span class="line">            Properties</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- 方式<span class="number">1</span>: 有参构造 --&gt;</span><br><span class="line">    &lt;!--&lt;bean id=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;com.study&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;port&quot;</span> value=<span class="string">&quot;3306&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;--&gt;</span><br><span class="line">    &lt;!-- 方式<span class="number">2</span>: 通过setter方法注入 ****--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;com.study&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;port&quot;</span> value=<span class="string">&quot;3306&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入其他bean类型 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;user&quot;</span> ref=<span class="string">&quot;user&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入数组 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;strArr&quot;</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;宝强&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;乃亮&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;羽凡&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;大郎&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入list --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;蓉蓉&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;璐璐&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;合合&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;莲莲&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--  注入map--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;map&quot;</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;波波&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;18&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;妖&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入properties --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;prop&quot;</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=<span class="string">&quot;name&quot;</span>&gt;昌老师&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">&quot;age&quot;</span>&gt;<span class="number">40</span>&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 创建user对象存放到IOC容器中 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.study.User&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;xxx&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3、解析property配置文件"><a href="#3、解析property配置文件" class="headerlink" title="3、解析property配置文件"></a>3、解析property配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解析Properties配置文件,将配置文件中的数据存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> <span class="attr">file-encoding</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="三、注解方式"><a href="#三、注解方式" class="headerlink" title="三、注解方式"></a>三、注解方式</h2><h3 id="1、启动注解功能"><a href="#1、启动注解功能" class="headerlink" title="1、启动注解功能"></a>1、启动注解功能</h3><ul>
<li><p>在spring XML配置文件中启动注解扫描，加载类中配置的注解项</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;packageName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>说明：</p>
<ul>
<li><p>在进行包所扫描时，会<font color='red'>对配置的包及其子包中所有文件</font>进行扫描;</p>
</li>
<li><p>扫描过程是以文件夹递归迭代的形式进行的;</p>
</li>
<li><p>扫描过程仅读取合法的java文件</p>
</li>
<li><p>扫描时仅读取spring可识别的注解</p>
</li>
<li><p>扫描结束后会将可识别的有效注解<font color='red'>转化为spring对应的资源加入IoC容器</font></p>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><strong>无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中</strong>，差别仅仅是数据读取方式不同</li>
<li>从加载效率上来说注解优于XML配置文件</li>
</ul>
</li>
</ul>
<h3 id="2、定义bean的常用注解"><a href="#2、定义bean的常用注解" class="headerlink" title="2、定义bean的常用注解"></a>2、定义bean的常用注解</h3><ul>
<li><p>名称：@Component    @Controller    @Service    @Repository</p>
</li>
<li><p>类型：<strong>类注解</strong></p>
</li>
<li><p>位置：<strong>类的定义上方</strong></p>
</li>
<li><p>作用：设置该类为spring管理的bean</p>
</li>
<li><p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>说明：</p>
<ul>
<li><p>以上注解相当于xml 中的bean标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>@Controller、@Service 、@Repository是@Component的衍生注解，功能同@Component</p>
</li>
<li><p>@Controller(控制层注解)、@Service（服务层注解） 、@Repository（持久层注解）只是提供了更加明确的语义化(见名知意)，精确指出是哪一层的对象,但不是强制要求的；</p>
</li>
</ul>
</li>
<li><p>相关属性</p>
<ul>
<li>value（默认）：定义bean的访问id</li>
</ul>
</li>
</ul>
<h3 id="3、bean的属性数据注入常用注解"><a href="#3、bean的属性数据注入常用注解" class="headerlink" title="3、bean的属性数据注入常用注解"></a>3、bean的属性数据注入常用注解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">以下注解它们就相当于：</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">或</span> <span class="attr">value</span>=<span class="string">&quot;基本类型数据或String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">------------------------</span><br><span class="line">这些注解使用在属性上,用于给对象中的属性进行赋值</span><br><span class="line">引用类型：</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier</span><br><span class="line">    @Resource</span><br><span class="line">基本类型+String：</span><br><span class="line">    @Value   可以支持Spring的EL表达式(SPEL)，写法就是$&#123;表达式&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、作用范围和生命周期相关注解"><a href="#4、作用范围和生命周期相关注解" class="headerlink" title="4、作用范围和生命周期相关注解"></a>4、作用范围和生命周期相关注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>: 相当于bean标签的scope属性</span><br><span class="line">	作用：用于调整bean的作用范围</span><br><span class="line">	使用位置: 被创建的类上</span><br><span class="line">	属性：</span><br><span class="line">		value：指定作用范围的取值。取值是固定的<span class="number">5</span>个，和XML的配置取值是一样的。</span><br><span class="line">			singleton: 单实例 默认值</span><br><span class="line">			prototype: 多实例</span><br><span class="line"><span class="meta">@PostConstruct</span> : 使用在方法上</span><br><span class="line">	使用位置: 初始化的方法上</span><br><span class="line">	​作用：指定初始化方法，相当于init-method</span><br><span class="line"><span class="meta">@PreDestroy</span> : 使用在方法上</span><br><span class="line">	​作用：指定销毁方法，相当于destroy-method</span><br></pre></td></tr></table></figure>

<h3 id="5、纯注解格式★"><a href="#5、纯注解格式★" class="headerlink" title="5、纯注解格式★"></a>5、纯注解格式★</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们需要使用配置类代替配置文件,将以下注解写在配置类上</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>: 声明该类为Spring的配置文件类</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.itheima&quot;)</span> : 指定要扫描的包</span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span> : 将配置文件交给Spring容器管理</span><br><span class="line"><span class="meta">@Bean()</span> : 将方法返回的对象存放到IOC容器中</span><br><span class="line">	将返回值存放到IOC容器中</span><br><span class="line">	一般将【第三方提供的类】对加载到IOC容器</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * Spring的核心配置类</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 声明配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span> <span class="comment">// 开启包扫描</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="comment">// 解析properties配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;template&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSource&quot;)</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        template.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Spring整合junit"><a href="#6、Spring整合junit" class="headerlink" title="6、Spring整合junit"></a>6、Spring整合junit</h3><p>使用步骤:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>导入jar包坐标</span><br><span class="line">	&lt;!-- 引入单元测试的jar包 <span class="number">4.12</span>以上 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 导入Spring整合junit的jar包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.0</span><span class="number">.2</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"><span class="number">2.</span>使用</span><br><span class="line">	在测试类上添加以下两个注解:</span><br><span class="line">	<span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line">	<span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span> (配置xml文件的路径)</span><br><span class="line">	或者：</span><br><span class="line">	<span class="meta">@ContextConfiguration(classes=SpringConfig.class)</span> (配置类)</span><br></pre></td></tr></table></figure>

<h2 id="四、Spring-AOP"><a href="#四、Spring-AOP" class="headerlink" title="四、Spring-AOP"></a>四、Spring-AOP</h2><h3 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h3><ul>
<li><p>Target（目标对象）:   要增强的对象(被代理的类对象)</p>
</li>
<li><p>Proxy（代理对象） :  对目标对象的增强的对象 (生成的代理类对象)</p>
</li>
<li><p>Joinpoint（连接点）:  目标对象中的所有方法(被代理类中的所有方法)–》可以被增强的方法</p>
</li>
<li><p>Pointcut（切入点）:   要被增强的方法(被代理类中要增强的方法)</p>
</li>
<li><p>Advice（通知/增强）:  增强的那段【代码方法】以及代码切入的位置</p>
<p>​                通知包含了2个维度内容：<strong>在增强方法的什么位置，切入什么代码；</strong></p>
<pre><code>前置通知：在方法之前进行增强

后置通知 ：在方法之后进行增强

异常通知：在方法异常进行增强

最终通知 ：最终执行的方法进行增强

环绕通知:  单独使用（以上所有通知）
</code></pre>
</li>
<li><p><strong>Aspect(切面):</strong> 切入点+通知=切面</p>
</li>
</ul>
<p>​                目标方法和增强方法合到在一起 叫做切面</p>
<p>​                说白了切面描述了在什么样的目标方法下(切入点)的什么位置（通知类型）切入了什么样的(增强代码）</p>
<ul>
<li><p>Weaving（织入）：</p>
<p>​          将增强的代码（方法）合并到目标方法的过程 叫织入过程;    </p>
</li>
</ul>
<p>Spring AOP底层实现技术就是动态代理</p>
<p>spring底层会自动抉择使用Jdk Proxy或Enhancer(cglib)</p>
<h3 id="2、AOP开发方式"><a href="#2、AOP开发方式" class="headerlink" title="2、AOP开发方式"></a>2、AOP开发方式</h3><ul>
<li><p>XML方式</p>
</li>
<li><p>XML+注解方式</p>
</li>
<li><p>注解方式</p>
</li>
</ul>
<h3 id="3、全xml方式实现AOP【最繁琐的】"><a href="#3、全xml方式实现AOP【最繁琐的】" class="headerlink" title="3、全xml方式实现AOP【最繁琐的】"></a>3、全xml方式实现AOP【最繁琐的】</h3><blockquote>
<p>例子：</p>
<p>对AccountServiceImpl下的方法进行增强;<br>步骤如下：<br>1.导入相关jar坐标;<br>2.自己封装要增强方法，并保存在某个专用类中【切面类/通知类/增强类】<br>3.将所有进行AOP操作的资源【切面类+目标对象】加载到IOC容器中；<br>4.编写配置文件<br>    告诉spring【切面类中的增强方法】在哪个对象的哪个方法上增强使用（配置切面）；</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将目标类(被增强的类)存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将切面类加载到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.aspect.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 面向切面编程====织入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点表达式 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定切面类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- method: 调用的通知方法  pointcut: 切入点是什么 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.study.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.itheima.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.itheima.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.study.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.study.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">切入点表达式:</span><br><span class="line">作用: 找到那些被增强的方法,类似正则表达式</span><br><span class="line">格式:</span><br><span class="line">    修饰符 返回值 方法的全限定名(参数列表)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> com.study.service.impl.AccountServiceImpl.delete()</span><br><span class="line">    说明：修饰符可省略不写，默认<span class="keyword">public</span>    </span><br><span class="line">支持通配符的写法：</span><br><span class="line">    *   ： 表示任意字符串</span><br><span class="line">    ..  ： 任意重复次数</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* *(..)) <span class="comment">//说明：第一个*表示任意返回值类型，第二个*匹配任意类，..匹配任意参数，该表达式表示匹配任意类的任意方法（简化书写方式，很少用到）</span></span><br><span class="line">execution(* *..*(..))<span class="comment">//同上</span></span><br><span class="line">execution(* *..*.*(..))<span class="comment">//同上，更符合书写习惯，第一个*表示匹配任意返回值类型，*..表示匹配任意包名称及其任意子包，第三个*匹配任意类，第四个匹配任意方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *..*.*(..))<span class="comment">//表示匹配任意public修饰符的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> *..*.*(..))<span class="comment">//表示陪陪任意返回值是int类型且修饰符是public的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> *..*.*(..))<span class="comment">//匹配任意返回值是void且修饰符是public的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..*.*(..))<span class="comment">//匹配com包及其任意子包下的被pulic修饰的返回值是void的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..service.*.*(..))<span class="comment">//匹配com包下任意子包下存在service包下的任意类的任意方法，且方法为void 被public修饰</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.User*.*(..))<span class="comment">//侧重点：任意一User开头的类下的任意void且被public修饰的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.*Service.*(..))<span class="comment">//侧重点：任意一Service结尾的类下的任意方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.UserService.*(..))<span class="comment">//匹配UserService类下的任意方法...</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.find*(..))<span class="comment">//侧重点：匹配UserService类下的任意以find开头的任意方法...</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.*Id(..))<span class="comment">//侧点：匹配UserService类下的任意以id结尾的任意方法...</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(..))<span class="comment">//侧重点：匹配UserService类下方法名为findById的任意参数的方法....</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(<span class="type">int</span>))<span class="comment">//精准匹配，方法入参只有一个int类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(<span class="type">int</span>,<span class="type">int</span>))<span class="comment">//精准匹配，方法入参包含2个int类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(<span class="type">int</span>,*))<span class="comment">//2个入参，第一个必须int，第二个任意类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(*,<span class="type">int</span>))<span class="comment">//2个入参，第一个任意类型，第二个必须int类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById())<span class="comment">//精准匹配无参</span></span><br><span class="line">execution(List com.study.service.*Service+.findAll(..))<span class="comment">//匹配任意以Service结尾的接口或者实现类下方法名为findAll的任意入参方法</span></span><br></pre></td></tr></table></figure>

<h3 id="4、半xml半注解实现AOP"><a href="#4、半xml半注解实现AOP" class="headerlink" title="4、半xml半注解实现AOP"></a>4、半xml半注解实现AOP</h3><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><div style='background-color:orange;'>1.开启包扫描</div>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启需要扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明当前项目可以使用AOP的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style='background-color:orange;'>2.在切面类中添加相关注解</div>    

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注解：</span><br><span class="line">	<span class="meta">@Aspect</span> ： 声明切面类</span><br><span class="line">	<span class="meta">@PonitCut</span>：定义公共的切入点</span><br><span class="line">			配置到空方法上，value：切入点表达式</span><br><span class="line">			引用：方法名()</span><br><span class="line">配置通知类型：</span><br><span class="line">    <span class="meta">@Before()</span> : 前置通知</span><br><span class="line">    <span class="meta">@AfterReturning()</span> ： 后置通知</span><br><span class="line">    <span class="meta">@AfterThrowing()</span>  ：异常通知</span><br><span class="line">    <span class="meta">@After()</span>			：最终通知</span><br><span class="line">    <span class="meta">@Around()</span>			：环绕通知</span><br></pre></td></tr></table></figure>

<h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码:"></a>相关代码:</h4><p><strong>1.导入jar包坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring核心jar包,已经依赖的AOP的jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.切面类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此类我们称之为切面类,在切面类中存放有各种通知</span></span><br><span class="line"><span class="comment"> * 切面 = 切入点 + 通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 声明此类为切面类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置切入点表达式</span></span><br><span class="line"><span class="comment">     * 调用切入点表单时,直接使用 方法名称()</span></span><br><span class="line"><span class="comment">     *      pt()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*.AccountServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知:11111111111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知:22222222222222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知:33333333333333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知:44444444444444&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 连接点 ---&gt; 切入点</span></span><br><span class="line"><span class="comment">     *        ProceedingJoinPoint: method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强--111111111111&quot;</span>);</span><br><span class="line">            <span class="comment">// 让原方法执行  method.invoke()</span></span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强--222222222222&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">//throwable.printStackTrace();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异常增强--333333333333&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;最终增强--444444444444&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.applicationContext.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启对Spring-AOP注解的支持 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5、全注解实现AOP"><a href="#5、全注解实现AOP" class="headerlink" title="5、全注解实现AOP"></a>5、全注解实现AOP</h3><p>@EnableAspectJAutoProxy ： 开启对AOP注解的支持</p>
<h5 id="aop全注解代码"><a href="#aop全注解代码" class="headerlink" title="aop全注解代码"></a>aop全注解代码</h5><p><strong>配置类代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 声明此类为Spring的配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.study&quot;)</span> <span class="comment">// 设置需要扫描的包(开启对Spring注解的支持)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 开启对AOP注解的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>切面类代码同上</strong></p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="一、回顾Servlet"><a href="#一、回顾Servlet" class="headerlink" title="一、回顾Servlet"></a>一、回顾Servlet</h2><p>Servlet:<br>    运行在服务器上的java小程序.<br>    本质上就是java代码,这个java代码可以被web服务器调用</p>
<p>【1】生命周期:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例化,创建一个对象放内存</span><br><span class="line">    默认第一次请求Servlet时,会创建Servlet对象,并调用init方法进行初始化操作</span><br><span class="line">    load-on-startup: 设置servlet的初始化时机</span><br><span class="line">    取值: 正整数,值越小优先级越高</span><br><span class="line">    初始化,创建完对象后,调用对象的方法进行初始化 </span><br><span class="line">    init(): 初始化方法</span><br><span class="line">    	当对象实例化完毕后,立即调用init方法完成初始化工作, <span class="number">1</span>次</span><br><span class="line">    service(): 提供服务</span><br><span class="line">    	每次请求来的时候,tomcat都会调用service方法提供服务, 请求一次执行一次</span><br><span class="line">    destory(): 销毁方法</span><br><span class="line">    	当对象从内存中移除前调用destory方法进行销毁工作, <span class="number">1</span>次</span><br></pre></td></tr></table></figure>

<p>【2】Servletconfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>web.xml配置：</span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">           	 &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;</span><br><span class="line">           	 &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo&lt;/servlet-class&gt;</span><br><span class="line">            	&lt;!--配置初始化参数--&gt;</span><br><span class="line">            	&lt;init-param&gt;</span><br><span class="line">                   &lt;!--用于获取初始化参数的key--&gt;</span><br><span class="line">                	&lt;param-name&gt;key&lt;/param-name&gt;</span><br><span class="line">                    &lt;!--初始化参数的值--&gt;</span><br><span class="line">                	&lt;param-value&gt;value&lt;/param-value&gt;</span><br><span class="line">            	&lt;/init-param&gt;</span><br><span class="line">         &lt;/servlet&gt;	</span><br><span class="line">          <span class="number">2.</span>java代码</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">                <span class="comment">//get config and do something</span></span><br><span class="line">                 config.getInitParameter(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure>

<p>【3】ServletContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext对象，它是应用上下文对象；</span><br><span class="line">           每一个应用有且【只有一个】ServletContext对象；</span><br><span class="line">           它可以实现让应用中所有Servlet间的数据共享；</span><br><span class="line">          eg: <span class="number">1.</span>web.xml配置：</span><br><span class="line">                &lt;!--配置应用初始化参数--&gt;</span><br><span class="line">                &lt;context-param&gt;</span><br><span class="line">                    &lt;!--用于获取初始化参数的key--&gt;</span><br><span class="line">                    &lt;param-name&gt;servletContextInfo&lt;/param-name&gt;</span><br><span class="line">                    &lt;!--初始化参数的值--&gt;</span><br><span class="line">                    &lt;param-value&gt;This is application scope&lt;/param-value&gt;</span><br><span class="line">                &lt;/context-param&gt;</span><br><span class="line">             <span class="number">2.</span>java代码示例：</span><br><span class="line">                getServletContext();</span><br><span class="line">                getInitParameter(<span class="string">&quot;servletContextInfo&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="二、SpringMVC概述"><a href="#二、SpringMVC概述" class="headerlink" title="二、SpringMVC概述"></a>二、SpringMVC概述</h2><p><strong>SpringMVC</strong> 顾名思义就是Spring对MVC架构的一种实现，属于轻量级的WEB框架。 </p>
<p>​    它通过一个简单的<strong>注解</strong>就可以让一个普通的Java类成为控制器，这种<strong>低侵入性的设计</strong>使得他备受业界欢迎 </p>
<p>​    同时他还支持RestFul风格的编程风格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringMVC是spring对web层进行的封装,提供的MVC架构</span><br><span class="line">    M（模型）: </span><br><span class="line">		Model可以叫做数据模型层，说白了就是用来封装数据的</span><br><span class="line">        例如：用户发送注册请求，那么请求的信息会被SpingMMVC封装到User实体类中，这个实体类就属于Model层；</span><br><span class="line">             用户发送查询个人信息的请求，那么后台也会将个人信息封装到一个User类型，数据同样也是Model层；</span><br><span class="line">            </span><br><span class="line">	V（视图）: </span><br><span class="line">		View说白了就是SpringMVC响应请求的一种数据展示（最终的执行结果）：</span><br><span class="line">		例如：SpringMVC响应的数据方式：JSP、json、xml、html等</span><br><span class="line"></span><br><span class="line">    C（控制）: </span><br><span class="line">		控制层就用来处理交互的部分，接收用户请求，然后执行业务等流程，最终反馈结果；</span><br><span class="line">	    控制器,本质上就是一个Servlet,一切请求都访问这个Servlet,在这个Servlet中进行调度</span><br><span class="line">            SpringMVC可以通过一个简单的注解,就能让浏览器访问到对应的方法.</span><br><span class="line">            <span class="meta">@RequestMapping(&quot;/请求路径&quot;)</span></span><br><span class="line">    总之，这个唯一的Servlet核心控制器会【根据请求的url匹配基于注解的url】，完成请求处理；</span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212240313.png" alt="image-20220821224047251"></p>
<h3 id="1、核心Servlet配置文件"><a href="#1、核心Servlet配置文件" class="headerlink" title="1、核心Servlet配置文件"></a>1、核心Servlet配置文件</h3><p>编写web.xml文件</p>
<p>在web.xml文件中配置核心控制器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">		  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        服务器启动时只会加载web项目的核心配置文件 web.xml</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SpringMVC的核心Servlet: 前端控制器 (由SpringMVC框架提供)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置SpringMVC的核心配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 我们给前端控制器配置的路径为 / (缺省匹配)可以匹配浏览器发送的所以请求</span></span><br><span class="line"><span class="comment">             注意: jsp除外</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、SpringMVC配置文件"><a href="#2、SpringMVC配置文件" class="headerlink" title="2、SpringMVC配置文件"></a>2、SpringMVC配置文件</h3><p>spring-mvc.xml约束头</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启包扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器: 生成前缀和后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将可能使用到的处理器适配器,处理器映射器,视图解析器统统的加载到内存中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><h4 id="【1】启动初始化顺序"><a href="#【1】启动初始化顺序" class="headerlink" title="【1】启动初始化顺序"></a>【1】启动初始化顺序</h4><p>​        资源准备阶段：</p>
<p>​        （1）打包好war包，部署到Tomcat中==》mavne的自动发布插件完成</p>
<p>​        （2）Tomcat启动，加载web.xml文件</p>
<p>​        （3）初始化前端控制器：dispatcherServlet配置</p>
<p>​        （4）根据<strong>contextConfigLocation</strong>加载springmvc.xml配置</p>
<p>​        （5）根据spring-mvc.xml配置完成spring容器的初始化；</p>
<p>​            时序图：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212247249.png" alt="image-20191203171050122"></p>
<h4 id="【2】请求处理顺序"><a href="#【2】请求处理顺序" class="headerlink" title="【2】请求处理顺序"></a>【2】请求处理顺序</h4><p>（1）浏览器发起 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 请求</p>
<p>（2）Tomcat调用dispatcherServlet拦截/hello</p>
<p>（3）dispatcherServlet调用一个处理器，根据请求路径[/hello]找对对应的处理方法（这里被@RequestMapping注释的方法）【处理器映射器】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">处理器映射器：处理浏览器请求，根据路径映射到指定发方法；</span></span><br><span class="line"><span class="attr">eg</span>:<span class="string"></span></span><br><span class="line"><span class="attr">/hello-----&gt;com.heima.controller.HelloController#hello()</span></span><br></pre></td></tr></table></figure>

<p>（4）dispatcherServlet找到方法后，调用另外一种处理器，执行HelloController中的hello()方法【处理器适配器】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">处理器适配器：</span></span><br><span class="line"><span class="attr">1.适配处理器handler类型（在这里对应的处理器是hello()方法）；</span></span><br><span class="line"><span class="attr">2.处理入参，把对应的参数直接封装为一个实体；</span></span><br></pre></td></tr></table></figure>

<p>（5）HelloController中的hello()方法有返回值，创建ModelAndVIew（包含响应数据，页面）</p>
<p>（6）dispatcherServlet调用视图解析器，组装响应对象，然后把页面返回给浏览器【视图解析器】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">视图解析器：把方法返回的ModelAndVIew，进行页面和数据的整合，标签根据传入的view进行页面跳转</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212248714.png" alt="image-20220821224827632"></p>
<ul>
<li><p>前端控制器：DispatcherServlet 是整体流程控制的中心，由其调用其它组件处理用户的请求， 有<br>效的降低了组件间的耦合性；</p>
</li>
<li><p>处理器：handler,业务处理的核心类，通常由我们自己编写,比如：HelloController类等；</p>
</li>
<li><p><strong>处理器映射器</strong>：负责根据URL请求找到对应的Handler处理器(就是根据请求URL与Controller方法的关系)</p>
</li>
<li><p><strong>处理器适配器</strong>：将请求参数解析转换成处理器的入参，并调用处理器执行的组件； </p>
</li>
<li><p><strong>视图解析器</strong>：将处理器执行的结果生成View视图（将逻辑视图转换成物理视图）</p>
</li>
<li><p>视图：View，最终产出结果， 常用视图如：jsp、 html  </p>
</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212249484.png" alt="image-20200426183313406"></p>
<h2 id="四、常用注解"><a href="#四、常用注解" class="headerlink" title="四、常用注解"></a>四、常用注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line">	类上:</span><br><span class="line">		窄化类,访问此类中的方法时,必须加上类上的路径</span><br><span class="line">	方法:</span><br><span class="line">		建立绑定路径与方法的对应关系</span><br><span class="line">           常用属性 :</span><br><span class="line">		value或者path: 用来指定路径,默认选项 </span><br><span class="line">		method: 用来限定请求的方式 </span><br><span class="line">               例如：RequestMapping(value = <span class="string">&quot;/test03&quot;</span>,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br><span class="line">		params: 用来限定请求参数 </span><br><span class="line">               例如：<span class="meta">@RequestMapping(value = &quot;/test04&quot;,params = &#123;&quot;username&quot;,&quot;password&quot;&#125;)</span></span><br><span class="line">		headers: 用来限定请求必须携带指定的请求头</span><br><span class="line">		以上的属性可以单独使用，也可以组合使用，组合使用时，必须同时满足才行。</span><br><span class="line"><span class="meta">@GetMapping()</span>  : 只能处理get请求</span><br><span class="line"><span class="meta">@PostMapping()</span> : 只能处理post请求</span><br><span class="line"><span class="meta">@PutMapping()</span> : 只能处理put请求</span><br><span class="line"><span class="meta">@DeleteMapping()</span> :只能处理delete请求</span><br></pre></td></tr></table></figure>

<h2 id="五、获取请求参数"><a href="#五、获取请求参数" class="headerlink" title="五、获取请求参数"></a>五、获取请求参数</h2><p>SpringMVC支持的参数类型有 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>基本数据类型和string</span><br><span class="line"><span class="number">2.</span>vo类型(View object,浏览器携带的所有数据封装成的对象叫做vo)  </span><br><span class="line">     	要求：请求参数的名称必须和对象中的属性名保持一致</span><br><span class="line"><span class="number">3.</span>复杂类型：    </span><br><span class="line">	<span class="number">3.</span>数组类型 </span><br><span class="line">     		要求：保证前端传递的参数名称跟方法中的数组形参名称一致就好。 </span><br><span class="line">	<span class="number">4.</span>集合类型 </span><br><span class="line">     		获取集合参数时，要将集合参数包装到一个Vo中才可以。</span><br><span class="line">说明：</span><br><span class="line">如果请求中携带这些类型的数据,SpringMVC会自动帮我们接收,并传递给方法进行使用,【方法上的形参名称必须要和请求参数名称保持一致】；</span><br></pre></td></tr></table></figure>

<h2 id="六、特殊情况"><a href="#六、特殊情况" class="headerlink" title="六、特殊情况"></a>六、特殊情况</h2><h4 id="1、日期处理"><a href="#1、日期处理" class="headerlink" title="1、日期处理"></a>1、日期处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果请求携带的参数为日期类型,SpringMVC没有提供相关的转换器,哪该如何处理呢?</span><br><span class="line">我们可以使用SpringMVC提供的注解进行日期格式化操作.</span><br><span class="line"><span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">说明：</span><br><span class="line">    此时springmvc.xml中必须要开启注解驱动： &lt;mvc:annotation-driven/&gt;    </span><br></pre></td></tr></table></figure>

<h4 id="2、编码过滤器"><a href="#2、编码过滤器" class="headerlink" title="2、编码过滤器"></a>2、编码过滤器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">若请求携带了中文有乱码的情况</span><br><span class="line">   在SpringMVC中已经提供好了编码过滤器,可以直接使用即可</span><br><span class="line">    <span class="comment">&lt;!-- 在web.xml中配置springMVC编码过滤器 --&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">			org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- 设置过滤器中的属性值 --&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">		    	      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!-- 过滤所有请求 --&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、请求参数名称不一致"><a href="#3、请求参数名称不一致" class="headerlink" title="3、请求参数名称不一致"></a>3、请求参数名称不一致</h4><p>@RequestParam : 主要用于在SpringMVC后台控制层获取参数时，前端传入的参数和方法形参不一致时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">它支持三个属性: </span><br><span class="line">	value：默认属性，用于指定前端传入的参数名称 </span><br><span class="line">	required：用于指定此参数是否必传 </span><br><span class="line">	defaultValue：当参数为非必传参数且前端没有传入参数时，指定一个默认值。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/params/demo8?username=张三&quot;</span>&gt;请求参数-基本类型&lt;/a&gt; &lt;br&gt;</span><br><span class="line">------------------------------</span><br><span class="line"><span class="meta">@RequestMapping(&quot;demo8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo1</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;tom&quot;,required = false,value = &quot;name&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、获取请求头信息"><a href="#4、获取请求头信息" class="headerlink" title="4、获取请求头信息"></a>4、获取请求头信息</h4><p>@RequestHeader</p>
<p><strong>作用:</strong> 主要用于从请求头中获取参数。它支持的属性跟@RequestParam一样。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo2</span><span class="params">(<span class="meta">@RequestHeader(&quot;cookie&quot;)</span> String cookie, HttpServletResponse response)</span>&#123;</span><br><span class="line">    System.out.println(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、获取cookie信息"><a href="#5、获取cookie信息" class="headerlink" title="5、获取cookie信息"></a>5、获取cookie信息</h4><p>@CookieValue</p>
<p><strong>作用:</strong> 用于从cookie中取值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意: cookie的key值区分大小写</span><br><span class="line"><span class="meta">@RequestMapping(&quot;demo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo3</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line">    System.out.println(jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、同步请求的响应"><a href="#七、同步请求的响应" class="headerlink" title="七、同步请求的响应"></a>七、同步请求的响应</h2><p>**SpringMVC返回值的方式可以分为两大类: **</p>
<p>​     <strong>1.同步请求的响应:</strong></p>
<p>​            请求<strong>转发 或 重定向</strong></p>
<p>​     <strong>2.异步请求的响应</strong></p>
<p>​            异步指的是前端的请求的方式：ajax</p>
<p>​            ajax请求直接返回响应结果字符串</p>
<h3 id="1、原生API和SpringMVC实现转发"><a href="#1、原生API和SpringMVC实现转发" class="headerlink" title="1、原生API和SpringMVC实现转发"></a>1、原生API和SpringMVC实现转发</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *      原生API实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler01&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler01</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler01方法执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求转发到 /pages/success.jsp</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/pages/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *      SpringMVC方式:</span></span><br><span class="line"><span class="comment">     *          forward:物理视图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler02&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler02方法执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// forward:物理视图路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *      SpringMVC方式:</span></span><br><span class="line"><span class="comment">     *          逻辑视图 + 视图解析器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler03&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler03方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、原生API和SpringMVC实现重定向"><a href="#2、原生API和SpringMVC实现重定向" class="headerlink" title="2、原生API和SpringMVC实现重定向"></a>2、原生API和SpringMVC实现重定向</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定向-原生API</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler04&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler04</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler04方法执行了...&quot;</span>);</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/pages/success.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringMVC方式:</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler05&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler05</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler05方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:https://www.baidu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、原生API和SpringMVC以流的形式写回字符串"><a href="#3、原生API和SpringMVC以流的形式写回字符串" class="headerlink" title="3、原生API和SpringMVC以流的形式写回字符串"></a>3、原生API和SpringMVC以流的形式写回字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以流的形式写回字符串</span></span><br><span class="line"><span class="comment">     *      原生API: HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler06&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler06</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;handler06方法执行了...&quot;</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;原生API响应的数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mime常用类型:</span></span><br><span class="line"><span class="comment">     *          *.html  text/html</span></span><br><span class="line"><span class="comment">     *          *.js    text/JavaScript</span></span><br><span class="line"><span class="comment">     *          *.png   image/png</span></span><br><span class="line"><span class="comment">     *          *.json  application/json</span></span><br><span class="line"><span class="comment">     * 以流的形式写回字符串</span></span><br><span class="line"><span class="comment">     *      SpringMVC方式:</span></span><br><span class="line"><span class="comment">     *          <span class="doctag">@ResponseBody</span> + String</span></span><br><span class="line"><span class="comment">     *  RequestMapping参数:</span></span><br><span class="line"><span class="comment">     *      produces: 设置响应参数的mime类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/handler07&quot;,produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler07</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler07方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringMVC写回的字符串&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、响应时数据共享问题"><a href="#4、响应时数据共享问题" class="headerlink" title="4、响应时数据共享问题"></a>4、响应时数据共享问题</h3><blockquote>
<p>请求转发: 数据都会存放到Request域中<br>重定向: 将共享的数据拼接在请求路径的后面</p>
</blockquote>
<h4 id="【1】转发响应时"><a href="#【1】转发响应时" class="headerlink" title="【1】转发响应时"></a>【1】转发响应时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用request域对象封装响应结果</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo1</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Model封装结果</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo2</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用ModelAndView封装结果 </span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">demo3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="【2】重定向时"><a href="#【2】重定向时" class="headerlink" title="【2】重定向时"></a>【2】重定向时</h4><p>数据存放到session域下，会占用服务器内存空间；【不可取】</p>
<p>重定向时，request域下的数据不能共享，但是使用Model或者ModelAndView可以自动将数据以参数的方式拼接到请求路径中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test04&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test04</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test04方法执行了...&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;你若安好,便是晴天&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test05&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test05</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test05方法执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// 封装转发携带的数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg1&quot;</span>,<span class="string">&quot;情绪是智慧不够的产物!&quot;</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg2&quot;</span>,<span class="string">&quot;哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">// 封装视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;redirect:/pages/success.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="八、异步请求的响应"><a href="#八、异步请求的响应" class="headerlink" title="八、异步请求的响应"></a>八、异步请求的响应</h2><p>测试环境：vue+springmvc</p>
<h3 id="1-使用Response-原生API响应结果"><a href="#1-使用Response-原生API响应结果" class="headerlink" title="1. 使用Response 原生API响应结果"></a>1. 使用Response 原生API响应结果</h3><div style='background-color:orange;'>示例1:</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原生API生成响应信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">(String name, Integer age, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;demo1方法执行了..&quot;</span>+name+<span class="string">&quot; : &quot;</span>+age);</span><br><span class="line">    response.getWriter().print(<span class="string">&quot;hello...&quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-ResponseBody注解"><a href="#2-使用-ResponseBody注解" class="headerlink" title="2. 使用@ResponseBody注解"></a>2. 使用@ResponseBody注解</h3><h4 id="返回普通字符串"><a href="#返回普通字符串" class="headerlink" title="返回普通字符串"></a>返回普通字符串</h4><div style='background-color:orange;'>示例2:</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求携带的json字符串,将字符串存放到一个变量中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestBody</span>:</span></span><br><span class="line"><span class="comment"> *      获取请求体中的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test03&quot;,produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test03</span><span class="params">(<span class="meta">@RequestBody</span> String str)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test03方法执行了&quot;</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求携带的json字符串,将字符串存放到一个变量中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestBody</span>:</span></span><br><span class="line"><span class="comment"> *      注意: 需要导入jackson的jar包</span></span><br><span class="line"><span class="comment"> *      解析请求体中的json字符串,并将数据封装到vo对象中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test04&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test04</span><span class="params">(<span class="meta">@RequestBody</span> UserVo userVo)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test04方法执行了&quot;</span>);</span><br><span class="line">    System.out.println(userVo);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回json字符串"><a href="#返回json字符串" class="headerlink" title="返回json字符串"></a>返回json字符串</h4><div style='background-color:orange;'>示例3:</div>

<p>先要导入JSON转换需要的包 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将返回结果转成json字符串返回给浏览器</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据:</span></span><br><span class="line"><span class="comment">     *      响应json格式的数据给浏览器</span></span><br><span class="line"><span class="comment">     *      <span class="doctag">@ResponseBody</span> + 对象</span></span><br><span class="line"><span class="comment">     *          可以直接将对象转成json字符串写回给浏览器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test05&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">test05</span><span class="params">(<span class="meta">@RequestBody</span> UserVo userVo)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test04方法执行了&quot;</span>);</span><br><span class="line">        System.out.println(userVo);</span><br><span class="line">        userVo.setAge(<span class="number">21</span>);</span><br><span class="line">        userVo.setUsername(<span class="string">&quot;笑雯&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-RequestBody和-ResponseBody的区别"><a href="#3-RequestBody和-ResponseBody的区别" class="headerlink" title="3. @RequestBody和@ResponseBody的区别"></a>3. @RequestBody和@ResponseBody的区别</h3><p>@RequestBody</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">@RequestBody</span>核心是接收客户端发送的json格式字符串，并封装到某个vo下(反序列化过程)；</span><br><span class="line"><span class="number">2.</span>get请求是没有请求体,而请求携带的json格式数据必须存放在请求体中携带给服务器</span><br><span class="line"><span class="number">3.</span>编写位置: 参数列表中参数的前面</span><br><span class="line">作用:</span><br><span class="line">  在post请求时,获取请求携带的json字符串,自动解析json字符串,并将解析到的内容封装到对应的java对象中(导入Jackson的jar包)</span><br></pre></td></tr></table></figure>

<p>@ResponseBody</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>:</span><br><span class="line">  作用<span class="number">1</span>: 以流的形式写回字符串给浏览器</span><br><span class="line">  作用<span class="number">2</span>: 将对象转成json字符串,将转完后的字符串以流的形式写回给浏览器</span><br><span class="line">    	需要设置返回数据的mime类型: produces = <span class="string">&quot;application/json;charset=utf-8&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>@RequestBody和@ResponseBody都是用来干什么的？</strong> </p>
<p>​        @RequestBody : 使用在post请求中</p>
<p>​                1.获取请求体的参数(获取的是一个字符串)</p>
<p>​                2.获取请求携带的json格式字符串,并解析json格式的字符串,封装到对象中</p>
<p>​                3.使用在参数的前面</p>
<p>​        @ResponseBody: 生成响应字符串的</p>
<p>​                1.直接返回一个普通字符串</p>
<p>​                2.如果返回的是对象,则将对象转出json字符串并返回</p>
<p>​                3.使用在方法上或方法的返回值前面</p>
<h2 id="九、RESTFul风格的路径"><a href="#九、RESTFul风格的路径" class="headerlink" title="九、RESTFul风格的路径"></a>九、RESTFul风格的路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求路径中 &#123;占位符&#125; 接收请求路径中当前位置的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PathVariable</span>: 解析请求路径中的值,并将值赋给形参变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/&#123;username&#125;/&#123;age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span>String username ,</span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;age&quot;)</span>Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户信息 &quot;</span>+username+<span class="string">&quot; : &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户信息 &quot;</span> +id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户信息 &quot;</span> +id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findByPage</span><span class="params">(<span class="meta">@PathVariable(&quot;currentPage&quot;)</span>Integer currentPage,</span></span><br><span class="line"><span class="params">                             <span class="meta">@PathVariable(&quot;pageSize&quot;)</span>Integer pageSize)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询用户信息 &quot;</span>+currentPage+<span class="string">&quot; : &quot;</span>+pageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><h3 id="1、静态资源映射"><a href="#1、静态资源映射" class="headerlink" title="1、静态资源映射"></a>1、静态资源映射</h3><h4 id="解决方式1："><a href="#解决方式1：" class="headerlink" title="解决方式1："></a>解决方式1：</h4><p>  在springmvc.xml文件中配置：</p>
<p>&lt; mvc:resources mapping=”匹配请求路径” location=”真实路径”&gt;  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置静态资源不过滤 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 样式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- javascript --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- html资源 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="解决方式2："><a href="#解决方式2：" class="headerlink" title="解决方式2："></a>解决方式2：</h4><p>  在springmvc.xml文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 统一配置 ★ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代替以上所有的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、异常处理"><a href="#2、异常处理" class="headerlink" title="2、异常处理"></a>2、异常处理</h3><h4 id="方式1：基于HandlerExceptionResolver接口实现"><a href="#方式1：基于HandlerExceptionResolver接口实现" class="headerlink" title="方式1：基于HandlerExceptionResolver接口实现"></a>方式1：基于HandlerExceptionResolver接口实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">自定义异常处理器</span><br><span class="line"> a）.编写一个类,实现 HandlerExceptionResolver 接口</span><br><span class="line"> b）.重写 resolveException方法：完成异常处理</span><br><span class="line">        <span class="number">1.</span>跳转到公共的错误页面</span><br><span class="line">        <span class="number">2.</span>携带错误信息</span><br><span class="line">        返回：ModelAndView</span><br><span class="line">           addObject：  携带参数</span><br><span class="line">           setViewName：指定页面跳转</span><br><span class="line"> c.配置异常处理器（交给spring容器管理）</span><br><span class="line">	&lt;bean id=<span class="string">&quot;exceptionResolver&quot;</span> class=<span class="string">&quot;com.study.exception.MyHandlerExceptionResolver&quot;</span> /&gt;	 或者使用注解加入spring的ioc容器中；</span><br></pre></td></tr></table></figure>

<p>实现代码如下：</p>
<h5 id="自定义异常处理类"><a href="#自定义异常处理类" class="headerlink" title="自定义异常处理类"></a>自定义异常处理类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request : 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response : 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler : 处理器对象(哪个处理器方法抛出的异常)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex : 抛出的异常是什么</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,ex.getMessage());</span><br><span class="line">        <span class="comment">// 设置视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;forward:/pages/error.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="方式2：注解开发异常处理器（推荐）"><a href="#方式2：注解开发异常处理器（推荐）" class="headerlink" title="方式2：注解开发异常处理器（推荐）"></a>方式2：注解开发异常处理器（推荐）</h4><ul>
<li>使用注解实现异常分类管理<br> 名称： @ControllerAdvice<br> 类型： 类注解<br> 位置：异常处理器类上方<br> 作用：设置当前类为异常处理器类<br> 范例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>使用注解实现异常分类管理<br> 名称： @ExceptionHandler<br> 类型： 方法注解<br> 位置：<font color='red'>异常处理器类中针对指定异常进行处理的方法上方</font><br> 作用：设置指定异常的处理方式<br> 范例：<br> 说明：处理器方法可以设定多个</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doOtherException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;出错啦，请联系管理员！ &quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>流程如下：</li>
</ul>
<p>1.以业务异常为例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常继承RuntimeException，覆盖父类所有的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.定义分类异常管理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handlerException</span><span class="params">(BusinessException exception)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.setViewName(<span class="string">&quot;forward:/pages/error.jsp&quot;</span>);</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(otherDefinerException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handlerException</span><span class="params">(BusinessException exception)</span>&#123;</span><br><span class="line">       <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.setViewName(<span class="string">&quot;forward:/pages/error.jsp&quot;</span>);</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.触发业务异常代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExceptionController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">//举例业务异常说明</span></span><br><span class="line">        <span class="keyword">if</span>(name.trim().length()&lt;<span class="number">4</span> )&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;用户名长度必须在2-4位之间，请重新输入！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总之，通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息</strong>  </p>
<h3 id="3、拦截器"><a href="#3、拦截器" class="headerlink" title="3、拦截器"></a>3、拦截器</h3><h4 id="【1】拦截器介绍"><a href="#【1】拦截器介绍" class="headerlink" title="【1】拦截器介绍"></a>【1】拦截器介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">拦截器（interceptor）是springmvc提供的一种机制，可以对请求进行拦截或直接放行，可以在进入控制器方法前后对请求做出相应的处理.</span><br><span class="line">作用:</span><br><span class="line">	在处理器方法执行前后,进行拦截过滤</span><br><span class="line">主要执行的拦截有:</span><br><span class="line">	在处理器方法执行前执行拦截: preHandle</span><br><span class="line">    	      在处理方法执行后执行拦截: postHandle</span><br><span class="line">            在视图解析器解析完毕后执行拦截: afterCompletion	</span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212356074.png" alt="1577627711990"></p>
<h4 id="【2】拦截器VS过滤器"><a href="#【2】拦截器VS过滤器" class="headerlink" title="【2】拦截器VS过滤器"></a>【2】拦截器VS过滤器</h4><p>拦截器与过滤器区别？</p>
<ul>
<li> 归属不同： Filter属于Servlet技术， Interceptor属于SpringMVC技术</li>
<li> 拦截内容不同： Filter可以对所有访问进行增强， Interceptor仅针对SpringMVC的访问进行增强  </li>
<li> 过滤器在Servlet执行前和执行后进行过滤，而 拦截器在servlet执行后,处理器执行前或后进行执行.</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212356069.png" alt="image-20200427164512745"></p>
<h4 id="【3】自定义拦截器"><a href="#【3】自定义拦截器" class="headerlink" title="【3】自定义拦截器"></a>【3】自定义拦截器</h4><p>​    <strong>1.编写一个类实现HandlerInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编写一个拦截器</span></span><br><span class="line"><span class="comment"> * 1.编写一个类,实现 HandlerInterceptor 接口</span></span><br><span class="line"><span class="comment"> * 2.重写后抽象方法</span></span><br><span class="line"><span class="comment"> * 3.配置拦截器 springmvc.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntercept</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器指定前执行拦截</span></span><br><span class="line"><span class="comment">     * 返回值为boolean</span></span><br><span class="line"><span class="comment">     *      如果返回ture则放行,执行处理器方法</span></span><br><span class="line"><span class="comment">     *      如果返回false则不放行,处理器方法不会执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle在处理器执行前拦截了..&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器执行后拦截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle在处理器执行后拦截了..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 视图解析器执行后拦截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion在视图解析器执行后拦截了..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>2. 配置拦截器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 在springmvc.xml文件中配置拦截器需要拦截的路径</span><br><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置拦截器的拦截路径，支持*通配--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/**         表示拦截所有映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*          表示拦截所有/开头的映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/user/*     表示拦截所有/user/开头的映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/user/add*  表示拦截所有/user/开头，且具体映射名称以add开头的映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/user/*All  表示拦截所有/user/开头，且具体映射名称以All结尾的映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 排除指定路径不需要拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:exclude-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:exclude-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用指定的拦截器类处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.intercept.MyIntercept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>3、多拦截器配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置拦截器 --&gt;</span><br><span class="line">    &lt;!-- 配置拦截器组 --&gt;</span><br><span class="line">    &lt;mvc:interceptors&gt;</span><br><span class="line">        &lt;!-- 配置一个拦截器 --&gt;</span><br><span class="line">        &lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;!-- 配置拦截器拦截的路径 第一*: 表示所有的包 第二*:表示所有的资源 --&gt;</span><br><span class="line">            &lt;mvc:mapping path=<span class="string">&quot;/**&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 排除指定路径不需要拦截 --&gt;</span><br><span class="line">            &lt;mvc:exclude-mapping path=<span class="string">&quot;/demo&quot;</span>&gt;&lt;/mvc:exclude-mapping&gt;</span><br><span class="line">            &lt;mvc:exclude-mapping path=<span class="string">&quot;/hello&quot;</span>&gt;&lt;/mvc:exclude-mapping&gt;</span><br><span class="line">            &lt;!-- 使用指定的拦截器类处理 --&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;com.itheima.intercept.MyIntercept&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br><span class="line"></span><br><span class="line">        &lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;!-- 配置拦截器拦截的路径 第一*: 表示所有的包 第二*:表示所有的资源 --&gt;</span><br><span class="line">            &lt;mvc:mapping path=<span class="string">&quot;/hello&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 使用指定的拦截器类处理 --&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;com.itheima.intercept.MyIntercept2&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br><span class="line">    &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212356075.png" alt="image-20200427171422781"></p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/13/test/</url>
    <content><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>hello</p>
<hr>
<p>title: Hello World # 标题<br>date: 2019/3/26 hh:mm:ss # 时间<br>categories: # 分类<br>    - 分类  # 只能由一个<br>tags: # 标签<br>    - PS3  # 能有多个<br>    - Games  # 一个标签一行<br>type:<br>    - about</p>
<hr>
<h1 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>hello</p>
<p><img src="https://tuchuangmweb.oss-cn-shenzhen.aliyuncs.com/mweb/xnip20220701204448..jpg" alt="Xnip2022-07-01_20-44-48"></p>
<p><img src="https://tuchuangmweb.oss-cn-shenzhen.aliyuncs.com/mweb/xnip20220701204444..jpg" alt="Xnip2022-07-01_20-44-44"></p>
<p><img src="media/Xnip2022-07-01_20-44-48.jpg" alt="Xnip2022-07-01_20-44-48"></p>
<p><img src="media/Xnip2022-07-01_20-44-44.jpg" alt="Xnip2022-07-01_20-44-44"></p>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/13/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Go语言学习</title>
    <url>/2022/03/01/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>Project项目名，-》src目录 -》go_code -&gt;&gt; 模块1，模块2 -&gt;&gt; main文件夹和其他文件夹</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212134868.png" alt="image-20220217214708424"></p>
<p><img src="media/16946123129615.jpg"></p>
<p>在对应的go文件目录下用cmd窗口打开，并运行 go build hello.go就会生成可执行文件hello.exe</p>
<p>==还可以通过 go build -o aaa/myhello.exe hello.go 指定生成的exe文件所在的目录==</p>
<p>==go build -o ../package/myhello.exe hello.go  回退上一级的package目录生成==</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135198.png" alt="image-20220217215651703"></p>
<h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><ol>
<li><p>使用shift+tab 和tab 或者 使用命令 gofmt  -w  文件名.go</p>
</li>
<li><p>运算符两边习惯各加一个空格</p>
</li>
<li><p>注意保持package包名和所在的外面文件夹的名字一样。除了package main</p>
</li>
<li><p>变量名、函数名、常量名 采用驼峰法，且首字母大写则可以被其他包访问；首字母小谢则只能在本包中使用，（可以理解成首字母大写是公开的，首字母小写是私有的，在golang里没有public，private等关键字）</p>
</li>
<li><p>Go 的源文件以 .go 为后缀名存储在计算机中，这些文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 scanner_test.go 。文件名不包含空格或其他特殊字符。</p>
</li>
<li><p>在习惯上，Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名</p>
</li>
<li><p>导入其他包时，注意import完整的路径按理说应该是 D:/Project/src/go_code/project1/module1 类似这种的，但是因为设置了gopath所以前面D:/Project是可以不用写的，然后src又是默认的，因此</p>
<p>import  “go_code/project1/module1” 这样写就行</p>
</li>
</ol>
<h2 id="IDE报错"><a href="#IDE报错" class="headerlink" title="IDE报错"></a>IDE报错</h2><h3 id="command-line-arguments-undefined"><a href="#command-line-arguments-undefined" class="headerlink" title="command-line-arguments undefined:"></a>command-line-arguments undefined:</h3><p>问题是使用goland开发。同一个包下两个或多个go文件，包名为main，点击其中一个文件的main()方法运行另一个文件的方法时报错，</p>
<p>解决办法是在goland中ctrl两个文件一起然后右键build运行</p>
<p>#go mod依赖管理</p>
<h2 id="传统模式建项目"><a href="#传统模式建项目" class="headerlink" title="传统模式建项目"></a>传统模式建项目</h2><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135392.png" alt="image-20220228122245833"></p>
<p>注意项目要放在gopath目录下的src目录下，注意要把go111module设为off</p>
<p>##go mod方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init</span><br><span class="line"><span class="keyword">go</span> mod download</span><br><span class="line"><span class="keyword">go</span> mod tidy <span class="comment">//更新</span></span><br><span class="line"></span><br><span class="line">运行<span class="keyword">go</span> get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</span><br><span class="line"></span><br><span class="line">GOPROXY=https:<span class="comment">//mirrors.aliyun.com,direct.</span></span><br></pre></td></tr></table></figure>

<p>运行的</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135915.png" alt="image-20220221190349551"></p>
<p>这样最后下载的包会自动放在gopath目录下的与src同级的pkg目录（自动生成） ==因为设置了本项目的GOpath==</p>
<p>如果不设置这个的话gomod下载的依赖会自动放在全局GOPATH的pkg目录下</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135793.png" alt="image-20220227143912789"></p>
<p>为整个GOPATH编制索引得加上==会将当前项目作为GOPATH 这个是推荐的。这样各个项目彼此独立不会存在谁污染谁的问题。   暂时不知道啥用，加上和不加上好像没区别==，</p>
<p>点击爆红的import alt+enter可以让你在代码中同步依赖然后就能自动拉取已经在本地pkg中的包</p>
<p>GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135018.png" alt="image-20220221190415461"></p>
<p>然后控制端用go mod tidy就行</p>
<h2 id="实现导入自己的包"><a href="#实现导入自己的包" class="headerlink" title="实现导入自己的包"></a>实现导入自己的包</h2><p>#github和git的操作</p>
<ol>
<li><p>ctrl+shift+A 窗口搜索 克隆 ， 然后克隆项目</p>
</li>
<li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135880.png" alt="image-20220221000947454"></p>
</li>
<li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135902.png" alt="image-20220221001100085"></p>
</li>
<li><p>alt+9查看历史提交</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135692.png" alt="image-20220221001631443"></p>
</li>
</ol>
<p><strong>goland操作</strong></p>
<ol>
<li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135065.png" alt="image-20220221175447112">按ctrl+i快速实现一个接口，会自动创建结构体和该结构体实现了这个接口</p>
</li>
<li><p>按F2直接跳到警告部分代码，对数字和字符串按个.直接能解析</p>
</li>
<li><p>ctrl+w</p>
</li>
</ol>
<p>#go的标准库</p>
<blockquote>
<p><a href="http://word.topgoer.com/">http://word.topgoer.com/</a> 查看标准库</p>
</blockquote>
<p>###strings</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.EqualFold(<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;go&quot;</span>)<span class="comment">//判断是否忽略大小写相等 结果true</span></span><br><span class="line"></span><br><span class="line">strings.HasPrefix(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;你&quot;</span>)<span class="comment">//判断是否有前缀，结果true</span></span><br><span class="line"></span><br><span class="line">strings.HasSuffix(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;好&quot;</span>)<span class="comment">//判断后缀，结果true</span></span><br><span class="line"></span><br><span class="line">strings.Contains(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&quot;好&quot;</span>)<span class="comment">//结果true</span></span><br><span class="line"></span><br><span class="line">strings.ContainsRune(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&#x27;好&#x27;</span>)<span class="comment">//判断字符串s是否包含utf-8码值r。结果true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func ContainsAny(s, chars string) bool  </span></span><br><span class="line"><span class="comment">//判断字符串s是否包含字符串chars中的任一字符。</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;team&quot;</span>, <span class="string">&quot;i&quot;</span>)<span class="comment">//false</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;failure&quot;</span>, <span class="string">&quot;u &amp; i&quot;</span>)<span class="comment">//true</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="comment">//false</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">strings.Count(<span class="string">&quot;你我我好我我&quot;</span>,<span class="string">&quot;我我&quot;</span>)<span class="comment">//返回字符串s中有几个不重复的sep子串。返回2</span></span><br><span class="line"></span><br><span class="line">strings.Index(<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;ken&quot;</span>)<span class="comment">//返回4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="type">string</span>, c <span class="type">byte</span>)</span></span> <span class="type">int</span><span class="comment">//字符c在s中第一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="type">string</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span><span class="comment">//unicode码值r在s中第一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span>   <span class="comment">//字符串chars中的任一utf-8码值在s中第一次出现的位置，如果不存在或者chars为空字符串则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep <span class="type">string</span>)</span></span> <span class="type">int</span>  <span class="comment">//子串sep在字符串s中最后一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span>  <span class="comment">//字符串chars中的任一utf-8码值在s中最后一次出现的位置，如不存在或者chars为空字符串则返回-1。</span></span><br><span class="line">strings.LastIndexAny(<span class="string">&quot;你好呀啊&quot;</span>,<span class="string">&quot;d啊 你&quot;</span>)<span class="comment">//返回9.因为一个汉字占三个字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回s中每个单词的首字母都改为标题格式的字符串拷贝。<span class="doctag">BUG:</span> Title用于划分单词的规则不能很好的处理Unicode标点符号。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回将所有字母都转为对应的小写版本的拷贝。不会改变s的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将所有字母都转为对应的大写版本的拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="type">string</span>, count <span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">//返回count个s串联的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%q]&quot;</span>, strings.Trim(<span class="string">&quot; !!! Achtung! Achtung! !!! &quot;</span>, <span class="string">&quot;! &quot;</span>))</span><br><span class="line">Output:</span><br><span class="line">[<span class="string">&quot;Achtung! Achtung&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前后端所有空白（unicode.IsSpace指定）都去掉的字符串。</span></span><br><span class="line">fmt.Println(strings.TrimSpace(<span class="string">&quot; \t\n a lone gopher \n\t\r\n&quot;</span>))</span><br><span class="line">Output:</span><br><span class="line">a lone gopher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回去除s可能的前缀prefix的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回将s后端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回去除s可能的后缀suffix的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span><span class="comment">//返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。</span></span><br><span class="line"></span><br><span class="line">strings.Split(<span class="string">&quot;a,b,c&quot;</span>,<span class="string">&quot;,&quot;</span>)<span class="comment">//返回值是一个字符串数组元素是abc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//将一系列字符串连接为一个字符串，之间用sep来分隔。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>###time</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">time.Now().Year()<span class="comment">//获取当前年</span></span><br><span class="line">time.Now().Month()<span class="comment">//获取当前年</span></span><br><span class="line">time.Now().Unix()<span class="comment">//返回从1970到现在的秒值</span></span><br><span class="line">time.Now().UnixNano <span class="comment">//返回从1970到现在的纳秒值</span></span><br><span class="line"></span><br><span class="line">elapsed := time.Since(start)<span class="comment">//可以获得从start秒开始到现在的毫秒值</span></span><br></pre></td></tr></table></figure>



<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s))) <span class="comment">//逆序排</span></span><br></pre></td></tr></table></figure>





<h1 id="golang变量"><a href="#golang变量" class="headerlink" title="golang变量"></a>golang变量</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li><p>``` go<br>var i int //i此时是默认值0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` go</span><br><span class="line">   var i = 10.11 //根据值自行判断变量类型 （类型推导）</span><br></pre></td></tr></table></figure></li>
<li><p>``` go<br>i := “tom” //省略var，注意 := 左侧的变量不应该是已经声明过的，否则会编译错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ``` go</span><br><span class="line">   var n1 , n2 , n3 int //一次声明多个变量</span><br><span class="line">   var n1 , n2 , n2 = 100 , &quot;tom&quot; , 888</span><br><span class="line">   n1 , name , n3 := 100 , &quot;tom&quot; , 888</span><br></pre></td></tr></table></figure></li>
<li><p>一次性声明多个全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	n3 = <span class="number">300</span></span><br><span class="line">    n4 = <span class="number">900</span></span><br><span class="line">    n5 = <span class="string">&quot;mary&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基本数据类型<ol>
<li>数值型<ol>
<li>整数类型（int,int8,int16,int32,int64,uint,uint8,uint16,uint64,byte）</li>
<li>浮点类型 (float32 , float64)</li>
</ol>
</li>
<li>布尔型 （bool）</li>
<li>字符串（string）</li>
</ol>
</li>
<li>派生复杂数据类型<ol>
<li>指针</li>
<li>数组</li>
<li>结构体 (struct)</li>
<li>管道（Channel）</li>
<li>函数</li>
<li>切片 （slice）</li>
<li>接口 （interface）</li>
<li>map</li>
</ol>
</li>
</ol>
<p>###整数类型</p>
<p>注意rune与int32一样范围，表示一个Unicode码</p>
<p>byte用于表示字符，</p>
<p>int uint的大小与系统有关</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 = <span class="number">100</span> <span class="comment">//n1默认是int型</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//unsafe.Sizeof(n1) 是unsafe包的一个函数，可以返回n1变量占用的字节数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2 的 类型 %T  n2占用的字节数是 %d &quot;</span>, n2, unsafe.Sizeof(n2))</span><br></pre></td></tr></table></figure>

<p>###浮点类型</p>
<blockquote>
<p>注意的是</p>
<p>golang的浮点型默认声明为float64</p>
<p>var n = 1.12 // n此时是float64的</p>
</blockquote>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示golang中字符类型使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1 <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">var</span> c2 <span class="type">byte</span> = <span class="string">&#x27;0&#x27;</span> <span class="comment">//字符的0</span></span><br><span class="line">   <span class="comment">//当我们直接输出byte值，就是输出了的对应的字符的码值</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c1=&quot;</span>, c1)<span class="comment">//c1= 97</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c2=&quot;</span>, c2)<span class="comment">//c2= 48</span></span><br><span class="line">   <span class="comment">//如果我们希望输出对应字符，需要使用格式化输出</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c1=%c c2=%c\n&quot;</span>, c1, c2)<span class="comment">//c1=a c2=0</span></span><br><span class="line">   <span class="comment">//var c3 byte = &#x27;北&#x27; //overflow溢出</span></span><br><span class="line">   <span class="keyword">var</span> c3 <span class="type">int</span> = <span class="string">&#x27;北&#x27;</span> </span><br><span class="line">   fmt.Printf(<span class="string">&quot;c3=%c c3对应码值=%d\n&quot;</span>, c3, c3)<span class="comment">//c3=北 c3对应码值=21271</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//可以直接给某个变量赋一个数字，然后按格式化输出时%c，会输出该数字对应的unicode 字符</span></span><br><span class="line">   <span class="keyword">var</span> c4 <span class="type">int</span> = <span class="number">22269</span> <span class="comment">// 22269 -&gt; &#x27;国&#x27; </span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c4=%c\n&quot;</span>, c4)<span class="comment">//c4=国</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//字符类型是可以进行运算的，相当于一个整数,运输时是按照码值运行</span></span><br><span class="line">   <span class="keyword">var</span> n1 = <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">//  10 + 97 = 107</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1)<span class="comment">//n1= 107</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ch = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ch的类似是%t,占用的字节是%d&quot;</span>,ch,unsafe.Sizeof(ch))<span class="comment">//ch的类似是%!t(int32=97),占用的字节是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go的字符串是由单个字节连接起来的。字节使用UTF-8编码识别Unicode文本，因此没有中文乱码问题</p>
<p>字符串一旦赋值，不能修改</p>
<p>可以用反引号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串遍历方式1-传统方式,注意这种方式对str2可以修改，但对str不能修改也就是说我们可以用str2[1]=&#x27;d&#x27;来修改值把‘北’改成‘d’</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;a北京&quot;</span></span><br><span class="line">	str2 := []<span class="type">rune</span>(str) <span class="comment">// 就是把 str 转成 []rune</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index = %d , %c \n&quot;</span>, i,str2[i]) <span class="comment">//使用到下标...</span></span><br><span class="line">        <span class="comment">//输出是index = 0 , a index = 1 , 北 ，index = 2 , 京 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串遍历方式2-for-range</span></span><br><span class="line">	<span class="keyword">for</span> index, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index=%d, val=%c \n&quot;</span>, index, val)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//index=0, val=a </span></span><br><span class="line"><span class="comment">//index=1, val=北 </span></span><br><span class="line"><span class="comment">//index=4, val=京 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>string底层是一个byte数组，如果需要修改字符串可以先将string转为[]byte 或者[]rune</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr1 := []<span class="type">rune</span>(str)</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">str = <span class="type">string</span>(arr1)</span><br></pre></td></tr></table></figure>

<hr>
<p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p>
<p><u><i>gopl.io/ch3/printints</i></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intsToString is like fmt.Sprint(values) but adds commas.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(intsToString([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)) <span class="comment">// &quot;[1, 2, 3]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似’[‘和’]’等ASCII字符则会更加有效。</p>
<p>bytes.Buffer类型有着很多实用的功能，我们在第七章讨论接口时将会涉及到，我们将看看如何将它用作一个I/O的输入和输出对象，例如当做Fprintf的io.Writer输出对象，或者当作io.Reader类型的输入源对象。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>###数组</p>
<ol>
<li><p>```go<br>var num [3]int = [3]int{1,2,3}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   var num = [3]int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>var num = […]int{1,2,3}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   var num = [...]int&#123;1:800, 0:900, 2:999&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>num := […]string{1:”tom”, 0:”jack”, 2:”mary”}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**数组的遍历方式**</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">for index,value := range array01&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>二维数组</strong></p>
<ol>
<li><p>```go<br>var arr [2][3]int //先声明再赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` go</span><br><span class="line">   var arr [2][3]int = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   var arr [2][3]int = [...][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   var arr = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   arr  := [...][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历方式</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(arr) ; i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr[i]); j++&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;%v\t&quot;</span>,arr[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span>(arr)&#123;</span><br><span class="line">		<span class="keyword">for</span> j , v2 := <span class="keyword">range</span>(v)&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;arr[%v][%v] = %v&quot;</span>,i,j,v2)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>###切片</p>
<p><strong>语法</strong></p>
<ol>
<li><p>```go<br>var arr [5]int = […]{1,22,33,65,99}<br>slice := arr[1:3]//得先有数组，然后让切片去引用一个已经创建好的数组<br>//注意这里引用的是1 2下标 。然后对slice和arr的里的元素的修改会互相影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   var slice []float64 = make([]float64,5,10)//make方式创建cap容量是10，len长度是5的切片，切片内各个元素使用默认值，</span><br><span class="line">   var slice = make([]float64,5,10)</span><br><span class="line">   slice := make([]float64,5,10)</span><br><span class="line">   //通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>var strSlice []string = []string{“tom”,”jack”,”mary”}<br>var strSlice  = []string{“tom”,”jack”,”mary”}<br>strSlice ：= []string{“tom”,”jack”,”mary”}<br>//方式3，定义一个切片，直接就指定具体数组，使用原理类似make的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过append（）来扩容</span><br><span class="line"></span><br><span class="line">1. 切片append操作的本质就是对数组扩容，go底层会创建一个新的数组newArr（安装扩容后大小），将slice原来包含的元素拷贝到新的数组newArr中，slice重新引用到newArr，注意newArr是在底层来维护的，程序员不可见，</span><br><span class="line">2. 因此append后两个数组的操作就独立开来了</span><br><span class="line">3. 切片之间的赋值需要通过copy函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ap的声</span><br><span class="line"></span><br><span class="line">### map</span><br><span class="line"></span><br><span class="line">当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</span><br><span class="line"></span><br><span class="line">map的声明</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">var mp map[string]string//注意声明不会分配内存，初始化需要make，分配内存后才能赋值和使用</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>具体使用</strong></p>
<ol>
<li><p>```go<br>var a map[string]string = make(map[string]string,10)<br>b := make(map[string]string)<br>c := map[string]string{“stu1”:”陈某”,”stu2”:”黄某”}</p>
<p>var m = map[string]Vertex{</p>
<pre><code>&quot;Bell Labs&quot;: Vertex&#123;
    40.68433, -74.39967,
&#125;,
&quot;Google&quot;: Vertex&#123;
    37.42202, -122.08408,
&#125;,
</code></pre>
<p>}<br>//若顶级类型只是一个类型名，你可以在文法的元素中省略它。<br>var m = map[string]Vertex{</p>
<pre><code>&quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,
&quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">2. 增删改查</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   city := make(map[string]string)</span><br><span class="line">   city[&quot;no1&quot;] = &quot;北京&quot;   //增加</span><br><span class="line">   city[&quot;no1&quot;] = &quot;深圳&quot;   //修改</span><br><span class="line">   delete(city,&quot;no1&quot;)//删除</span><br><span class="line">   </span><br><span class="line">   val , ok := city[&quot;no2&quot;]</span><br><span class="line">   if ok&#123;</span><br><span class="line">       fmt.Printf(&quot;有no1 key 值为%v \n&quot;,val) //查找</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       fmt.Printf(&quot;没有no1 key\n&quot;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>map的遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	city := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	city[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> city&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;k = %v  v = %v&quot;</span>,k,v)</span><br><span class="line">	&#125;</span><br><span class="line">----------------------------------</span><br><span class="line">capitals := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;France&quot;</span>: <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;Italy&quot;</span>: <span class="string">&quot;Rome&quot;</span>, <span class="string">&quot;Japan&quot;</span>: <span class="string">&quot;Tokyo&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> capitals &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Map item: Capital of&quot;</span>, key, <span class="string">&quot;is&quot;</span>, capitals[key])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>###map切片</p>
<p>切片的数据类型如果是map,则我们成为slice of map，map切片，这样使用则map个数可以动态变化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设我们想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素（参见下面的例子 8.4）。</span></span><br><span class="line">sm := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) </span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">s := []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;n1&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n2&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;n3&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n4&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面代码很重要，要注意</p>
<p><strong>应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> items &#123; <span class="comment">//i是切片的索引下标</span></span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version A: Value of items: %v\n&quot;</span>, items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">    items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">        item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">        item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This &#x27;item&#x27; will be lost on the next iteration.</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Version A: Value of items: [<span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>]]</span><br><span class="line">Version B: Value of items: [<span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###sync.Map</p>
<p>Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n)</span><br><span class="line">			value, _ := m.Load(key)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>###map排序</p>
<ol>
<li>先将map的key的顺序进行排序输出</li>
<li>对切片排序</li>
<li>遍历切片，然后按照key来输出map的值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> k,_ := <span class="keyword">range</span> map1&#123;</span><br><span class="line">    keys = appen(keys,k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(keys)</span><br><span class="line"><span class="keyword">for</span> _,k := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;map1[%v] = %v \n&quot;</span> , k , map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意结构体没有给字段赋值，那么就用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面介绍创建结构体s的方式</span></span><br><span class="line">	<span class="keyword">type</span> s <span class="keyword">struct</span>&#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> s1 s <span class="comment">//此时用默认值</span></span><br><span class="line">	s2 := s&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> s4 *s = <span class="built_in">new</span>(s)</span><br><span class="line">	<span class="keyword">var</span> s5 *s = &amp;s&#123;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s6 = &amp;s&#123;</span><br><span class="line">    name : <span class="string">&quot;小李&quot;</span></span><br><span class="line">    age : <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TV <span class="keyword">struct</span> &#123; <span class="comment">//这个也叫多重继承</span></span><br><span class="line">	Goods   </span><br><span class="line">	Brand	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Goods</span><br><span class="line">	*Brand	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值</span></span><br><span class="line">	tv := TV&#123; Goods&#123;<span class="string">&quot;电视机001&quot;</span>, <span class="number">5000.99</span>&#125;,  Brand&#123;<span class="string">&quot;海尔&quot;</span>, <span class="string">&quot;山东&quot;</span>&#125;, &#125;</span><br><span class="line"></span><br><span class="line">tv4 := TV2&#123; </span><br><span class="line">			&amp;Goods&#123;</span><br><span class="line">				Name : <span class="string">&quot;电视机004&quot;</span>, </span><br><span class="line">				Price : <span class="number">9000.99</span>,</span><br><span class="line">			&#125;,  </span><br><span class="line">			&amp;Brand&#123;</span><br><span class="line">				Name : <span class="string">&quot;长虹&quot;</span>, </span><br><span class="line">				Address : <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">			&#125;, </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意访问要这样写</span></span><br><span class="line">fmt.Println(<span class="string">&quot;tv4&quot;</span>, *tv4.Goods, *tv4.Brand)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>###接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stu)</span></span> Say() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Say()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu Stu = Stu&#123;&#125;</span><br><span class="line"><span class="comment">// var u Usb = stu这样写会错误！ 会报 Stu类型没有实现Usb接口 ,</span></span><br><span class="line"><span class="comment">// 如果希望通过编译,  var u Usb = &amp;stu</span></span><br><span class="line"><span class="keyword">var</span> u Usb = &amp;stu</span><br><span class="line">u.Say()</span><br></pre></td></tr></table></figure>

<p>####值接收和指针接收</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Move() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Dog value run...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover    <span class="comment">// 声明一个Mover类型的变量x</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d1 = Dog&#123;&#125; <span class="comment">// d1是Dog类型</span></span><br><span class="line">	x = d1         <span class="comment">// 可以将d1赋值给变量x</span></span><br><span class="line">	x.Move()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; <span class="comment">// d2是Dog指针类型</span></span><br><span class="line">	x = d2          <span class="comment">// 也可以将d2赋值给变量x</span></span><br><span class="line">	x.Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p>
<p>==但是注意下面的情况==</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (d Dog) Move() &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Dog value run...&quot;)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> Move() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Dog Point run...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Mover </span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d1 = Dog&#123;&#125; </span><br><span class="line">   x = d1         <span class="comment">// 这里会编译错误</span></span><br><span class="line">   x.Move()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; </span><br><span class="line">   x = d2          </span><br><span class="line">   x.Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>####接口的底层结构</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212136842.png" alt="image-20220226114637512"></p>
<h3 id="自定义数据类型type"><a href="#自定义数据类型type" class="headerlink" title="自定义数据类型type"></a>自定义数据类型type</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span> <span class="comment">//这时myInt就等价int来使用了</span></span><br><span class="line"><span class="keyword">type</span> mySum <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span><span class="comment">//这时mySum就等价一个函数类型</span></span><br></pre></td></tr></table></figure>



<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>注意类型转化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int8</span> = <span class="type">int8</span>(num1) <span class="comment">//可以看成函数那样，并不会改变num1的结果和类型，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int32</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int</span> <span class="number">64</span></span><br><span class="line">n2 = n1 + <span class="number">20</span> <span class="comment">//int32的n1不能这样相加转int64的n2。必须强转 int64(n1) + 20</span></span><br></pre></td></tr></table></figure>

<p>##类型断言</p>
<p>​    为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure>

<p>​    若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。  </p>
<p>​    否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。  </p>
<p>​    请注意这种语法和读取一个映射时的相同之处。  </p>
<hr>
<p>​    <strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。  </p>
<p>​    类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值），     它们针对给定接口值所存储的值的类型进行比较。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。  </p>
<p>​    此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。  </p>
<h3 id="字符串和数字类型的转换"><a href="#字符串和数字类型的转换" class="headerlink" title="字符串和数字类型的转换"></a>字符串和数字类型的转换</h3><p>==<strong>strconv包下</strong>==</p>
<blockquote>
<h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4></blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4></blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p>ParseBool() 函数用于将字符串转换为 bool 类型的值，它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误，函数签名如下。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ParseInt() 函数用于返回字符串表示的整数值（可以包含正负号），参数说明：</p>
<ul>
<li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。</li>
<li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li>
<li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p>ParseFloat() 函数用于将一个表示浮点数的字符串转换为 float 类型，参数说明：</p>
<ul>
<li>如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。</li>
<li>bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64；</li>
<li>返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p>FormatBool() 函数可以一个 bool 类型的值转换为对应的字符串类型，函数签名如下。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，其中，参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">        str := strconv.FormatInt(num, <span class="number">16</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">        <span class="comment">//type:string,value:64</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p>FormatFloat() 函数用于将浮点数转换为字符串类型，参数说明：</p>
<ul>
<li>bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。</li>
<li>fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd  十进制指数、“E”表示 -d.ddddE±dd  十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li>prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 fmt 为“g”、“G”时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ol>
<li>值类型<ol>
<li>int系列</li>
<li>float系列</li>
<li>bool</li>
<li>string</li>
<li>数组</li>
<li>结构体</li>
</ol>
</li>
<li>引用类型<ol>
<li>指针</li>
<li>slice切片</li>
<li>map</li>
<li>管道chan</li>
<li>interface</li>
</ol>
</li>
</ol>
<blockquote>
<p>注意值类型参数默认就是值传递，而引用类型参数默认就是引用传递。但是不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小</p>
</blockquote>
<blockquote>
<p>引用类型默认是引用传递，变量存储的是一个地址，这个地址对应的空间才是真正存储数据值，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>注意下面几点</p>
<ol>
<li>golang没有三元运算符</li>
<li>只能写i++</li>
<li>取余的结果与被除数的符号一样</li>
<li>&amp;&amp;和||都具有短路效果</li>
</ol>
<h1 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a>分支和循环</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age := <span class="number">20</span> ; age &gt; <span class="number">18</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> key&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,n1:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    	<span class="keyword">fallthrough</span> <span class="comment">//默认只能穿透一层</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">	x = y</span><br><span class="line">	<span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;mox 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ol>
<li><p>``` go<br>var str string = “hello,wordld~”<br>for i := 0 ; i &lt; len(str) ; i++{</p>
<pre><code>fmt.Printf(&quot;%c \n&quot;,str[i])
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   i := 1</span><br><span class="line">   for i &lt;= 19&#123;</span><br><span class="line">       ///</span><br><span class="line">       i++</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>k := 1<br>for {</p>
<pre><code>if k &lt;= 19 &#123;
    
&#125;else&#123;
    break
&#125;
k++
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   //Golang提供for-range的方式可以方便遍历字符串和数组（能遍历中文）</span><br><span class="line">   str := &#x27;a北京&#x27;</span><br><span class="line">   for index , val := range str&#123;</span><br><span class="line">       fmt.Printf(&quot;index = %d,val = %c \n&quot;,index,val)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>//对于while的实现改成<br>for{</p>
<pre><code>if 循环条件表达式&#123;
    break
&#125;
//语句
循环遍历迭代
</code></pre>
<p>}</p>
<p>//对于dowhile的实现改成<br>for{</p>
<pre><code>//语句
循环遍历迭代
if 循环条件表达式&#123;
    break
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## break continue</span><br><span class="line"></span><br><span class="line">### 生成随机数</span><br><span class="line"></span><br><span class="line">``` go</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	intn := rand.Intn(3)//intn取值是0,1,2</span><br><span class="line">	println(intn)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>###break和continue</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里演示一下指定标签的形式来使用 break</span></span><br><span class="line">lable2: </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">         <span class="keyword">break</span> lable2 <span class="comment">// j=0 j=1</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;j=&quot;</span>, j) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lable2:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">   <span class="comment">//lable1: // 设置一个标签在这里设置等价于普通的continue</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> lable2</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;i=&quot;</span>,i,<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出如下</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>###<strong>goto的使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="type">int</span> = <span class="number">30</span></span><br><span class="line"><span class="comment">//演示goto的使用</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ok1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">20</span> &#123;</span><br><span class="line">   <span class="keyword">goto</span> label1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;ok2&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok4&quot;</span>)</span><br><span class="line">label1:</span><br><span class="line">fmt.Println(<span class="string">&quot;ok5&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok6&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok7&quot;</span>)</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">ok1</span><br><span class="line">ok5</span><br><span class="line">ok6</span><br><span class="line">ok7</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="type">float64</span>, n2 <span class="type">byte</span>)</span></span> <span class="type">float64</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>,sub <span class="type">int</span>)&#123;&#125;<span class="comment">//支持对函数返回值命名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,args... <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;&#125;<span class="comment">//args是slice切片，通过args[index]访问</span></span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ol>
<li>在给一个go文件打包时，该包对应一个文件夹，go文件的的包名通常和文件所在的文件夹名字一致，一般为小写字母</li>
<li>import包时，路径从$GOPATH的src下开始，不用带src，编译器会自动从src下开始引入</li>
<li>为了让其他包的文件可以访问到本包的函数，该函数名的首字母需要大写，类似其他语言的public，这样才能跨包访问</li>
<li>在访问其他包函数变量时，语法是包名.函数名</li>
<li>如果包名较长，Go支持给包取别名，注意细节：取别名之后，原来的包名就不能使用了</li>
</ol>
<h2 id="函数注意事项"><a href="#函数注意事项" class="headerlink" title="函数注意事项"></a>函数注意事项</h2><ol>
<li><p>基本数据类型和数组默认都是值传递的，即进行值拷贝，在函数内修改，不会影响原来的值</p>
</li>
<li><p>如果希望函数内的变量能修改函数外的变量（指的是默认以值传递的方式的数据类型），可以传入变量的地址&amp;。函数内以指针的方式操作变量</p>
</li>
<li><p>go函数不支持重载</p>
</li>
<li><p>函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用，同时既然是数据类型，因此函数也可以作为形参，并且调用</p>
</li>
<li><p>每个源文件都可以包含一个<code>init函数</code>，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用</p>
</li>
<li><p>==函数初始化的执行顺序==</p>
<ol>
<li>先导入其他包，执行被导入的包的初始化</li>
<li>初始化顺序是先执行全局变量的初始化</li>
<li>然后执行init函数</li>
</ol>
</li>
<li><p>匿名函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res1 := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;<span class="keyword">return</span> n1+n2&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;<span class="keyword">return</span> n1+n2&#125;</span><br><span class="line">res2 := a(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局匿名函数：将匿名函数赋给一个全局变量</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    Fun1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span><span class="type">int</span>&#123;<span class="keyword">return</span> n1 + n2&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol>
<li><p>闭包就是一个函数和其相关的引用环境组合的一个整体</p>
</li>
<li><p>闭包的使用是通过返回一个匿名函数实现的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span> </span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      n = n + x</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := AddUpper()</span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">// 11 </span></span><br><span class="line">fmt.Println(f(<span class="number">2</span>))<span class="comment">// 13</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ol>
<li>当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数下一个语句</li>
<li>当函数执行完毕后，再从栈顶取出语句执行</li>
<li>在defer将语句放入到栈时，也会将相关的值拷贝同时入栈，</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">7</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	func1(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func1(&quot;Go&quot;) = 7, EOF</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;defer:&quot;</span>, i, y)</span><br><span class="line">	&#125;(x)</span><br><span class="line">	x += <span class="number">10</span></span><br><span class="line">	y += <span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是</span></span><br><span class="line">x= <span class="number">20</span> y= <span class="number">120</span> </span><br><span class="line"><span class="keyword">defer</span>: <span class="number">10</span> <span class="number">120</span></span><br></pre></td></tr></table></figure>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li>函数内部声明定义的变量叫局部变量，作用域仅限于函数内部</li>
<li>函数外部声明定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效</li>
<li>如果变量在一个代码块，比如for/if中，那么这个变量的作用域就在该代码块中</li>
</ol>
<p>#异常处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//使用defer + recover 来捕获和处理异常</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := <span class="built_in">recover</span>()  <span class="comment">// recover()内置函数，可以捕获到异常</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="comment">// 说明捕获到错误</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;err=&quot;</span>, err)</span><br><span class="line">         <span class="comment">//这里就可以将错误信息发送给管理员....</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;发送邮件给admin@sohu.com~&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   num1 := <span class="number">10</span></span><br><span class="line">   num2 := <span class="number">0</span></span><br><span class="line">   res := num1 / num2</span><br><span class="line">   fmt.Println(<span class="string">&quot;res=&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数去读取以配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">      <span class="comment">//读取...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//返回一个自定义错误</span></span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误..&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>工厂模式创建对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span>   <span class="comment">//其它包不能直接访问..</span></span><br><span class="line">	sal <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个工厂模式的函数，相当于构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		Name : name,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> age &gt;<span class="number">0</span> &amp;&amp; age &lt;<span class="number">150</span> &#123;</span><br><span class="line">		p.age = age</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;年龄范围不正确..&quot;</span>)</span><br><span class="line">		<span class="comment">//给程序员给一个默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##继承</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A    <span class="comment">//这样就表示内嵌，但是和java的继承有些许不同，不能父类指针指向子类对象，Go中的内嵌方法不算重载的概念，算是叫隐藏。 </span></span><br><span class="line">    <span class="comment">//后面var b B; 然后可以直接b.name.或者b.A.name访问方法和变量  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##组合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    a A    <span class="comment">//这样就表示组合， 后面var b B; 然后只能b.a.name访问方法和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h3><p>​    比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// 编译错误！</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>​    而以指针为接收者的方法被调用时，接收者既能为值又能为指针：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>​    对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。     也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">	p.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(v, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;	</span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(p.Abs())   <span class="comment">//方法调用可以这样</span></span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br></pre></td></tr></table></figure>



<p>###基于指针对象的方法</p>
<p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实现是通过接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> b2 <span class="type">float32</span> = <span class="number">2.1</span></span><br><span class="line">	x = b2 <span class="comment">//空接口，可以接收任何类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> y, ok := x.(<span class="type">float32</span>); ok &#123; <span class="comment">//调用特有方法，需要类型断言来转型</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;y的类型是 %T 值是%v&quot;</span>, y, y)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;转换失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol>
<li><p>```go<br>file, err := os.Open(“d:/test.txt”) //打开文件<br>err = file.Close()  //关闭文件<br>if err != nil {</p>
<pre><code>fmt.Println(&quot;close file err=&quot;, err)
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 文件的读取有两种方式</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   	reader := bufio.NewReader(file)</span><br><span class="line">   	//循环的读取文件的内容</span><br><span class="line">   	for &#123;</span><br><span class="line">   		str, err := reader.ReadString(&#x27;\n&#x27;) // 读到一个换行就结束</span><br><span class="line">   		//输出内容</span><br><span class="line">   		fmt.Printf(str)</span><br><span class="line">   		</span><br><span class="line">   		if err == io.EOF &#123; // io.EOF表示文件的末尾</span><br><span class="line">   			break</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   -----------------------------------------</span><br><span class="line">   content, err := ioutil.ReadFile(&quot;d:/test.txt&quot;)</span><br><span class="line">   fmt.Printf(&quot;%v&quot;, string(content)) // content是[]byte需要强转。文件的Open和Close被封装到 ReadFile 函数内部，不需要我们写</span><br></pre></td></tr></table></figure></li>
<li><p>文件的写入也有两种方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">filePath := <span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	</span><br><span class="line">	str := <span class="string">&quot;hello,Gardon\n&quot;</span> <span class="comment">// \r\n 表示换行</span></span><br><span class="line">	</span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为writer是带缓存，因此在调用WriterString方法时，其实</span></span><br><span class="line">	<span class="comment">//内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据</span></span><br><span class="line">	<span class="comment">//真正写入到文件中， 否则文件中会没有数据!!!</span></span><br><span class="line">	writer.Flush()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//将d:/abc.txt 文件内容导入到  d:/kkk.txt</span></span><br><span class="line"></span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;d:/abc.txt&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	err = ioutil.WriteFile(<span class="string">&quot;d:/kkk.txt&quot;</span>, data, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判断文件是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span> <span class="comment">//文件或者目录存在</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span> <span class="comment">//文件或文件夹不存在</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err <span class="comment">//其他类型错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(os.Args))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">   fmt.Println(i, <span class="string">&quot;---&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用flag解析</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp;user 就是接收用户命令行中输入的 -u 后面的参数值</span></span><br><span class="line">	<span class="comment">//&quot;u&quot; ,就是 -u 指定参数</span></span><br><span class="line">	<span class="comment">//&quot;&quot; , 默认值</span></span><br><span class="line">	<span class="comment">//&quot;用户名,默认为空&quot; 说明</span></span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名,默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码,默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名,默认为localhost&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为3306&quot;</span>)</span><br><span class="line">	<span class="comment">//这里有一个非常重要的操作,转换， 必须调用该方法</span></span><br><span class="line">	flag.Parse()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>)</span><br><span class="line"><span class="comment">//这样也能解析然后获取对应的参数到n和sep</span></span><br><span class="line"><span class="comment">//不过访问时要用 *n  *sep</span></span><br></pre></td></tr></table></figure>



<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>序列化和反序列化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将monster 序列化</span></span><br><span class="line">	data, err := json.Marshal(&amp;monster) <span class="comment">//..</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//反序列化</span></span><br><span class="line">	<span class="comment">//注意：反序列化map,不需要make,因为make操作被封装到 Unmarshal函数</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br></pre></td></tr></table></figure>



<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li><p>测试用例文件必须以 _test.go结尾。比如cal_test.go  其中cal不是固定的</p>
</li>
<li><p>测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAdd（注意A必须大写，即Test后的首字母必须大写） 同时测试用例函数的形参类型必须是*testing.T</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	addf := aaa.Addf(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">//测试aaa包下的Addf函数</span></span><br><span class="line">	<span class="keyword">if</span> addf == <span class="number">3</span> &#123;</span><br><span class="line">		t.Logf(<span class="string">&quot;测试成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;测试失败&quot;</span>) <span class="comment">//当出现错误时用这个输出错误信息并退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>cmd&gt;go test  <code>如果运行正确，无日志，错误时会输出日志</code></p>
<p>cmd &gt; go test -v <code> 运行正确或是错误，都会输出日志</code></p>
<p>测试单个文件，一定要带上被测试的原文件 go test -v cal_test.go cal.go</p>
<p>测试单个方法 go test -v -test.run TestAddUpper<code>(这个是方法名)</code></p>
</li>
</ol>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cpuNum := runtime.NumCPU() <span class="comment">//系统CPU数量</span></span><br><span class="line"><span class="comment">//可以自己设置使用多个cpu</span></span><br><span class="line">runtime.GOMAXPROCS(cpuNum - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>协程goroutine运行要注意同时写的资源竞争问题，可以用 go build -race 来编译运行查看是否存在资源竞争问题</p>
<p>解决方法</p>
<ol>
<li><p>全局变量加锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="comment">// test 函数就是计算 n!, 让将这个结果放入到 myMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	myMap[n] = res <span class="comment">//concurrent map writes?</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> test(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//休眠10秒钟【第二个问题 】</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>var wg sync.WaitGroup</p>
<p>func hello(i int) {</p>
<pre><code>defer wg.Done() // goroutine结束就登记-1
fmt.Println(&quot;Hello Goroutine!&quot;, i)
</code></pre>
<p>}<br>func main() {</p>
<pre><code>for i := 0; i &lt; 10; i++ &#123;
    wg.Add(1) // 启动一个goroutine就登记+1
    go hello(i)
&#125;
wg.Wait() // 等待所有登记的goroutine都结束
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. **读写锁**</span><br><span class="line"></span><br><span class="line">   读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   var (</span><br><span class="line">   	x      int64</span><br><span class="line">   	wg     sync.WaitGroup</span><br><span class="line">   	lock   sync.Mutex</span><br><span class="line">   	rwlock sync.RWMutex</span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line">   func write() &#123;</span><br><span class="line">   	// lock.Lock()   // 加互斥锁</span><br><span class="line">   	rwlock.Lock() // 加写锁</span><br><span class="line">   	x = x + 1</span><br><span class="line">   	time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒</span><br><span class="line">   	rwlock.Unlock()                   // 解写锁</span><br><span class="line">   	// lock.Unlock()                     // 解互斥锁</span><br><span class="line">   	wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func read() &#123;</span><br><span class="line">   	// lock.Lock()                  // 加互斥锁</span><br><span class="line">   	rwlock.RLock()               // 加读锁</span><br><span class="line">   	time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒</span><br><span class="line">   	rwlock.RUnlock()             // 解读锁</span><br><span class="line">   	// lock.Unlock()                // 解互斥锁</span><br><span class="line">   	wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func main() &#123;</span><br><span class="line">   	start := time.Now()</span><br><span class="line">   	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">   		wg.Add(1)</span><br><span class="line">   		go write()</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   	for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">   		wg.Add(1)</span><br><span class="line">   		go read()</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   	wg.Wait()</span><br><span class="line">   	end := time.Now()</span><br><span class="line">   	fmt.Println(end.Sub(start))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol>
<li><p>channel</p>
<ol>
<li><p>channel本质就是一个数据结构-队列，数据先进先出</p>
</li>
<li><p>线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的</p>
</li>
<li><p>channel有类型的，一个string类型的channel只能存放string类型数据</p>
</li>
<li><p>channe的定义和初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//无缓冲的管道</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>) <span class="comment">//必须make才能用，而且还要指定len才能用</span></span><br><span class="line">b &lt;- <span class="string">&quot;dd&quot;</span></span><br><span class="line">b &lt;- <span class="string">&quot;aa&quot;</span></span><br><span class="line"></span><br><span class="line">val1 := &lt;-b</span><br></pre></td></tr></table></figure></li>
<li><p>channel的数据放满了后，就不能再放入了，若没有使用协程的情况下，如果channel的数据取完了，再取就会报  <code>fatal error: all goroutines are asleep - deadlock! </code> 错误</p>
</li>
<li><p>管道的遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//遍历管道</span></span><br><span class="line">	intChan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		intChan2 &lt;- i * <span class="number">2</span> <span class="comment">//放入100个数据到管道</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历管道不能使用普通的 for 循环</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intChan2); i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;v=&quot;</span>, &lt;-intChan2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在遍历时，如果channel没有关闭，则会出现deadlock的错误</span></span><br><span class="line">	<span class="comment">//在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</span></span><br><span class="line">	<span class="built_in">close</span>(intChan2)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;v=&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">//另一种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		num, ok := &lt;-intChan <span class="comment">//intChan 取不到..	</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123; </span><br><span class="line">			<span class="keyword">break</span>  <span class="comment">//没数据时退出循环</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>只读或者只写的管道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 在默认情况下下，管道是双向</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 声明为只写</span></span><br><span class="line">	<span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//两种写法都可以</span></span><br><span class="line">    chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">-------------------------------------</span><br><span class="line">chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">chan2 &lt;- <span class="number">20</span></span><br><span class="line">	<span class="comment">//num := &lt;-chan2 //error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 声明为只读</span></span><br><span class="line">	chan3 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">	num2 := &lt;-chan3</span><br><span class="line">	<span class="comment">//chan3&lt;- 30 //err</span></span><br></pre></td></tr></table></figure></li>
<li><p>select的用法</p>
<p>​    <code>select</code> 语句使一个 Go 程可以等待多个通信操作。  </p>
<p>​    <code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//问题，在实际开发中，可能我们不好确定什么关闭该管道.</span></span><br><span class="line">	<span class="comment">//可以使用select 方式可以解决</span></span><br><span class="line">	label:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">//注意: 这里，如果intChan一直没有关闭，不会一直阻塞而deadlock</span></span><br><span class="line">			<span class="comment">//，会自动到下一个case匹配</span></span><br><span class="line">			<span class="keyword">case</span> v := &lt;-intChan : </span><br><span class="line">				fmt.Printf(<span class="string">&quot;从intChan读取的数据%d\n&quot;</span>, v)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-stringChan :</span><br><span class="line">				fmt.Printf(<span class="string">&quot;从stringChan读取的数据%s\n&quot;</span>, v)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">default</span> :</span><br><span class="line">				fmt.Printf(<span class="string">&quot;都取不到了，不玩了, 程序员可以加入逻辑\n&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">				<span class="keyword">break</span> label</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><ol>
<li><p>Dial函数和服务端建立连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.191.2:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;client dial err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//功能一：客户端可以发送单行数据，然后就退出</span></span><br><span class="line">	reader := bufio.NewReader(os.Stdin) <span class="comment">//os.Stdin 代表标准输入[终端]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从终端读取一行用户输入，并准备发送给服务器</span></span><br><span class="line">		line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readString err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果用户输入的是 exit就退出</span></span><br><span class="line">		line = strings.Trim(line, <span class="string">&quot; \r\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出..&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//再将line 发送给 服务器</span></span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(line + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn.Write err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Listen函数创建的服务端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">//这里我们循环的接收客户端发送的数据</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close() <span class="comment">//关闭conn</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个新的切片</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		<span class="comment">//conn.Read(buf)</span></span><br><span class="line">		<span class="comment">//1. 等待客户端通过conn发送信息</span></span><br><span class="line">		<span class="comment">//2. 如果客户端没有wrtie[发送]，那么协程就阻塞在这里</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;服务器在等待客户端%s 发送信息\n&quot;, conn.RemoteAddr().String())</span></span><br><span class="line">		n , err := conn.Read(buf) <span class="comment">//从conn读取</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			</span><br><span class="line">			fmt.Printf(<span class="string">&quot;客户端退出 err=%v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">//!!!</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3. 显示客户端发送的内容到服务器的终端</span></span><br><span class="line">		fmt.Print(<span class="type">string</span>(buf[:n])) </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;服务器开始监听....&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;0.0.0.0:8888&quot;</span>)<span class="comment">//监听本机的端口</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;listen err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listen.Close() <span class="comment">//延时关闭listen</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环等待客户端来链接我</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//等待客户端链接</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端来链接....&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() err=&quot;</span>, err)</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Accept() suc con=%v 客户端ip=%v\n&quot;</span>, conn, conn.RemoteAddr().String())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里准备其一个协程，为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h4 id="判断种类"><a href="#判断种类" class="headerlink" title="判断种类"></a>判断种类</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	k := v.Kind()</span><br><span class="line">	<span class="keyword">switch</span> k &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Int64:</span><br><span class="line">		<span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>####修改值获取值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;tom&quot;</span>      </span><br><span class="line">   fs := reflect.ValueOf(&amp;str) <span class="comment">//修改值必须用&amp;传参</span></span><br><span class="line">    aa := reflect.ValueOf(str).String() + <span class="string">&quot;aa&quot;</span><span class="comment">//获取值用.String() .Interface()   .Int()</span></span><br><span class="line">   fmt.Println(aa, str) <span class="comment">//输出结果：tomaa tom</span></span><br><span class="line">    fs.Elem().SetString(<span class="string">&quot;jack&quot;</span>) <span class="comment">////修改值必须先.Elem()</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, str)     <span class="comment">// jack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####结构体获取方法和成员</p>
<p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   stu1 := student&#123;</span><br><span class="line">      Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">      Score: <span class="number">90</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t := reflect.TypeOf(stu1)</span><br><span class="line">   fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">   <span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">      field := t.Field(i)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">   <span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.NumMethod())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">		methodType := v.Method(i).Type()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">		<span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line">		<span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">		v.Method(i).Call(args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========================</span><br><span class="line">args = <span class="built_in">append</span>(args, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">args = <span class="built_in">append</span>(agrs, reflect.ValueOf(<span class="number">40</span>))<span class="comment">//通过这种方式添加参数</span></span><br></pre></td></tr></table></figure>





<h1 id="go中的数据结构"><a href="#go中的数据结构" class="headerlink" title="go中的数据结构"></a>go中的数据结构</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span> <span class="comment">// 姓名</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="comment">// 年纪</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 Person.Age 从大到小排序</span></span><br><span class="line"><span class="keyword">type</span> PersonSlice []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Len() <span class="type">int</span> &#123; <span class="comment">// 重写 Len() 方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123; <span class="comment">// 重写 Swap() 方法</span></span><br><span class="line">   a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="comment">// 重写 Less() 方法， 从小到大排序</span></span><br><span class="line">   res := a[i].Age - a[j].Age</span><br><span class="line">   <span class="keyword">if</span> res == <span class="number">0</span> &#123;</span><br><span class="line">      res = strings.Compare(a[i].Name, a[j].Name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> res &gt; <span class="number">0</span> &#123;  <span class="comment">//从大到小排序，当年龄数字一样时，名字也是从大到小排序</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   people := []Person&#123;</span><br><span class="line">      &#123;<span class="string">&quot;ahang san&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;li si&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;bang wu&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;zhao liu&quot;</span>, <span class="number">26</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">   sort.Sort(PersonSlice(people)) <span class="comment">// 按照 Age 的升序排序</span></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">   sort.Sort(sort.Reverse(PersonSlice(people))) <span class="comment">// 按照 Age 的降序排序</span></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序正序，基本数据类型的切片用这几个函数	</span></span><br><span class="line">	sort.Sort(sort.IntSlice(intList))</span><br><span class="line">    sort.Sort(sort.Float64Slice(floatList))</span><br><span class="line">    sort.Sort(sort.StringSlice(stringList))</span><br></pre></td></tr></table></figure>



<p>##堆，优先队列</p>
<p>heap是常用的实现优先队列的方法。heap包对任意实现了heap接口的类型提供堆操作。堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：Len() int / Less(i, j int) bool / Swap(i, j  int) 再加上堆接口定义的两个方法：Push(x interface{}) / Pop()  interface{}。故只要实现了这五个方法，便定义了一个堆。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    heap.Push(h, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>==优先队列：==</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu []stu</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*t) <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*t)[i].age &lt; (*t)[j].age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*t)[i], (*t)[j] = (*t)[j], (*t)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *t = <span class="built_in">append</span>(*t, x.(stu))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*t)</span><br><span class="line">    x := (*t)[n<span class="number">-1</span>]</span><br><span class="line">    *t = (*t)[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := &amp;Stu&#123;&#123;<span class="string">&quot;Amy&quot;</span>, <span class="number">21</span>&#125;, &#123;<span class="string">&quot;Dav&quot;</span>, <span class="number">15</span>&#125;, &#123;<span class="string">&quot;Spo&quot;</span>, <span class="number">22</span>&#125;, &#123;<span class="string">&quot;Reb&quot;</span>, <span class="number">11</span>&#125;&#125;</span><br><span class="line">    heap.Init(student)</span><br><span class="line">    one := stu&#123;<span class="string">&quot;hund&quot;</span>, <span class="number">9</span>&#125;</span><br><span class="line">    heap.Push(student, one)</span><br><span class="line">    <span class="keyword">for</span> student.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, heap.Pop(student))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h2><p>可以类比数据结构中线性表的删除</p>
<p>要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>下面的方式可以在LeetCode中使用，简单的实现栈和队列。但是在实际项目中不要这么使用，这么做会带来内存泄漏的风险。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入栈</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="number">1</span>)</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 出栈</span></span><br><span class="line">queue = queue[<span class="number">1</span>: <span class="built_in">len</span>(queue)]</span><br><span class="line">stack = stack[<span class="number">0</span>: <span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>



<p> golang 内置的 <a href="https://links.jianshu.com/go?to=https://golang.org/pkg/container/list/"><code>container/list</code></a> 库提供了双向链表的数据结构。我们用这个也是很方便的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue := list.New()</span><br><span class="line">stack := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入栈</span></span><br><span class="line">queue.PushBack(<span class="number">123</span>)</span><br><span class="line">stack.PushBack(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 出栈 返回的数据是结构类型 Value 需要断言成相应的类型</span></span><br><span class="line">num1 = queue.Front() <span class="comment">//num1.Value才是具体值，不然是地址</span></span><br><span class="line">queue.Remove(num1)</span><br><span class="line"></span><br><span class="line">num2 = queue.Back()</span><br><span class="line">stack.Remove(num2)</span><br></pre></td></tr></table></figure>



<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span></span><br><span class="line"><span class="comment">// License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// See page 101.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package treesort provides insertion sort using an unbalanced binary tree.</span></span><br><span class="line"><span class="keyword">package</span> treesort</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+</span></span><br><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">   value       <span class="type">int</span></span><br><span class="line">   left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort sorts values in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> root *tree</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">      root = add(root, v)  <span class="comment">//建树</span></span><br><span class="line">   &#125;</span><br><span class="line">   appendValues(values[:<span class="number">0</span>], root)<span class="comment">//中序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues appends the elements of t to values in order</span></span><br><span class="line"><span class="comment">// and returns the resulting slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="type">int</span>, t *tree)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">      values = appendValues(values, t.left)</span><br><span class="line">      values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">      values = appendValues(values, t.right)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="type">int</span>)</span></span> *tree &#123;</span><br><span class="line">   <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class="line">      t = <span class="built_in">new</span>(tree)</span><br><span class="line">      t.value = value</span><br><span class="line">      <span class="keyword">return</span> t</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">      t.left = add(t.left, value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      t.right = add(t.right, value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!-</span></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %c %d&quot;</span>, &amp;a, &amp;b, &amp;c)</span><br><span class="line">---------------</span><br><span class="line"><span class="comment">//输入一行的话</span></span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line">	<span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">		counts[input.Text()]++</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b, c <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> d [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> e []<span class="type">string</span></span><br><span class="line">	fmt.Scanf(<span class="string">&quot;%d %d %d\n&quot;</span>, &amp;a, &amp;b, &amp;c)</span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入字符串的两行&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">		fmt.Scanf(<span class="string">&quot;%s\n&quot;</span>, &amp;s) <span class="comment">//后面的\n不加的话按Enter键的也被加入e</span></span><br><span class="line">		e = <span class="built_in">append</span>(e, s)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入数组的两行三列&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b; j++ &#123;</span><br><span class="line">			fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;d[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b; j++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d &quot;</span>, d[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(e[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>###for循环中的陷阱</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary! 这个不能省略，不然就出错原因是d是引用地址</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map的值是切片的陷阱"><a href="#map的值是切片的陷阱" class="headerlink" title="map的值是切片的陷阱"></a>map的值是切片的陷阱</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span></span><br><span class="line">   m := <span class="built_in">make</span>(Map)</span><br><span class="line">   s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">   s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)<span class="comment">//[1 2 3]</span></span><br><span class="line">   m[<span class="string">&quot;q1mi&quot;</span>] = s</span><br><span class="line">   s = <span class="built_in">append</span>(s[:<span class="number">1</span>], s[<span class="number">2</span>:]...)<span class="comment">//相当于删除s[1],  [1 3]</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])<span class="comment">//[1 3 3]</span></span><br><span class="line">   s = <span class="built_in">append</span>(s,<span class="number">4</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])<span class="comment">//[1 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="defer的陷阱"><a href="#defer的陷阱" class="headerlink" title="defer的陷阱"></a>defer的陷阱</h3><p>==暂时还看不懂==</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   x := <span class="number">5</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> (y <span class="type">int</span>) &#123;</span><br><span class="line">   x := <span class="number">5</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;(x)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(f1())</span><br><span class="line">   fmt.Println(f2())</span><br><span class="line">   fmt.Println(f3())</span><br><span class="line">   fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   ret := a + b</span><br><span class="line">   fmt.Println(index, a, b, ret)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x := <span class="number">1</span></span><br><span class="line">   y := <span class="number">2</span></span><br><span class="line">   <span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">   x = <span class="number">10</span></span><br><span class="line">   <span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">   y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>###牛客陷阱</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   a := <span class="number">12</span></span><br><span class="line">   &#123;</span><br><span class="line">      a := <span class="number">13</span></span><br><span class="line">      _ = a <span class="comment">// make compiler happy</span></span><br><span class="line">      fmt.Println(a)<span class="comment">//输出13</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)<span class="comment">//输出12</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于常量定义zero(const zero = 0.0)，zero是浮点型常量，这一说法是否正确。<code>错误</code>Go语言里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>java编程思想学习笔记</title>
    <url>/2022/07/21/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="linux常见命令"><a href="#linux常见命令" class="headerlink" title="linux常见命令"></a>linux常见命令</h1><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r aaa/* ccc</span><br><span class="line">将aaa目录下所有文件和文件夹拷贝到ccc目录下</span><br></pre></td></tr></table></figure>



<p>#四、运算符</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、几乎所有运算符都只能操作基本类型（Primitives）。唯一的例外是 <code>=</code>、<code>==</code> 和 <code>!=</code>，它们能操作所有对象（这也是令人混淆的一个地方）。除此以外，<strong>String</strong> 类支持 <code>+</code> 和 <code>+=</code>。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>注意基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Tank</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">      <span class="type">Tank</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">      t1.level = <span class="number">9</span>;</span><br><span class="line">      t2.level = <span class="number">47</span>;</span><br><span class="line">      t1 = t2;<span class="comment">//执行这个赋值后t1和t2都是指向同一个对象，其level都是47</span></span><br></pre></td></tr></table></figure>

<p>这种现象通常称为别名（aliasing），==而且注意当我们把对象传递给方法时，会发生别名现象。==</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>这里要注意的是一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 <strong>int</strong> 类型。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212119306.png" alt="image-20220128181924540"></p>
<h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>对于前缀形式++i，我们将在执行递增/减操作后获取值；使用后缀形式i–，我们将在执行递增/减操作之前获取值。它们是唯一具有“副作用”的运算符（除那些涉及赋值的以外） —— 它们修改了操作数的值。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符包括小于 <code>&lt;</code>，大于 <code>&gt;</code>，小于或等于 <code>&lt;=</code>，大于或等于 <code>&gt;=</code>，等于 <code>==</code> 和不等于 <code>！=</code>。<code>==</code> 和 <code>!=</code> 可用于所有基本类型，但其他运算符不能用于基本类型 <strong>boolean</strong></p>
<blockquote>
<p>这里要注意的是关系运算符 <code>==</code> 和 <code>!=</code> 适用于所有对象之间的比较运算。比较的是对象引用但有个陷阱如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Equivalence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        System.out.println(n1 == n2); <span class="comment">//输出的是true</span></span><br><span class="line">      	</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">147</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">147</span>;</span><br><span class="line">        System.out.println(n3 == n4);<span class="comment">//输出的是false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 <code>==</code> 和 <code>!=</code> 比较也能能到正确的结果</p>
<hr>
<p>那么怎么比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的 <code>equals()</code> 方法，但是<code>equals()</code> 的默认行为是比较对象的引用而非具体内容。大多数 Java 库类通过覆写 <code>equals()</code> 方法比较对象的内容而不是其引用。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>每个逻辑运算符 <code>&amp;&amp;</code> （<strong>AND</strong>）、<code>||</code>（<strong>OR</strong>）和 <code>!</code>（<strong>非</strong>）根据参数的逻辑关系生成布尔值 <code>true</code> 或 <code>false</code></p>
<p>这里注意的是将 int 作为布尔处理不是合法的 Java 写法</p>
<p>如果在预期为 <strong>String</strong> 类型的位置使用 <strong>boolean</strong> 类型的值，则结果会自动转为适当的文本格式（即 “true” 或 “false” 字符串）。</p>
<blockquote>
<p>逻辑运算符支持一种称为“短路”（short-circuiting）的现象。整个表达式会在运算到可以明确结果时就停止并返回结果，这意味着该逻辑表达式的后半部分不会被执行到</p>
</blockquote>
<h2 id="字面常量值"><a href="#字面常量值" class="headerlink" title="字面常量值"></a>字面常量值</h2><p>通常，当我们向程序中插入一个字面值常量（<strong>Literal</strong>）时，编译器会确切地识别它的类型。当类型不明确时，必须辅以字面值常量关联来帮助编译器识别。</p>
<p>在文本值的后面添加字符可以让编译器识别该文本值的类型。对于 <strong>Long</strong> 型数值，结尾使用大写 <code>L</code> 或小写 <code>l</code> 皆可（不推荐使用 <code>l</code>，因为容易与阿拉伯数值 1 混淆）。大写 <code>F</code> 或小写 <code>f</code> 表示 <strong>float</strong> 浮点数。大写 <code>D</code> 或小写 <code>d</code> 表示 <strong>double</strong> 双精度。</p>
<p>十六进制（以 16 为基数），适用于所有整型数据类型，由前导 <code>0x</code> 或 <code>0X</code> 表示，后跟 0-9 或 a-f （大写或小写）。八进制以前导 <code>0</code>  表示。如果我们在初始化某个类型的数值时，赋值超出其范围，那么编译器会报错（不管值的数字形式如何）。在上例的代码中，<strong>char（最大<code>0xffff</code>）</strong>、<strong>byte（<code>0x7f</code>）</strong> 和 <strong>short（<code>0x7fff</code>）</strong> 的值已经是最大了。如果超过这些值，编译器将自动转型为 <strong>int</strong>，并且提示我们需要声明强制转换（强制转换将在本章后面定义），意味着我们已越过该类型的范围界限。</p>
<p>八进制（以 8 为基数）由 0~7 之间的数字和前导零 <code>0</code> 表示。</p>
<p><code>此外float expFloat = 1.39e-43f;这种指数可以用e来表示大写的E和小写的e一样表示 10 的几次幂</code></p>
<p>注意如果编译器能够正确地识别类型，就不必使用后缀字符。对于下述语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p>它并不存在含糊不清的地方，所以 200 后面的 L 大可省去。然而，对于下述语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="number">1e-43f</span>; <span class="comment">//10 的幂数</span></span><br></pre></td></tr></table></figure>

<p>编译器通常会将指数作为 <strong>double</strong> 类型来处理，所以假若没有这个后缀字符 <code>f</code>，编译器就会报错，提示我们应该将 <strong>double</strong> 型转换成 <strong>float</strong> 型。</p>
<p>Java 7 引入了二进制的字面值常量，由前导 <code>0b</code> 或 <code>0B</code> 表示，它可以初始化所有的整数类型。</p>
<p>使用整型数值类型时，显示其二进制形式会很有用。在 Long 型和 Integer 型中这很容易实现，调用其静态的 <code>toBinaryString()</code> 方法即可。 但是请注意，若将较小的类型传递给 <strong>==Integer.toBinaryString()==</strong> 时，类型将自动转换为 <strong>int</strong>。</p>
<p>Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 <code>_</code>，以使结果更清晰。这对于大数值的分组特别有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="number">0b0010_1111_1010_1111_1010_1111_1010_1111</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(bin));</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, bin); <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//101111101011111010111110101111</span></span><br><span class="line"><span class="comment">//2fafafaf</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的是<code>\n</code> 表示换行符的是一个“Unix 风格”的换行符。如果我们使用的是 Windows，则必须指定 <code>\r\n</code>。这种差异的包袱应该由编程语言来解决。这就是 Java 用 <code>％n</code> 实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 <code>System.out.printf()</code> 或 <code>System.out.format()</code> 时。对于 <code>System.out.println()</code>，我们仍然必须使用 <code>\n</code>；如果你使用 <code>％n</code>，<code>println()</code> 只会输出 <code>％n</code> 而不是换行符。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>若两个输入位都是 1，则按位“与运算符” <code>&amp;</code> 运算后结果是 1，否则结果是 0。若两个输入位里至少有一个是 1，则按位“或运算符” <code>|</code> 运算后结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。若两个输入位的某一个是 1，另一个不是 1，那么按位“异或运算符” <code>^</code> 运算后结果才是 1。按位“非运算符” <code>~</code> 属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。按位非运算后结果与输入位相反。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0b101</span>;</span><br><span class="line">    a = ~a;</span><br><span class="line">    System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="comment">//输出11111111111111111111111111111010</span></span><br></pre></td></tr></table></figure>

<p>位运算符可与等号 <code>=</code> 联合使用以接收结果及赋值：<code>&amp;=</code>，<code>|=</code> 和 <code>^=</code> 都是合法的（由于 <code>~</code> 是一元运算符，所以不可与 <code>=</code> 联合使用）。</p>
<hr>
<p>我们可以对 boolean 型变量执行与、或、异或运算，但不能执行非运算（大概是为了避免与逻辑“非”混淆）。对于布尔值，位运算符具有与逻辑运算符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的位运算为我们新增了一个“异或”逻辑运算符，它并未包括在逻辑运算符的列表中。在移位表达式中，禁止使用布尔值</p>
<hr>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>只能用于处理整数类型（基本类型的一种）。左移位运算符 <code>&lt;&lt;</code> 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。右移位运算符 <code>&gt;&gt;</code> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。Java 也添加了一种“不分正负”的右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。这一运算符是 C/C++ 没有的。</p>
<p>如果移动 <strong>char</strong>、<strong>byte</strong> 或 <strong>short</strong>，则会在移动发生之前将其提升为 <strong>int</strong>，结果为 <strong>int</strong>。仅使用右侧的 5 个低阶位。这可以防止我们移动超过 <strong>int</strong> 范围的位数。若对一个 <strong>long</strong> 值进行处理，最后得到的结果也是 <strong>long</strong>。</p>
<p>移位可以与等号 <code>&lt;&lt;=</code> 或 <code>&gt;&gt;=</code> 或 <code>&gt;&gt;&gt;=</code> 组合使用。左值被替换为其移位运算后的值。但是，问题来了，当无符号右移与赋值相结合时，若将其与 <strong>byte</strong> 或 <strong>short</strong> 一起使用的话，则结果错误。取而代之的是，它们被提升为 <strong>int</strong> 型并右移，但在重新赋值时被截断。在这种情况下，结果为 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">     b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">     System.out.println(b);<span class="comment">//结果是-1</span></span><br></pre></td></tr></table></figure>

<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符，也称为条件运算符。这种运算符比较罕见，因为它有三个运算对象。但它确实属于运算符的一种，因为它最终也会生成一个值。这与本章后一节要讲述的普通 <strong>if-else</strong> 语句是不同的。下面是它的表达式格式：</p>
<p><strong>布尔表达式 ? 值 1 : 值 2</strong></p>
<p>若表达式计算为 <strong>true</strong>，则返回结果 <strong>值 1</strong> ；如果表达式的计算为 <strong>false</strong>，则返回结果 <strong>值 2</strong>。</p>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x = y) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，这样的表达式结果并不会转化为一个布尔值。 而编译器会试图把这个 <strong>int</strong> 型数据转换为预期应接收的布尔类型。最后，我们将会在试图运行前收到编译期错误。因此，Java 天生避免了这种陷阱发生的可能。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>除了布尔类型的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。此外，类是不能进行类型转换的。为了将一个类转换为另一个类型，需要使用特殊的方法（后面将会学习到如何在父子类之间进行向上/向下转型）</p>
<p>若将数据类型进行“向下转换”（<strong>Narrowing Conversion</strong>）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。此时，必须显示转换。</p>
<p>对于“向上转换”（<strong>Widening conversion</strong>），则不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">     <span class="type">long</span> <span class="variable">lng</span> <span class="operator">=</span> i; <span class="comment">// 隐式转换</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">lng2</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">// 隐式转换</span></span><br><span class="line"></span><br><span class="line">     i = (<span class="type">int</span>)lng2; <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure>

<h3 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h3><p>如果我们对小于 <strong>int</strong> 的基本数据类型（即 <strong>char</strong>、<strong>byte</strong> 或 <strong>short</strong>）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 <strong>int</strong>，并且结果值的类型为 <strong>int</strong>。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。通常，表达式中最大的数据类型是决定表达式结果的数据类型。<strong>float</strong> 型和 <strong>double</strong> 型相乘，结果是 <strong>double</strong> 型的；<strong>int</strong> 和 <strong>long</strong> 相加，结果是 <strong>long</strong> 型。</p>
<h2 id="没有sizeof"><a href="#没有sizeof" class="headerlink" title="没有sizeof"></a>没有sizeof</h2><p>Java 不需要 <code>sizeof()</code> 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。</p>
<h1 id="五、控制流"><a href="#五、控制流" class="headerlink" title="五、控制流"></a>五、控制流</h1><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>标签”是后面跟一个冒号的标识符。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br></pre></td></tr></table></figure>

<p>对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方 —— 在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于 <strong>break</strong> 和 <strong>continue</strong> 关键字通常只中断当前循环，但若搭配标签一起使用，它们就会中断并跳转到标签所在的地方开始执行。</p>
<h1 id="六、初始化和清理"><a href="#六、初始化和清理" class="headerlink" title="六、初始化和清理"></a>六、初始化和清理</h1><p>##利用构造器保证初始化</p>
<p>构造器没有返回值，它是一种特殊的方法，方法名和类名一样，因此不需要符合首字母小写的编程风格（类的首字母大写）。但它和返回类型为 <code>void</code> 的普通方法不同，普通方法可以返回空值，你还能选择让它返回别的类型；而构造器没有返回值.</p>
<p>##方法重载</p>
<p>方法重载是必要的，它允许方法具有相同的方法名但接收的参数不同。方法的重载不看返回值。</p>
<blockquote>
<p>为什么需要方法重载：①相同的词可以表达多种不同的含义——它们被”重载”了。特别是当含义的差别很小时，这会更加有用。你会说”清洗衬衫”、”清洗车”和”清洗狗”。而如果硬要这么说就会显得很愚蠢：”以洗衬衫的方式洗衬衫”、”以洗车的方式洗车”和”以洗狗的方式洗狗</p>
<p>②因为构造器方法名肯定是与类名相同，所以一个类中只会有一个构造器名。那么你怎么通过不同的方式创建一个对象呢？例如，你想创建一个类，这个类的初始化方式有两种：一种是标准化方式，另一种是从文件中读取信息的方式。你需要两个构造器：无参构造器和有一个 <strong>String</strong> 类型参数的构造器，该参数传入文件名。两个构造器的名字都是与类名相同。</p>
</blockquote>
<blockquote>
<p>不能通过方法的返回值区分方法的原因是</p>
<p>void f(){}<br>int f() {return 1;}</p>
<p>可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 <code>f()</code>，Java 编译器就不知道你想调用哪个方法，阅读者也不明所以</p>
</blockquote>
<p><strong>但注意的是</strong></p>
<p>基本类型可以自动从较小的类型转型为较大的类型。当这与重载结合时，有一些陷阱：</p>
<p>如果传进的是一个常数比如5，那么重载会输出下面的哪种情况呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">short</span> x)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//执行f1(5)将会输出 f1(int)</span></span><br><span class="line"><span class="comment">//当然如果没有int及以下的内容时 5会自动的从较小的类型int转为较大的类型比如long，float等等</span></span><br></pre></td></tr></table></figure>

<p>如果传进的是一个字符比如  char a = ‘x’, f1(a) 那么首先会看重载的类型里有没有char的，如果没有char但是有int和short和byte这时候会选择int，如果连int都没有，那么就优先选择long，然后float然后double</p>
<p>另外需要注意的是如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。</p>
<blockquote>
<p>总结：如果传入的参数是char,那么方法期望接收的参数类型只能是char或者是int及以上，而不能是byte和short。如果传入的参数是一个常数，那么方法期望接收的参数类型必须是int及以上，不能是char,byte,short。传入的参数匹配时可以自动从较小的类型转型为较大的类型，但不能自动从较大的类型转为较小的，必须要显示的转化</p>
</blockquote>
<h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。但是,一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p><strong>this</strong> 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，<strong>this</strong> 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 <strong>this</strong>，直接调用即可，<strong>this</strong> 自动地应用于其他方法上了。</p>
<p><strong>this 关键字的用途</strong></p>
<p>①、在一些必须显式使用当前对象引用的特殊场合。例如，用在 <strong>return</strong> 语句中返回对当前对象的引用。</p>
<p>②当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过 <strong>this</strong> 关键字实现这样的调用。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>记住了 <strong>this</strong> 关键字的内容，你会对 <strong>static</strong> 修饰的方法有更加深入的理解：<strong>static</strong> 方法中不会存在 <strong>this</strong>。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 <strong>this</strong>，所以你没有向一个对象发送消息。</p>
<h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>对于方法的局部变量如果没有进行初始化就使用会编译错误。</p>
<p>对于成员变量，类的每个基本类型数据成员保证都会有一个默认的初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="literal">false</span></span><br><span class="line"><span class="type">char</span>[NUL]</span><br><span class="line"><span class="type">byte</span> <span class="number">0</span></span><br><span class="line"><span class="type">short</span> <span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="number">0</span></span><br><span class="line"><span class="type">long</span> <span class="number">0</span></span><br><span class="line"><span class="type">float</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">double</span> <span class="number">0.0</span></span><br><span class="line">reference <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>当然你也可以在定义类成员变量的地方为其赋值（自动初始化）。但是缺少灵活性，无法为每个对象初始化不同的成员变量值</p>
<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>可以用构造器进行初始化，这种方式给了你更大的灵活性，因为你可以在运行时调用方法进行初始化。但是，这无法阻止自动初始化的进行，他会在构造器被调用之前发生。</p>
<h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>成员变量首先是默认初始化，然后是自动的赋值初始化，接着是构造器的初始化。</p>
<blockquote>
<p>在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。</p>
</blockquote>
<h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。<strong>static</strong> 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 <strong>null</strong>。</p>
<p>如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。</p>
<h3 id="总的初始化顺序"><a href="#总的初始化顺序" class="headerlink" title="总的初始化顺序"></a>总的初始化顺序</h3><p>可以看下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.chapter6;<span class="comment">// housekeeping/StaticInitialization.java</span></span><br><span class="line"><span class="comment">// (c)2021 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Specifying initial values in a class definition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span> &#123;</span><br><span class="line">  Bowl(<span class="type">int</span> marker) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Table静态代码块执行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Table() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span> &#123;</span><br><span class="line">  <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cupborad实例初始化子句执行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Bowl</span> <span class="variable">bowl9</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">9</span>);</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> marker)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Table静态代码块执行</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupborad实例初始化子句执行</span></span><br><span class="line"><span class="comment">Bowl(9)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">main creating new Cupboard()</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupborad实例初始化子句执行</span></span><br><span class="line"><span class="comment">Bowl(9)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">main creating new Cupboard()</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupborad实例初始化子句执行</span></span><br><span class="line"><span class="comment">Bowl(9)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，初始化的顺序先是静态对象（如果它们之前没有被初始化的话，只初始化一次），然后是非静态对象（先默认初始化，再自动初始化，最后再构造器初始化），从输出中可以看出。要执行 <code>main()</code> 方法，必须加载 <strong>StaticInitialization</strong> 类，它的静态属性 <strong>table</strong> 和 <strong>cupboard</strong> 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 <strong>Bowl</strong> 对象，所以 <strong>Bowl</strong> 类也会被加载。 </p>
<p>同时静态代码块和实例初始化子句都是按照顺序执行的，**<code>没有说实例初始化子句先执行于成员变量的默认初始化和自动初始化</code>**。构造函数的初始化顺序肯定是最后的</p>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Integer[] a = <span class="built_in">new</span> Integer[rand.nextInt(<span class="number">20</span>)];<span class="comment">//注意这是可以的，而且这个是引用数组，里面存储的不是具体对象，而是对象的引用</span></span><br></pre></td></tr></table></figure>



<p>所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 <strong>length</strong>，告诉你这个数组有多少个元素，你不能对其修改。与 C 和 C++ 类似，Java 数组计数也是从 0 开始的，所能使用的最大下标数是 <strong>length - 1</strong>。超过这个边界，C 和 C++ 会默认接受，允许你访问所有内存，许多声名狼藉的 bug 都是由此而生。但是 Java 在你访问超出这个边界时，会报运行时错误（异常），从而避免此类问题。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Spiciness.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个名为 <strong>Spiciness</strong> 的枚举类型，它有 5 个值。由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。</p>
<p>要使用 <strong>enum</strong>，需要创建一个该类型的引用，然后将其赋值给某个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleEnumUse.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你创建 <strong>enum</strong> 时，编译器会自动添加一些有用的特性。例如，它会创建 <code>toString()</code> 方法，以便你方便地显示某个 <strong>enum</strong> 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 <code>ordinal()</code> 方法表示某个特定 <strong>enum</strong> 常量的声明顺序，<code>static values()</code> 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/EnumOrder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Spiciness s: Spiciness.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NOT, ordinal 0</span></span><br><span class="line"><span class="comment">//MILD, ordinal 1</span></span><br><span class="line"><span class="comment">//MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">//HOT, ordinal 3</span></span><br><span class="line"><span class="comment">//FLAMING, ordinal 4</span></span><br></pre></td></tr></table></figure>



<h1 id="七、封装"><a href="#七、封装" class="headerlink" title="七、封装"></a>七、封装</h1><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>包内包含一组类，它们被组织在一个单独的命名空间下。</p>
<p>例如，标准 Java 发布中有一个工具库，它被组织在 <strong>java.util</strong> 命名空间下。<strong>java.util</strong> 中含有一个类，叫做 <strong>ArrayList</strong>。使用 <strong>ArrayList</strong> 的一种方式是用其全名 <strong>java.util.ArrayList</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/FullQualification.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FullQualification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.<span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式使得程序冗长乏味，因此你可以换一种方式，使用 <strong>import</strong> 关键字。如果需要导入某个类，就需要在 <strong>import</strong> 语句中声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/SingleImport.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleImport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你就可以不加限定词，直接使用 <strong>ArrayList</strong> 了。但是对于 <strong>java.util</strong> 包下的其他类，你还是不能用。要导入其中所有的类，只需使用 <strong>*</strong> ，就像本书中其他示例那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure>

<hr>
<p>一个 Java 源代码文件称为一个<em>编译单元</em>（有时也称<em>翻译单元</em>）。每个编译单元的文件名后缀必须是 <strong>.java</strong>。在编译单元中可以有一个 <strong>public</strong> 类，它的类名必须与文件名相同（包括大小写，但不包括后缀名 <strong>.java</strong>）。每个编译单元中只能有一个 <strong>public</strong> 类，否则编译器不接受。如果这个编译单元中还有其他类，那么在包之外是无法访问到这些类的，因为它们不是 <strong>public</strong> 类，此时它们支持主 <strong>public</strong> 类。</p>
<hr>
<p>类库是一组类文件。每个源文件通常都含有一个 <strong>public</strong> 类和任意数量的非 <strong>public</strong> 类，因此每个文件都有一个构件。如果把这些组件集中在一起，就需要使用关键字 <strong>package</strong>。</p>
<p>如果你使用了 <strong>package</strong> 语句，它必须是文件中除了注释之外的第一行代码。当你如下这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hiding;</span><br></pre></td></tr></table></figure>

<p>意味着这个编译单元是一个名为 <strong>hiding</strong> 类库的一部分。换句话说，你正在声明的编译单元中的 <strong>public</strong> 类名称位于名为 <strong>hiding</strong> 的保护伞下。任何人想要使用该名称，必须指明完整的类名或者使用 <strong>import</strong> 关键字导入 <strong>hiding</strong>。（注意，Java 包名按惯例一律小写，即使中间的单词也需要小写，与驼峰命名不同）</p>
<hr>
<p>当创建一个包时，包名就隐含了目录结构。这个包必须位于包名指定的目录中，该目录必须在以 CLASSPATH 开始的目录中可以查询到。</p>
<h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>Java 访问权限修饰符 <strong>public</strong>，<strong>protected</strong> 和 <strong>private</strong> 位于定义的类名，属性名和方法名之前。每个访问权限修饰符只能控制它所修饰的对象。</p>
<p>如果不提供访问修饰符，就意味着”包访问权限”。所以无论如何，万物都有某种形式的访问控制权。</p>
<h3 id="包访问权限"><a href="#包访问权限" class="headerlink" title="包访问权限"></a>包访问权限</h3><p>本章之前的所有示例要么使用 <strong>public</strong> 访问修饰符，要么就没使用修饰符（默认访问）。默认访问权限没有关键字，通常被称为包访问权限（有时也称为 friendly）。这意味着当前包中的所有其他类都可以访问那个成员。对于这个包之外的类，这个成员看上去是 <strong>private</strong> 的。由于一个编译单元（即一个文件）只能隶属于一个包，所以通过包访问权限，位于同一编译单元中的所有类彼此之间都是可访问的。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212119537.png" alt="img"></p>
<h1 id="八、复用"><a href="#八、复用" class="headerlink" title="八、复用"></a>八、复用</h1><p>两种代码复用的方法即组合和继承</p>
<h2 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h2><p>把对象的引用（object references）放置在一个新的类里，这就使用了组合。例如，假设你需要一个对象，其中内置了几个 <strong>String</strong> 对象，两个基本类型（primitives）的属性字段，一个其他类的对象。对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SprinklerSystem</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String valve1, valve2, valve3, valve4;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">WaterSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaterSource</span>();<span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">float</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不会为每个引用创建一个默认对象，这是有意义的，因为在许多情况下，这会导致不必要的开销。初始化引用有四种方法:</p>
<ol>
<li><p>当对象被定义时。这意味着它们总是在调用构造函数之前初始化。</p>
</li>
<li><p>在该类的构造函数中。</p>
</li>
<li><p>在实际使用对象之前。这通常称为<em>延迟初始化</em>。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s4 == <span class="literal">null</span>) <span class="comment">// Delayed initialization:</span></span><br><span class="line">     s4 = <span class="string">&quot;Joy&quot;</span>;<span class="comment">//这里在实际使用前先判断如果没有初始化操作就进行初始化，</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用实例初始化。</p>
</li>
</ol>
<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>继承是所有面向对象语言的一个组成部分。事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。</p>
<p>组合的语法很明显，但是继承使用了一种特殊的语法。使用关键字 <strong>extends</strong> 后跟基类的名称。当你这样做时，你将自动获得基类中的所有字段和方法。</p>
<blockquote>
<p>注意继承后如果 Java 基类的方法名多次重载，则在派生类中重新定义该方法名不会隐藏任何基类版本。也就是子类中还是可以重载与父类同名的方法。</p>
<p>但是如果子类使用与基类中完全相同的签名和返回类型则会覆盖父类中相同名称的方法，此时要调用父类那个方法得用super关键字</p>
</blockquote>
<h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>当你创建派生类的对象时，它包含基类的子对象。这个子对象与你自己创建基类的对象是一样的。只是从外部看，基类的子对象被包装在派生类的对象中。</p>
<p>必须正确初始化基类子对象，而且只有一种方法可以保证这一点 : 通过调用基类构造函数在构造函数中执行初始化，该构造函数具有执行基类初始化所需的所有适当信息和特权。Java 自动在派生类构造函数中插入对基类构造函数的调用。</p>
<p>如果没有无参数的基类构造函数，或者必须调用具有参数的基类构造函数，则必须使用 <strong>super</strong> 关键字和适当的参数列表显式地编写对基类构造函数的调用:</p>
<p>对基类构造函数的调用必须是派生类构造函数中的第一个操作。(如果你写错了，编译器会提醒你。)</p>
<p>##组合、继承、static后的初始化顺序</p>
<p>首先加载类，如果发现加载的类继承了某个父类，则加载父类（以此类推加载），如果这时候加载的父类里发现有静态static修饰的成员变量，那么初始化这个静态成员变量，如果这个静态成员变量是用的组合方式，那么就要找到对应的类加载，（加载的时候可能又有继承，那么就同上一直加载）。静态的加载执行完后就执行非静态的初始化，（==要注意的是静态的加载只会随着类的加载加载一次==）</p>
<p>非静态的初始化首先初始化父类，不管父类有没有被构建，初始化父类时按照成员的默认初始化，自动初始化，构造函数的顺序进行，然后初始化儿子类，也是同样按照成员的默认初始化，自动初始化，构造函数的顺序进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialOrderWithExtend</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 非静态块 1  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 static块 1  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Sample</span> <span class="variable">staticSam1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;父类 静态成员 staticSam1 初始化&quot;</span>);</span><br><span class="line">    <span class="type">Sample</span> <span class="variable">sam1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;父类 普通成员 sam1 初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Sample</span> <span class="variable">staticSam2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;父类 静态成员 staticSam2 初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 static块 2  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 默认构造函数被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Sample</span> <span class="variable">sam2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;父类 普通成员 sam2 初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类 非静态块 2  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 非静态块 1  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Sample</span> <span class="variable">staticSamSub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;子类 静态成员 staticSamSub1 初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 默认构造函数被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Sample</span> <span class="variable">sam1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;子类 普通成员 sam1 初始化&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Sample</span> <span class="variable">staticSamSub2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;子类 静态成员 staticSamSub2 初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 static块1  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Sample</span> <span class="variable">sam2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;子类 普通成员 sam2 初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 非静态块 2  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类 static块2  执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    Sample(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sample() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample默认构造函数被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终执行结果是：</p>
<blockquote>
<p>父类 static块 1  执行  <code>父类静态代码区和父类静态成员</code><br>父类 静态成员 staticSam1 初始化<br>父类 静态成员 staticSam2 初始化<br>父类 static块 2  执行<br>子类 静态成员 staticSamSub1 初始化<br>子类 静态成员 staticSamSub2 初始化<br>子类 static块1  执行   <code>子类静态代码区和子类静态成员</code><br>子类 static块2  执行<br>父类 非静态块 1  执行   <code>父类非静态代码区和普通成员</code><br>父类 普通成员 sam1 初始化<br>父类 普通成员 sam2 初始化<br>父类 非静态块 2  执行<br>父类 默认构造函数被调用  <code>父类构造函数</code><br>子类 非静态块 1  执行   <code>子类非静态代码区和普通成员</code><br>子类 普通成员 sam1 初始化<br>子类 普通成员 sam2 初始化<br>子类 非静态块 2  执行<br>子类 默认构造函数被调用  <code>子类构造函数</code></p>
</blockquote>
<hr>
<p>当执行程序时，首先会访问主类的main方法（一个静态方法），加载器启动并找出 **main方法所在类的编译代码（在名为 <strong>Beetle.class</strong> 的文件中）。在加载过程中，编译器注意到有一个基类，于是继续加载基类。不论是否创建了基类的对象，基类都会被加载。（可以尝试把创建基类对象的代码注释掉证明这点。）</p>
<p>如果基类还存在自身的基类，那么第二个基类也将被加载，以此类推。接下来，根基类（例子中根基类是 <strong>Insect</strong>）的 <strong>static</strong> 的初始化开始执行，接着是派生类，以此类推。这点很重要，因为派生类中 <strong>static</strong> 的初始化可能依赖基类成员是否被正确地初始化。</p>
<p>至此，必要的类都加载完毕，可以创建对象了。首先，对象中的所有基本类型变量都被置为默认值，对象引用被设为 <strong>null</strong> —— 这是通过将对象内存设为二进制零值一举生成的。接着会调用基类的构造器。本例中是自动调用的，但是你也可以使用 <strong>super</strong> 调用指定的基类构造器（在 <strong>Beetle</strong> 构造器中的第一步操作）。基类构造器和派生类构造器一样以相同的顺序经历相同的过程。当基类构造器完成后，子类实例变量按文本顺序初始化。最终，子类构造函数执行。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>下面讨论可能使用 <strong>final</strong> 的三个地方：数据、方法和类。</p>
<p>###final数据</p>
<p>在 Java 中，常量必须是基本类型，而且用关键字 <strong>final</strong> 修饰。你必须在定义常量的时候进行赋值。</p>
<p>一个被 <strong>static</strong> 和 <strong>final</strong> 同时修饰的属性只会占用一段不能改变的存储空间。<strong>static</strong> 强调只有一个，<strong>final</strong> 说明是一个常量。</p>
<p><code>按照惯例，带有恒定初始值的 final static 基本变量（即编译时常量）命名全部使用大写，单词之间用下划线分隔。（源于 C 语言中定义常量的方式。）</code></p>
<p>当用 <strong>final</strong> 修饰对象引用而非基本类型时，其含义会有一点令人困惑。对于基本类型，<strong>final</strong> 使数值恒定不变，而对于对象引用，<strong>final</strong> 使引用恒定不变。一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。（你可以自己编写类达到使对象恒定不变的效果）这一限制同样适用数组，数组也是对象。</p>
<p>###final 参数</p>
<p>在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> &#123;</span><br><span class="line">       <span class="comment">//-g = new Gizmo(); // Illegal -- g is final</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//void f(final int i) &#123; i++; &#125; // Can&#x27;t change</span></span><br><span class="line">   <span class="comment">// You can only read from a final primitive</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法 <code>f()</code> 和 <code>g()</code> 展示了 <strong>final</strong> 基本类型参数的使用情况。你只能读取而不能修改参数。这个特性主要用于传递数据给匿名内部类。这将在”内部类“章节中详解。</p>
<h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><p>使用 <strong>final</strong> 方法的原因有两个。第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。</p>
<p>过去建议使用 <strong>final</strong> 方法的第二个原因是效率。在早期的 Java 实现中，如果将一个方法指明为 <strong>final</strong>，就是同意编译器把对该方法的调用转化为内嵌调用。当编译器遇到 <strong>final</strong> 方法的调用时，就会很小心地跳过普通的插入代码以执行方法的调用机制（将参数压栈，跳至方法代码处执行，然后跳回并清理栈中的参数，最终处理返回值），而用方法体内实际代码的副本替代方法调用。这消除了方法调用的开销。但是如果一个方法很大代码膨胀，你也许就看不到内嵌带来的性能提升，因为内嵌调用带来的性能提高被花费在方法里的时间抵消了。</p>
<p>在最近的 Java 版本中，虚拟机可以探测到这些情况（尤其是 <em>hotspot</em> 技术），并优化去掉这些效率反而降低的内嵌调用方法。有很长一段时间，使用 <strong>final</strong> 来提高效率都被阻止。你应该让编译器和 JVM 处理性能问题，只有在为了明确禁止覆写方法时才使用 <strong>final</strong>。</p>
<h3 id="final-和private"><a href="#final-和private" class="headerlink" title="final 和private"></a>final 和private</h3><p>类中所有的 <strong>private</strong> 方法都隐式地指定为 <strong>final</strong>。因为不能访问 <strong>private</strong> 方法，所以不能覆写它。可以给 <strong>private</strong> 方法添加 <strong>final</strong> 修饰，但是并不能给方法带来额外的含义。</p>
<p>以下情况会令人困惑，当你试图覆写一个 <strong>private</strong> 方法（隐式是 <strong>final</strong> 的）时，看上去奏效，而且编译器不会给出错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalOverridingIllusion.java</span></span><br><span class="line"><span class="comment">// It only looks like you can override</span></span><br><span class="line"><span class="comment">// a private or private final method</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithFinals</span> &#123;</span><br><span class="line">    <span class="comment">// Identical to &quot;private&quot; alone:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithFinals.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Also automatically &quot;final&quot;:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithFinals.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverridingPrivate</span> <span class="keyword">extends</span> <span class="title class_">WithFinals</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverridingPrivate2</span> <span class="keyword">extends</span> <span class="title class_">OverridingPrivate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate2.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate2.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalOverridingIllusion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OverridingPrivate2</span> <span class="variable">op2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverridingPrivate2</span>();</span><br><span class="line">        op2.f();</span><br><span class="line">        op2.g();</span><br><span class="line">        <span class="comment">// You can upcast:</span></span><br><span class="line">        <span class="type">OverridingPrivate</span> <span class="variable">op</span> <span class="operator">=</span> op2;</span><br><span class="line">        <span class="comment">// But you can&#x27;t call the methods:</span></span><br><span class="line">        <span class="comment">//- op.f();</span></span><br><span class="line">        <span class="comment">//- op.g();</span></span><br><span class="line">        <span class="comment">// Same here:</span></span><br><span class="line">        <span class="type">WithFinals</span> <span class="variable">wf</span> <span class="operator">=</span> op2;</span><br><span class="line">        <span class="comment">//- wf.f();</span></span><br><span class="line">        <span class="comment">//- wf.g();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OverridingPrivate2.f()</span><br><span class="line">OverridingPrivate2.g()</span><br></pre></td></tr></table></figure>

<p>“覆写”只发生在方法是基类的接口时。也就是说，必须能将一个对象向上转型为基类并调用相同的方法（这一点在下一章阐明）。如果一个方法是 <strong>private</strong> 的，它就不是基类接口的一部分。它只是隐藏在类内部的代码，且恰好有相同的命名而已。但是如果你在派生类中以相同的命名创建了 <strong>public</strong>，<strong>protected</strong> 或包访问权限的方法，这些方法与基类中的方法没有联系，你没有覆写方法，只是在创建新的方法而已。由于 <strong>private</strong> 方法无法触及且能有效隐藏，除了把它看作类中的一部分，其他任何事物都不需要考虑到它。</p>
<h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>当说一个类是 <strong>final</strong> （<strong>final</strong> 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。</p>
<p><strong>final</strong> 类的属性可以根据个人选择是或不是 <strong>final</strong>。这同样适用于不管类是否是 <strong>final</strong> 的内部 <strong>final</strong> 属性。然而，由于 <strong>final</strong> 类禁止继承，类中所有的方法都被隐式地指定为 <strong>final</strong>，所以没有办法覆写它们。你可以在 final 类中的方法加上 <strong>final</strong> 修饰符，但不会增加任何意义。</p>
<h1 id="九、多态"><a href="#九、多态" class="headerlink" title="九、多态"></a>九、多态</h1><h2 id="方法调用绑定"><a href="#方法调用绑定" class="headerlink" title="方法调用绑定"></a>方法调用绑定</h2><p>将一个方法调用和一个方法主体关联起来称作<em>绑定</em>。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做<em>前期绑定</em>。你可能从来没有听说这个术语，因为它是面向过程语言不需选择默认的绑定方式，例如在 C 语言中就只有<em>前期绑定</em>这一种方法调用。</p>
<p>上述程序让人困惑的地方就在于前期绑定，因为编译器只知道一个 <strong>Instrument</strong> 引用，它无法得知究竟会调用哪个方法。</p>
<p>解决方法就是<em>后期绑定</em>，意味着在运行时根据对象的类型进行绑定。后期绑定也称为<em>动态绑定</em>或<em>运行时绑定</em>。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。</p>
<p>Java 中除了 <strong>static</strong> 和 <strong>final</strong> 方法（<strong>private</strong> 方法也是隐式的 <strong>final</strong>）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。</p>
<p>为什么将一个对象指明为 <strong>final</strong> ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 <strong>final</strong> 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 <strong>final</strong>，而不是为了提升性能而使用。</p>
<hr>
<p>向上转型就像下面这么简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Shape</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br></pre></td></tr></table></figure>

<p>这会创建一个 <strong>Circle</strong> 对象，引用被赋值给 <strong>Shape</strong> 类型的变量 s，这看似错误（将一种类型赋值给另一种类型），然而是没问题的，因此从继承上可认为圆(Circle)就是一个形状(Shape)。因此编译器认可了赋值语句，没有报错。</p>
<p>假设你调用了一个基类方法（在各个派生类中都被重写）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.draw()</span><br></pre></td></tr></table></figure>

<p>你可能再次认为 <strong>Shape</strong> 的 <code>draw()</code> 方法被调用，因为 s 是一个 <strong>Shape</strong> 引用——编译器怎么可能知道要做其他的事呢？然而，由于后期绑定（多态）被调用的是 <strong>Circle</strong> 的 <code>draw()</code> 方法，这是正确的。</p>
<h2 id="陷阱：“重写”私有方法"><a href="#陷阱：“重写”私有方法" class="headerlink" title="陷阱：“重写”私有方法"></a>陷阱：“重写”私有方法</h2><p>你可能天真地试图像下面这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride.java</span></span><br><span class="line"><span class="comment">// Trying to override a private method</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.PrivateOverride&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrivateOverride</span> <span class="variable">po</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Derived <span class="keyword">extends</span> <span class="title class_">PrivateOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private f()</span><br></pre></td></tr></table></figure>

<p>你可能期望输出是 **public f()**，然而 <strong>private</strong> 方法也是 <strong>final</strong> 的，对于派生类来说是隐蔽的。因此，这里 <strong>Derived</strong> 的 <code>f()</code> 是一个全新的方法；因为基类版本的 <code>f()</code> 屏蔽了 <strong>Derived</strong> ，因此它都不算是重写方法。</p>
<p>结论是只有非 <strong>private</strong> 方法才能被重写，但是得小心重写 <strong>private</strong> 方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名采用与基类中 <strong>private</strong> 方法名不同的命名。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">注意调用f的方法和成员变量时，编译能不能通过都是看左边的父类里有没有，</span><br><span class="line">    但是对于成员变量，运行也是看左边，对于成员方法，运行看右边</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于静态方法 要注意即使父类和子类的静态方法名字，参数列表一样也不是重写，调用的时候静态方法是类名.方法名()调用的</p>
</blockquote>
<p>##重写的条件</p>
<p>子类重写的方法的方法名和形参列表与父类被重写的方法名和形参列表相同。<br>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。<br>特殊情况：子类不能重写父类中声明为privite权限的方法。<br><strong>返回值类型：</strong></p>
<ol>
<li><p>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void。</p>
</li>
<li><p>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子集。==（协变返回类型）==</p>
</li>
<li><p>父类被重写的方法的返回值类型是基本数据类型（比如：double），则子类重写的方法的返回值类型必须是相同的基本数据类型。</p>
</li>
</ol>
<p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。<br>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。如果一个是static一个不是的话编译器会报错</p>
<hr>
<p>==注意父类和子类有相同的静态属性和静态方法时，当父类引用指向子类对象，此时调用时是调用父类的静态属性和方法，因为此时没有重写的概念，只有隐藏==</p>
<h2 id="陷阱：构造器中的多态行为"><a href="#陷阱：构造器中的多态行为" class="headerlink" title="陷阱：构造器中的多态行为"></a>陷阱：构造器中的多态行为</h2><p>编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在构造器中唯一能安全调用的只有基类的 <strong>final</strong> 方法（包括 <strong>private</strong> 方法，它们自动属于 <strong>final</strong>）。这些方法不能被重写，因此不会产生意想不到的结果。</p>
<blockquote>
<p>原因是构造器里调用的本类方法可能会被子类重写，那么初始化时是执行的被重写的方法（那个方法用到的数据可能还没初始化）因此不安全</p>
</blockquote>
<h1 id="十、接口"><a href="#十、接口" class="headerlink" title="十、接口"></a>十、接口</h1><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>Java 提供了一个叫做<em>抽象方法</em>的机制，这个方法是不完整的：它只有声明没有方法体。下面是抽象方法的声明语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>包含抽象方法的类叫做<em>抽象类</em>。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface/Basic.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Basic</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">unimplemented</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个抽象类是不完整的，当试图创建这个类的对象时，Java 会怎么做呢？它不会创建抽象类的对象，所以我们只会得到编译器的错误信息。这样保证了抽象类的纯粹性，我们不用担心误用它。</p>
<p>如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做（可以选择不做），新类仍然是一个抽象类，编译器会强制我们为新类加上 <strong>abstract</strong> 关键字。</p>
<p>可以将一个不包含任何抽象方法的类指明为 <strong>abstract</strong>，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。</p>
<blockquote>
<p>注意接口只允许 <strong>public</strong> 方法（jdk9后增加私有），如果不加访问修饰符的话，接口的方法不是 <strong>friendly</strong> 而是 <strong>public</strong>。然而，抽象类的访问修饰符可以是默认的friendly、或者protected 但不能是private。因为private意味着final意味着不能被重写和abstract的矛盾</p>
</blockquote>
<h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>使用关键字 <strong>interface</strong> 而不是 <strong>class</strong> 来创建接口。和类一样，需要在关键字 <strong>interface</strong> 前加上 <strong>public</strong> 关键字（但只是在接口名与文件名相同的情况下），否则接口只有包访问权限，只能在接口相同的包下才能使用它。</p>
<p>接口同样可以包含属性，这些属性被隐式指明为 <strong>static</strong> 和 <strong>final</strong>。</p>
<p>接口中的方法在<strong>java8</strong>之前默认是<strong>public abstract</strong>， Java 8 允许接口包含默认方法（<strong>default</strong>）和静态方法（<strong>static</strong>）</p>
<p>使用 <strong>implements</strong> 关键字使一个类遵循某个特定接口（或一组接口），它表示：接口只是外形，现在我要说明它是如何工作的。除此之外，它看起来像继承。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 为关键字 <strong>default</strong> 增加了一个新的用途（之前只用于 <strong>switch</strong> 语句和注解中）。当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 <strong>default</strong> 创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常有用，我们将在“流式编程”一章中看到</p>
<p>默认方法关键字 <strong>default</strong> 允许在接口中提供方法实现</p>
<p>增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为<em>守卫方法</em>或<em>虚拟扩展方法</em>。</p>
<p>###接口多继承</p>
<p>为了解决这个问题，需要覆写冲突的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Jim.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Jim1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">jim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jim1::jim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Jim2</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">jim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jim2::jim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jim</span> <span class="keyword">implements</span> <span class="title class_">Jim1</span>, Jim2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jim</span><span class="params">()</span> &#123;</span><br><span class="line">        Jim2.<span class="built_in">super</span>.jim(); <span class="comment">//注意这个写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Jim</span>().jim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jim2::jim</span><br></pre></td></tr></table></figure>

<p>当然，你可以重定义 <code>jim()</code> 方法，但是也能像上例中那样使用 <strong>super</strong> 关键字选择基类实现中的一种。</p>
<p>###接口中的静态方法</p>
<p>Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具：（用接口名.方法名的方式调用因此不会出现多继承冲突的情况）</p>
<p>这是模版方法设计模式的一个版本（在“设计模式”一章中详细描述），<code>runOps()</code> 是一个模版方法。<code>runOps()</code> 使用可变参数列表，因而我们可以传入任意多的 <strong>Operation</strong> 参数并按顺序运行它们：（详情见java 8书籍）</p>
<h2 id="抽象类和接口的比较"><a href="#抽象类和接口的比较" class="headerlink" title="抽象类和接口的比较"></a>抽象类和接口的比较</h2><p>尤其是在 Java 8 引入 <strong>default</strong> 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分：</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">组合</td>
<td align="center">新类可以组合多个接口</td>
<td align="center">只能继承单一抽象类</td>
</tr>
<tr>
<td align="center">状态</td>
<td align="center">不能包含属性（除了静态属性，不支持对象状态）</td>
<td align="center">可以包含属性，非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td align="center">默认方法 和 抽象方法</td>
<td align="center">不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td>
<td align="center">必须在子类中实现抽象方法</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">没有构造器</td>
<td align="center">可以有构造器</td>
</tr>
<tr>
<td align="center">可见性</td>
<td align="center">隐式 <strong>public</strong></td>
<td align="center">可以是 <strong>protected</strong> 或友元</td>
</tr>
</tbody></table>
<p>抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。</p>
<p>有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。</p>
<h2 id="继承和接口的一些错误"><a href="#继承和接口的一些错误" class="headerlink" title="继承和接口的一些错误"></a>继承和接口的一些错误</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceCollision.java</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这两个会编译出错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C5</span> <span class="keyword">extends</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">I1</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I4</span> <span class="keyword">extends</span> <span class="title class_">I1</span>, I3 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>#十一、内部类</p>
<h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><h2 id="链接外部类"><a href="#链接外部类" class="headerlink" title="链接外部类"></a>链接外部类</h2><p>当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</p>
<p>内部类可以访问外部类的private字段所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看到：内部类的对象只能在与其外围类的对象相关联的情况下才能被创建（就像你应该看到的，内部类是非 <strong>static</strong> 类时）。构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候这都无需程序员操心。</p>
<h2 id="使用-this-和-new"><a href="#使用-this-和-new" class="headerlink" title="使用 .this 和 .new"></a>使用 .this 和 .new</h2><p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 <strong>this</strong>。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。下面的示例展示了如何使用 <strong>.this</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/DotThis.java</span></span><br><span class="line"><span class="comment">// Accessing the outer-class object</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotThis</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> DotThis <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">// 如果只是this那就表示内部类的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">inner</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DotThis</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotThis</span>();</span><br><span class="line">        DotThis.<span class="type">Inner</span> <span class="variable">dti</span> <span class="operator">=</span> dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DotThis.f()</span><br></pre></td></tr></table></figure>

<p>有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在 <strong>new</strong> 表达式中提供对其他外部类对象的引用，这是需要使用 <strong>.new</strong> 语法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/DotNew.java</span></span><br><span class="line"><span class="comment">// Creating an inner class directly using .new syntax</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DotNew</span> <span class="variable">dn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DotNew</span>();</span><br><span class="line">        DotNew.<span class="type">Inner</span> <span class="variable">dni</span> <span class="operator">=</span> dn.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字 <strong>DotNew</strong>，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。这也解决了内部类名字作用域的问题，因此你不必声明（实际上你不能声明）dn.new DotNew.Inner。</p>
<p>在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p>
<p>##内部类与向上转型</p>
<p>当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。这是因为此内部类-某个接口的实现-能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。</p>
<p>内部类可以用private和protected修饰。<strong>private</strong> 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。</p>
<h2 id="内部类方法和作用域"><a href="#内部类方法和作用域" class="headerlink" title="内部类方法和作用域"></a>内部类方法和作用域</h2><p>到目前为止，读者所看到的只是内部类的典型用途。通常，如果所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单并且容易理解。然而，内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。</p>
<p>这么做有两个理由：</p>
<ol>
<li>如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。</li>
<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li>
</ol>
<p>在后面的例子中，先前的代码将被修改，以用来实现：</p>
<ol>
<li>一个定义在方法中的类。</li>
<li>一个定义在作用域内的类，此作用域在方法的内部。</li>
<li>一个实现了接口的匿名类。</li>
<li>一个匿名类，它扩展了没有默认构造器的类。</li>
<li>一个匿名类，它执行字段初始化。</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。</li>
</ol>
<p>第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel5.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PDestination</span> <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="title function_">PDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PDestination</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel5</span>();</span><br><span class="line">        <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PDestination</strong> 类是 <code>destination()</code> 方法的一部分，而不是 <strong>Parcel5</strong> 的一部分。所以，在 <code>destination()</code> 之外不能访问 <strong>PDestination</strong>，注意出现在 <strong>return</strong> 语句中的向上转型-返回的是 <strong>Destination</strong> 的引用，它是 <strong>PDestination</strong> 的基类。当然，在 <code>destination()</code> 中定义了内部类 <strong>PDestination</strong>，并不意味着一旦 <code>dest()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了。</p>
<p>你可以在同一个子目录下的任意类中对某个内部类使用类标识符 <strong>PDestination</strong>，这并不会有命名冲突。</p>
<p>下面的例子展示了如何在任意的作用域内嵌入一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel6.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalTracking</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">TrackingSlip</span> &#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                String <span class="title function_">getSlip</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TrackingSlip</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackingSlip</span>(<span class="string">&quot;slip&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Can&#x27;t use it here! Out of scope:</span></span><br><span class="line">        <span class="comment">//- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">()</span> &#123; internalTracking(<span class="literal">true</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel6</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel6</span>();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TrackingSlip</strong> 类被嵌入在 <strong>if</strong> 语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义 <strong>Trackingslip</strong> 的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>下面是匿名内部类的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contents</span>() &#123; <span class="comment">// Insert class definition</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">        &#125;; <span class="comment">//需要分号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel7</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7</span>();</span><br><span class="line">        <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>contents()</code> 方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个 <strong>Contents</strong> 对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。</p>
<p>这种奇怪的语法指的是：“创建一个继承自 <strong>Contents</strong> 的匿名类的对象。”通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。上述匿名内部类的语法是下述形式的简化形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel7b</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyContents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel7b</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel7b</span>();</span><br><span class="line">        <span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个匿名内部类中，使用了默认的构造器来生成 <strong>Contents</strong>。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Wrapping <span class="title function_">wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wrapping</span>(x) &#123; <span class="comment">// [1]</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel8</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel8</span>();</span><br><span class="line">        <span class="type">Wrapping</span> <span class="variable">w</span> <span class="operator">=</span> p.wrapping(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>[1] 将合适的参数传递给基类的构造器。</li>
<li>[2] 在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。</li>
</ul>
<p>尽管 <strong>Wrapping</strong> 只是一个具有具体实现的普通类，但它还是被导出类当作公共“接口”来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Wrapping.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wrapping</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wrapping</span><span class="params">(<span class="type">int</span> x)</span> &#123; i = x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了多样性，<strong>Wrapping</strong> 拥有一个要求传递一个参数的构造器。</p>
<p>在匿名类中定义字段时，还能够对其执行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel9.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel9</span> &#123;</span><br><span class="line">    <span class="comment">// Argument must be final or &quot;effectively final&quot;</span></span><br><span class="line">    <span class="comment">// to use within the anonymous inner class:</span></span><br><span class="line">    <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel9</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel9</span>();</span><br><span class="line">        <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 <strong>final</strong> 的（也就是说，它在初始化后不会改变，所以可以被当作 <strong>final</strong>），就像你在 <code>destination()</code> 的参数中看到的那样。这里省略掉 <strong>final</strong> 也没问题，但是通常最好加上 <strong>final</strong> 作为一种暗示。</p>
<p>如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/AnonymousConstructor.java</span></span><br><span class="line"><span class="comment">// Creating a constructor for an anonymous inner class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    Base(<span class="type">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title function_">getBase</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Base</span>(i) &#123;</span><br><span class="line">            &#123; System.out.println(</span><br><span class="line">                    <span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> getBase(<span class="number">47</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base constructor, i = 47</span><br><span class="line">Inside instance initializer</span><br><span class="line">In anonymous f()</span><br></pre></td></tr></table></figure>

<p>在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p>
<p>下例是带实例初始化的”parcel”形式。注意 <code>destination()</code> 的参数必须是 <strong>final</strong> 的，因为它们是在匿名类内部使用的（译者注：即使不加 <strong>final</strong>, Java 8 的编译器也会为我们自动加上 <strong>final</strong>，以保证数据的一致性）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel10.java</span></span><br><span class="line"><span class="comment">// Using &quot;instance initialization&quot; to perform</span></span><br><span class="line"><span class="comment">// construction on an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Destination</span><br><span class="line">    <span class="title function_">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> cost;</span><br><span class="line">            <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel10</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel10</span>();</span><br><span class="line">        <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Over budget!</span><br></pre></td></tr></table></figure>

<p>在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是 <strong>if</strong> 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。</p>
<p>匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为 <strong>static</strong>，这通常称为嵌套类。想要理解 <strong>static</strong> 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象。</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象。</li>
</ol>
<p>嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 <strong>static</strong> 数据和 <strong>static</strong> 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p>
<p>就像你在本章前面看到的那样，在一个普通的（非 <strong>static</strong>）内部类中，通过一个特殊的 <strong>this</strong> 引用可以链接到其外围类对象。嵌套类就没有这个特殊的 <strong>this</strong> 引用，这使得它类似于一个 <strong>static</strong> 方法。</p>
<h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3><p>嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 <strong>public</strong> 和 <strong>static</strong> 的。因为类是 <strong>static</strong> 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外围接口，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/ClassInInterface.java</span></span><br><span class="line"><span class="comment">// &#123;java ClassInInterface$Test&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">ClassInInterface</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">howdy</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Test</span>().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Howdy!</span><br></pre></td></tr></table></figure>

<p>如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。</p>
<p>我曾在本书中建议过，在每个类中都写一个 <code>main()</code> 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestBed.java</span></span><br><span class="line"><span class="comment">// Putting test code in a nested class</span></span><br><span class="line"><span class="comment">// &#123;java TestBed$Tester&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBed</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tester</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">TestBed</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBed</span>();</span><br><span class="line">            t.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f()</span><br></pre></td></tr></table></figure>

<p>这生成了一个独立的类 <strong>TestBed$Tester</strong>（要运行这个程序，执行 <strong>java TestBed$Tester</strong>，在 Unix/Linux 系统中需要转义 **$**）。你可以使用这个类测试，但是不必在发布的产品中包含它，可以在打包产品前删除 <strong>TestBed$Tester.class</strong>。</p>
<h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiNestingAccess.java</span></span><br><span class="line"><span class="comment">// Nested classes can access all members of all</span></span><br><span class="line"><span class="comment">// levels of the classes they are nested within</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MNA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiNestingAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MNA</span> <span class="variable">mna</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MNA</span>();</span><br><span class="line">        MNA.<span class="type">A</span> <span class="variable">mnaa</span> <span class="operator">=</span> mna.<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        MNA.A.<span class="type">B</span> <span class="variable">mnaab</span> <span class="operator">=</span> mnaa.<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        mnaab.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 <strong>MNA.A.B</strong> 中，调用方法 <code>g()</code> 和 <code>f()</code> 不需要任何条件（即使它们被定义为 <strong>private</strong>）。这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。”<strong>.new</strong>“语法能产生正确的作用域，所以不必在调用构造器时限定类名。</p>
<p>（如果改为静态的方式的话调用方式用MNA.A.B.h();）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MNA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiNestingAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MNA</span> <span class="variable">mna</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MNA</span>();</span><br><span class="line">        MNA.A.B.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能同答“为什么需要内部类”这个问题。那么，Java 设计者们为什么会如此费心地增加这项基本的语言特性呢？</p>
<p>一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。</p>
<p>内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：</p>
<blockquote>
<p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>
</blockquote>
<p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。</p>
<p>为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：</p>
<p>当然，这里假设在两种方式下的代码结构都确实有逻辑意义。然而遇到问题的时候，通常问题本身就能给出某些指引，告诉你是应该使用单一类，还是使用内部类。但如果没有任何其他限制，从实现的观点来看，前面的例子并没有什么区别，它们都能正常运作。</p>
<p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiImplementation.java</span></span><br><span class="line"><span class="comment">// For concrete or abstract classes, inner classes</span></span><br><span class="line"><span class="comment">// produce &quot;multiple implementation inheritance&quot;</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.MultiImplementation&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    E <span class="title function_">makeE</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">E</span>() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiImplementation</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">takesD</span><span class="params">(D d)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">takesE</span><span class="params">(E e)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Z</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Z</span>();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p>
<ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。<br>稍后就会展示一个这样的例子。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建</li>
<li>内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</li>
</ol>
<p>举个例子，如果 <strong>Sequence.java</strong> 不使用内部类，就必须声明”<strong>Sequence</strong> 是一个 <strong>Selector</strong>“，对于某个特定的 <strong>Sequence</strong> 只能有一个 <strong>Selector</strong>，然而使用内部类很容易就能拥有另一个方法 <code>reverseSelector()</code>，用它来生成一个反方向遍历序列的 <strong>Selector</strong>，只有内部类才有这种灵活性。</p>
<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3><p>闭包（<strong>closure</strong>）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 <strong>private</strong> 成员。</p>
<p>在 Java 8 之前，生成闭包行为的唯一方式就是内部类。在 Java 8 之后，我们可以使用 lambda 表达式来生成闭包行为，并且语法更加精细和简洁；你将会在 <a href="">函数式编程 </a> 这一章节中学习相关细节。即使应该优先使用 lambda 表达式用于内部类闭包，你依旧会看到那些 Java 8 以前的代码，即使用内部类来表示闭包的方式，所以非常有必要来理解这种形式。</p>
<p>Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。</p>
<p>通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。见下例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Callbacks.java</span></span><br><span class="line"><span class="comment">// Using inner classes for callbacks</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.Callbacks&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Very simple to just implement the interface:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callee1</span> <span class="keyword">implements</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIncrement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(MyIncrement mi)</span> &#123; mi.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callee2</span> <span class="keyword">extends</span> <span class="title class_">MyIncrement</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Closure</span> <span class="keyword">implements</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise</span></span><br><span class="line">            <span class="comment">// you&#x27;ll get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="built_in">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Incrementable <span class="title function_">getCallbackReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Closure</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caller</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Callbacks</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callee1</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callee1</span>();</span><br><span class="line">        <span class="type">Callee2</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callee2</span>();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        <span class="type">Caller</span> <span class="variable">caller1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caller</span>(c1);</span><br><span class="line">        <span class="type">Caller</span> <span class="variable">caller2</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Caller</span>(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Other operation</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Other operation</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Other operation</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别。就代码而言，<strong>Calleel</strong> 是更简单的解决方式。<strong>Callee2</strong> 继承自 <strong>MyIncrement</strong>，后者已经有了一个不同的 <code>increment()</code> 方法，并且与 <strong>Incrementable</strong> 接口期望的 <code>increment()</code> 方法完全不相关。所以如果 <strong>Callee2</strong> 继承了 <strong>MyIncrement</strong>，就不能为了 <strong>Incrementable</strong> 的用途而覆盖 <code>increment()</code> 方法，于是只能使用内部类独立地实现 <strong>Incrementable</strong>，还要注意，当创建了一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口。</p>
<p>注意，在 <strong>Callee2</strong> 中除了 <code>getCallbackReference()</code> 以外，其他成员都是 <strong>private</strong> 的。要想建立与外部世界的任何连接，接口 <strong>Incrementable</strong> 都是必需的。在这里可以看到，<strong>interface</strong> 是如何允许接口与接口的实现完全独立的。<br>内部类 <strong>Closure</strong> 实现了 <strong>Incrementable</strong>，以提供一个返回 <strong>Callee2</strong> 的“钩子”（hook）-而且是一个安全的钩子。无论谁获得此 <strong>Incrementable</strong> 的引用，都只能调用 <code>increment()</code>，除此之外没有其他功能（不像指针那样，允许你做很多事情）。</p>
<p><strong>Caller</strong> 的构造器需要一个 <strong>Incrementable</strong> 的引用作为参数（虽然可以在任意时刻捕获回调引用），然后在以后的某个时刻，<strong>Caller</strong> 对象可以使用此引用回调 <strong>Callee</strong> 类。</p>
<p>回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现 GUI 功能的时候，到处都用到回调。</p>
<h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在干，那个指向外围类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/InheritInner.java</span></span><br><span class="line"><span class="comment">// Inheriting an inner class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">    <span class="comment">//- InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">        <span class="type">InheritInner</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>InheritInner</strong> 只继承自内部类，而不是外围类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外围类对象的引用。此外，必须在构造器内使用如下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类引用.<span class="built_in">super</span>();</span><br></pre></td></tr></table></figure>

<p>这样才提供了必要的引用，然后程序才能编译通过。</p>
<h2 id="内部类不能被覆盖"><a href="#内部类不能被覆盖" class="headerlink" title="内部类不能被覆盖"></a>内部类不能被覆盖</h2><p>如果创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？答案是不能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg.java</span></span><br><span class="line"><span class="comment">// An inner class cannot be overridden like a method</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Egg() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">        y = <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg</span> <span class="keyword">extends</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BigEgg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New Egg()</span><br><span class="line">Egg.Yolk()</span><br></pre></td></tr></table></figure>

<p>默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了 <strong>BigEgg</strong> 的对象，那么所使用的应该是“覆盖后”的 <strong>Yolk</strong> 版本，但从输出中可以看到实际情况并不是这样的。</p>
<p>这个例子说明，当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg2.java</span></span><br><span class="line"><span class="comment">// Proper inheritance of an inner class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Yolk</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yolk</span>();<span class="comment">//[1]父类的成员变量初始化</span></span><br><span class="line">    Egg2() &#123; System.out.println(<span class="string">&quot;New Egg2()&quot;</span>); &#125; <span class="comment">//[2]父类构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertYolk</span><span class="params">(Yolk yy)</span> &#123; y = yy; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123; y.f(); &#125;<span class="comment">//[6]此时是父类引用指向子类对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg2</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> <span class="keyword">extends</span> <span class="title class_">Egg2</span>.Yolk &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//[4]执行子类的构造函数之前得先执行父类的初始化</span></span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>);<span class="comment">//[5]子类的构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigEgg2</span><span class="params">()</span> &#123; insertYolk(<span class="keyword">new</span> <span class="title class_">Yolk</span>()); &#125; <span class="comment">//[3]子类的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Egg2</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigEgg2</span>();</span><br><span class="line">        e2.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Egg2.Yolk()</span><br><span class="line">New Egg2()</span><br><span class="line">Egg2.Yolk()</span><br><span class="line">BigEgg2.Yolk()</span><br><span class="line">BigEgg2.Yolk.f()</span><br></pre></td></tr></table></figure>

<h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 <strong>Class</strong> 对象）。</p>
<p>你可能猜到了，内部类也必须生成一个**.class** 文件以包含它们的 <strong>Class</strong> 对象信息。这些类文件的命名有严格的规则：外围类的名字，加上“<strong>$</strong>“，再加上内部类的名字。例如，<strong>LocalInnerClass.java</strong> 生成的 <strong>.class</strong> 文件包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">LocalInnerClass$1</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">LocalInnerClass$1LocalCounter</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">LocalInnerClass</span>.class</span><br></pre></td></tr></table></figure>

<p>如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与“**$**”的后面。</p>
<p>虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。）</p>
<h1 id="十二、集合"><a href="#十二、集合" class="headerlink" title="十二、集合"></a>十二、集合</h1><p>##泛型和类型安全的集合</p>
<p>过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。[^3]下面还是这个示例，但是使用了泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithGenerics.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplesAndOrangesWithGenerics</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    <span class="comment">// Compile-time error:</span></span><br><span class="line">    <span class="comment">// apples.add(new Orange());</span></span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples) &#123;</span><br><span class="line">      System.out.println(apple.id());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>apples</strong> 定义的右侧，可以看到 <code>new ArrayList&lt;&gt;()</code> 。这有时被称为“菱形语法”（diamond syntax）。在 Java 7 之前，必须要在两端都进行类型声明，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>

<p>随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然<em>类型推断</em>（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。</p>
<p>有了 <strong>ArrayList</strong> 声明中的类型指定，编译器会阻止将 <strong>Orange</strong> 放入 <strong>apples</strong> ，因此，这会成为一个编译期错误而不是运行时错误。</p>
<p>使用泛型，从 <strong>List</strong> 中获取元素不需要强制类型转换。因为 <strong>List</strong> 知道它持有什么类型，因此当调用 <code>get()</code> 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。</p>
<p>当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/GenericsAndUpcasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrannySmith</span> <span class="keyword">extends</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gala</span> <span class="keyword">extends</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fuji</span> <span class="keyword">extends</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Braeburn</span> <span class="keyword">extends</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsAndUpcasting</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">GrannySmith</span>());</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Gala</span>());</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Fuji</span>());</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Braeburn</span>());</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples)</span><br><span class="line">      System.out.println(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">GrannySmith@15db9742</span></span><br><span class="line"><span class="comment">Gala@6d06d69c</span></span><br><span class="line"><span class="comment">Fuji@7852e922</span></span><br><span class="line"><span class="comment">Braeburn@4e25154f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因此，可以将 <strong>Apple</strong> 的子类型添加到被指定为保存 <strong>Apple</strong> 对象的集合中。</p>
<p>程序的输出是从 <strong>Object</strong> 默认的 <code>toString()</code> 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 <code>hashCode()</code> 方法产生的）。将在<a href="">附录：理解 equals 和 hashCode 方法</a>中了解有关散列码的内容。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li>
<li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li>
</ol>
<p>尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 <strong>List</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>请注意， <strong>ArrayList</strong> 已经被向上转型为了 <strong>List</strong> ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p>
<p>这种方式并非总是有效的，因为某些具体类有额外的功能。例如， <strong>LinkedList</strong> 具有 <strong>List</strong> 接口中未包含的额外方法，而 <strong>TreeMap</strong> 也具有在 <strong>Map</strong> 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p>
<h2 id="添加元素组"><a href="#添加元素组" class="headerlink" title="添加元素组"></a>添加元素组</h2><p>在 <strong>java.util</strong> 包中的 <strong>Arrays</strong> 和 <strong>Collections</strong> 类中都有很多实用的方法，可以在一个 <strong>Collection</strong> 中添加一组元素。</p>
<p><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。 <code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。下边的示例展示了这两个方法，以及更通用的 <code>addAll()</code> 方法，所有 <strong>Collection</strong> 类型都包含该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/AddingGroups.java</span></span><br><span class="line"><span class="comment">// Adding groups of elements to Collection objects</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddingGroups</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Integer&gt; collection =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    collection.addAll(Arrays.asList(moreInts));<span class="comment">//只能接收另一个collection作为参数</span></span><br><span class="line">    <span class="comment">// Runs significantly faster, but you can&#x27;t</span></span><br><span class="line">    <span class="comment">// construct a Collection this way:</span></span><br><span class="line">    Collections.addAll(collection, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">    Collections.addAll(collection, moreInts);</span><br><span class="line">    <span class="comment">// Produces a list &quot;backed by&quot; an array:</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>);</span><br><span class="line">    list.set(<span class="number">1</span>, <span class="number">99</span>); <span class="comment">// OK -- modify an element</span></span><br><span class="line">    <span class="comment">// list.add(21); // Runtime error; the underlying</span></span><br><span class="line">                     <span class="comment">// array cannot be resized.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Collection</strong> 的构造器可以接受另一个 <strong>Collection</strong>，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 <strong>Collection</strong> ，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p>
<p><code>Collection.addAll()</code> 方法只能接受另一个 <strong>Collection</strong> 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p>
<p>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 <strong>List</strong> ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 <strong>List</strong> 上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</p>
<h2 id="集合的打印"><a href="#集合的打印" class="headerlink" title="集合的打印"></a>集合的打印</h2><p>必须使用 <code>Arrays.toString()</code> 来生成数组的可打印形式。但是打印集合无需任何帮助。下面是一个例子，这个例子中也介绍了基本的 Java 集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/PrintingCollections.java</span></span><br><span class="line"><span class="comment">// Collections print themselves automatically</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintingCollections</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> Collection</span><br><span class="line">  <span class="title function_">fill</span><span class="params">(Collection&lt;String&gt; collection)</span> &#123;</span><br><span class="line">    collection.add(<span class="string">&quot;rat&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> collection;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Map <span class="title function_">fill</span><span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;Fuzzy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;Rags&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;Bosco&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;Spot&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">[cat, dog, rat]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span></span><br><span class="line"><span class="comment">&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这显示了 Java 集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 <strong>Collection</strong> 类型在每个槽中只能保存一个元素。此类集合包括： <strong>List</strong> ，它以特定的顺序保存一组元素； <strong>Set</strong> ，其中元素不允许重复； <strong>Queue</strong> ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 <strong>Map</strong> 在每个槽中存放了两个元素，即<em>键</em>和与之关联的<em>值</em>。</p>
<p>默认的打印行为，使用集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。</p>
<p>第一个 <code>fill()</code> 方法适用于所有类型的 <strong>Collection</strong> ，这些类型都实现了 <code>add()</code> 方法以添加新元素。</p>
<p><strong>ArrayList</strong> 和 <strong>LinkedList</strong> 都是 <strong>List</strong> 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 <strong>LinkedList</strong> 包含的操作多于 <strong>ArrayList</strong> 。本章后面将对这些内容进行更全面的探讨。</p>
<p><strong>HashSet</strong> ， <strong>TreeSet</strong> 和 <strong>LinkedHashSet</strong> 是 <strong>Set</strong> 的类型。从输出中可以看到， <strong>Set</strong> 仅保存每个相同项中的一个，并且不同的 <strong>Set</strong> 实现存储元素的方式也不同。 <strong>HashSet</strong> 使用相当复杂的方法存储元素，这在<a href="">附录：集合主题</a>中进行了探讨。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 <strong>Set</strong> 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 <strong>TreeSet</strong> ，它将按比较结果的升序保存对象）或 <strong>LinkedHashSet</strong> ，它按照被添加的先后顺序保存对象。</p>
<p><strong>Map</strong> （也称为<em>关联数组</em>）使用<em>键</em>来查找对象，就像一个简单的数据库。所关联的对象称为<em>值</em>。 假设有一个 <strong>Map</strong> 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， <strong>Map</strong> 只存储一次。</p>
<p><code>Map.put(key, value)</code> 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 <code>Map.get(key)</code> 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。</p>
<p>请注意，这里没有指定（或考虑） <strong>Map</strong> 的大小，因为它会自动调整大小。 此外， <strong>Map</strong> 还知道如何打印自己，它会显示相关联的键和值。</p>
<p>本例使用了 <strong>Map</strong> 的三种基本风格： <strong>HashMap</strong> ， <strong>TreeMap</strong> 和 <strong>LinkedHashMap</strong> 。</p>
<p>键和值保存在 <strong>HashMap</strong> 中的顺序不是插入顺序，因为 <strong>HashMap</strong> 实现使用了非常快速的算法来控制顺序。 <strong>TreeMap</strong> 通过比较结果的升序来保存键， <strong>LinkedHashMap</strong> 在保持 <strong>HashMap</strong> 查找速度的同时按键的插入顺序保存键。</p>
<h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p>
<p>有两种类型的 <strong>List</strong> ：</p>
<ul>
<li><p>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</p>
</li>
<li><p><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</p>
</li>
</ul>
<p>==下面是Collection接口拥有的方法==</p>
<table>
<thead>
<tr>
<th><code>boolean</code></th>
<th><code>add(E e)</code>确保此集合包含指定的元素（可选操作）。</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>将指定集合中的所有元素添加到此集合（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>从此集合中删除所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>将指定的对象与此集合进行比较如果所有元素都一样则相同返回true</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>返回此集合的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>删除指定集合中包含的所有此集合的元素（可选操作）请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>删除满足给定谓词的此集合的所有元素。（可用lambda表达式）</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>仅保留此集合中包含在指定集合中的元素（可选操作）。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>返回此集合中的元素数。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code>返回以此集合作为源的顺序 <code>Stream</code> 。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>返回一个包含此集合中所有元素的数组。默认为object类型，因此最好用下面的重载形式，免去类型转换</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>返回包含此集合中所有元素的数组;返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<p>==下面是LinkList所拥有的方法==</p>
<p>没有绿色标注的是ArrayList和LinkList共有的方法</p>
<table>
<thead>
<tr>
<th><code>boolean</code></th>
<th><code>add(E e)</code>将指定的元素追加到此列表的末尾。</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>add(int index, E element)</code>在此列表中的指定位置插入指定的元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>按照指定集合的迭代器返回的顺序将指定集合中的所有元素追加到此列表的末尾。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(int index, Collection&lt;? extends E&gt; c)</code>将指定集合中的所有元素插入到此列表中，从指定的位置开始。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addFirst(E e)</code>==在该列表开头插入指定的元素。==</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addLast(E e)</code>==将指定的元素追加到此列表的末尾。==</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>从列表中删除所有元素。</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>clone()</code>返回此 <code>LinkedList</code>的浅版本。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>如果此列表包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>descendingIterator()</code>==以相反的顺序返回此deque中的元素的迭代器。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>element()</code>==检索但不删除此列表的头（第一个元素）。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>get(int index)</code>返回此列表中指定位置的元素。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>getFirst()</code>==返回此列表中的第一个元素。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>getLast()</code>==返回此列表中的最后一个元素。==</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(Object o)</code>返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</td>
</tr>
<tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator(int index)</code>从列表中的指定位置开始，返回此列表中元素的列表迭代器（按适当的顺序）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code>==将指定的元素添加为此列表的尾部（最后一个元素）。==</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offerFirst(E e)</code>==在此列表的前面插入指定的元素。==</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offerLast(E e)</code>==在该列表的末尾插入指定的元素。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code>==检索但不删除此列表的头（第一个元素）。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peekFirst()</code>==检索但不删除此列表的第一个元素，如果此列表为空，则返回 <code>null</code> 。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peekLast()</code>==检索但不删除此列表的最后一个元素，如果此列表为空，则返回 <code>null</code> 。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code>==检索并删除此列表的头（第一个元素）。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pollFirst()</code>==检索并删除此列表的第一个元素，如果此列表为空，则返回 <code>null</code> 。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pollLast()</code>==检索并删除此列表的最后一个元素，如果此列表为空，则返回 <code>null</code> 。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pop()</code>==从此列表表示的堆栈中弹出一个元素。==</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push(E e)</code>==将元素推送到由此列表表示的堆栈上。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove()</code>==检索并删除此列表的头（第一个元素）。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove(int index)</code>删除该列表中指定位置的元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>从列表中删除指定元素的第一个出现（如果存在）。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>removeFirst()</code>==从此列表中删除并返回第一个元素。==</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeFirstOccurrence(Object o)</code>==删除此列表中指定元素的第一个出现（从头到尾遍历列表时）。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>removeLast()</code>==从此列表中删除并返回最后一个元素。==</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeLastOccurrence(Object o)</code>==删除此列表中指定元素的最后一次出现（从头到尾遍历列表时）。==</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>set(int index, E element)</code>用指定的元素替换此列表中指定位置的元素。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>返回此列表中的元素数。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList特有的方法是</span></span><br><span class="line">    	ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="number">11</span>);</span><br><span class="line">        a.add(<span class="number">21</span>);</span><br><span class="line">        a.add(<span class="number">31</span>);</span><br><span class="line">        a.add(<span class="number">41</span>);</span><br><span class="line">        List&lt;Integer&gt; integers = a.subList(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        integers.forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">//输出21 31</span></span><br></pre></td></tr></table></figure>

<p>##链表 LinkedList</p>
<p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p>
<p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p>
<ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><p>传统遍历方式会发现有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p>
<p>_迭代器_（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为<em>轻量级对象</em>（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p>
<ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p>
<p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 <em>for-in</em> 语法更加简洁。</p>
<p><strong>Iterator</strong> 还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。[^4]</p>
<p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p>
<p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossCollectionIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p>
<p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration2.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossCollectionIteration2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterable&lt;Pet&gt; ip)</span> &#123;<span class="comment">//注意这里变成Iterable</span></span><br><span class="line">    Iterator&lt;Pet&gt; it = ip.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(pets);</span><br><span class="line">    display(pets);</span><br><span class="line">    display(petsLL);</span><br><span class="line">    display(petsHS);</span><br><span class="line">    display(petsTS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;			  (Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line">        ListIterator&lt;Integer&gt; it = a.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">            System.out.print(it.next() +</span><br><span class="line">                    <span class="string">&quot;,&quot;</span> + it.nextIndex() +</span><br><span class="line">                    <span class="string">&quot;,&quot;</span> + it.previousIndex() + <span class="string">&quot; ; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// Backwards:</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">            System.out.print(it.previous()+ <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        it = a.listIterator(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(<span class="number">71</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1,1,0 ; 2,2,1 ; 3,3,2 ; 4,4,3 ; 5,5,4 ; 6,6,5 ; 7,7,6 ; 8,8,7 ; 9,9,8 ; </span></span><br><span class="line"><span class="comment">9 8 7 6 5 4 3 2 1 </span></span><br><span class="line"><span class="comment">[1, 2, 3, 71, 71, 71, 71, 71, 71]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>###关于删除的注意事项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//of啥的是jdk9的新特性</span></span><br><span class="line">   <span class="comment">// Map&lt;Integer, String&gt; map1 = new HashMap&lt;Integer, String&gt;(Map.of(1, &quot;value1&quot;, 2, &quot;value2&quot;, 3, &quot;value3&quot;));</span></span><br><span class="line">       ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>));</span><br><span class="line">       Iterator&lt;Integer&gt; iterator = a.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="number">3</span>)&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.forEach(s -&gt; System.out.print(s + <span class="string">&quot;  &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; a.size() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">4</span> == a.get(i))&#123;</span><br><span class="line">                a.remove(i);</span><br><span class="line">                i--; <span class="comment">//注意这里必须--才能正常移除4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.forEach(s -&gt; System.out.print(s + <span class="string">&quot;  &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆栈Stack"><a href="#堆栈Stack" class="headerlink" title="堆栈Stack"></a>堆栈Stack</h2><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：入栈用<code>push( )</code>，取栈顶用<code>peek( )</code>,  出栈用<code>pop( )</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     	Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            stack.push(s);</span><br><span class="line">        System.out.println(stack.peek() + <span class="string">&quot; &quot;</span>);<span class="comment">//取栈顶，但不删除</span></span><br><span class="line">        System.out.println(stack.peek() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">            System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas </span></span><br><span class="line"><span class="comment">fleas </span></span><br><span class="line"><span class="comment">fleas has dog My </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p><strong>LinkedList</strong> 实现了 <strong>Queue</strong> 接口，并且提供了一些方法以支持队列行为，因此 <strong>LinkedList</strong> 可以用作 <strong>Queue</strong> 的一种实现。 通过将 <strong>LinkedList</strong> 向上转换为 <strong>Queue</strong> ，下面的示例使用了在 <strong>Queue</strong> 接口中与 <strong>Queue</strong> 相关(Queue-specific)的方法：</p>
<p>入队用<code>offer( )</code>，取队头用<code>peek( )</code>，出队用<code>poll( )</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/QueueDemo.java</span></span><br><span class="line"><span class="comment">// Upcasting to a Queue from a LinkedList</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printQ</span><span class="params">(Queue queue)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(queue.peek() != <span class="literal">null</span>)</span><br><span class="line">      System.out.print(queue.remove() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      queue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">    printQ(queue);</span><br><span class="line">    Queue&lt;Character&gt; qc = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : <span class="string">&quot;Brontosaurus&quot;</span>.toCharArray())</span><br><span class="line">      qc.offer(c);</span><br><span class="line">    printQ(qc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">8 1 1 1 5 14 3 1 0 1</span></span><br><span class="line"><span class="comment">B r o n t o s a u r u s</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 <code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 <code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</p>
<p>###优先级队列</p>
<p>优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在 Java 5 中添加了 <strong>PriorityQueue</strong> ，以便自动实现这种行为。</p>
<p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。[^5]默认的排序使用队列中对象的<em>自然顺序</em>（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p>
<p><strong>PriorityQueue</strong> 是允许重复的，最小的值具有最高的优先级（如果是 <strong>String</strong> ，空格也可以算作值，并且比字母的优先级高）</p>
<p>想要去重可以添加一个 <strong>HashSet</strong> 。如下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/PriorityQueueDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      priorityQueue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">   </span><br><span class="line">    List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>, <span class="number">22</span>, <span class="number">20</span>,</span><br><span class="line">      <span class="number">18</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>);</span><br><span class="line">    priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(ints);</span><br><span class="line">   </span><br><span class="line">    priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">        ints.size(), Collections.reverseOrder());</span><br><span class="line">    priorityQueue.addAll(ints);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">fact</span> <span class="operator">=</span> <span class="string">&quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;</span>;</span><br><span class="line">    List&lt;String&gt; strings =</span><br><span class="line">      Arrays.asList(fact.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    PriorityQueue&lt;String&gt; stringPQ =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(strings);</span><br><span class="line"></span><br><span class="line">    stringPQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">      strings.size(), Collections.reverseOrder());</span><br><span class="line">    stringPQ.addAll(strings);</span><br><span class="line"></span><br><span class="line">    Set&lt;Character&gt; charSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : fact.toCharArray())</span><br><span class="line">      charSet.add(c); <span class="comment">// Autoboxing</span></span><br><span class="line">    PriorityQueue&lt;Character&gt; characterPQ =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(charSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>boolean</code></th>
<th><code>add(E e)</code>将指定的元素插入到此优先级队列中。</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>clear()</code>从此优先级队列中删除所有元素。</td>
</tr>
<tr>
<td><code>Comparator&lt;? super E&gt;</code></td>
<td><code>comparator()</code>返回用于为了在这个队列中的元素，或比较<code>null</code>如果此队列根据所述排序<a href="../../java/lang/Comparable.html">natural ordering</a>的元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>如果此队列包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>返回此队列中的元素的迭代器。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code>将指定的元素插入到此优先级队列中。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code>检索但不删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code>检索并删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>从该队列中删除指定元素的单个实例（如果存在）。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>返回此集合中的元素数。</td>
</tr>
<tr>
<td><code>Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code>在此队列中的元素上创建*<a href="Spliterator.html#binding">late-binding</a><em>和</em>失败快速* <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a> 。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>返回一个包含此队列中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>返回一个包含此队列中所有元素的数组;返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<p>入队依然用<code>offer(E  e)</code>, 取队头依然是<code>peek( )</code>，出队<code>poll( )</code>，</p>
<p>此外还可以查找是否在优先队列中用<code>contains(Object o)</code>，删除元素用<code>remove(Object o)</code></p>
<p>还可以转成数组形式</p>
<p>下面是自定义比较器的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/PriorityQueueDemo.java</span></span><br><span class="line"><span class="keyword">package</span> b;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    Student(<span class="type">int</span> age, String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Student&gt; priorityQueue =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Student a, Student b)-&gt;&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a.age - b.age;</span><br><span class="line">                    result = result == <span class="number">0</span> ? a.name.compareTo(b.name):result;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">ddd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">10</span>, <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">bbb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">aaa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">ccc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">10</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        priorityQueue.offer(ddd);</span><br><span class="line">        priorityQueue.offer(aaa);</span><br><span class="line">        priorityQueue.offer(bbb);</span><br><span class="line">        priorityQueue.offer(ccc);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">            System.out.println(priorityQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Student&#123;age=1, name=&#x27;bbb&#x27;&#125;</span></span><br><span class="line"><span class="comment">Student&#123;age=10, name=&#x27;ccc&#x27;&#125;</span></span><br><span class="line"><span class="comment">Student&#123;age=10, name=&#x27;ddd&#x27;&#125;</span></span><br><span class="line"><span class="comment">Student&#123;age=20, name=&#x27;aaa&#x27;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p>
<p><strong>Set</strong> 具有与 <strong>Collection</strong> 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 <strong>List</strong> 那样。实际上， <strong>Set</strong> 就是一个 <strong>Collection</strong> ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）<strong>Set</strong> 根据对象的“值”确定归属性，更复杂的内容将在<a href="">附录：集合主题</a>中介绍。</p>
<p>下面是使用存放 <strong>Integer</strong> 对象的 <strong>HashSet</strong> 的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/SetOfInteger.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetOfInteger</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    Set&lt;Integer&gt; intset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">      intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">    System.out.println(intset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,</span></span><br><span class="line"><span class="comment">16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 0 到 29 之间的 10000 个随机整数被添加到 <strong>Set</strong> 中，因此可以想象每个值都重复了很多次。但是从结果中可以看到，每一个数只有一个实例出现在结果中。</p>
<p>早期 Java 版本中的 <strong>HashSet</strong> 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， <strong>HashSet</strong> 使用了散列，请参阅<a href="">附录：集合主题</a>一章。由 <strong>HashSet</strong> 维护的顺序与 <strong>TreeSet</strong> 或 <strong>LinkedHashSet</strong> 不同，因为它们的实现具有不同的元素存储方式。 <strong>TreeSet</strong> 将元素存储在红-黑树数据结构中，而 <strong>HashSet</strong> 使用散列函数。 <strong>LinkedHashSet</strong> 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 <strong>Integer</strong> 按顺序排序。但是，您不应该依赖此行</p>
<p>###TreeSet进行排序</p>
<p>TreeSet的排序规则有两种实现</p>
<p><strong>第一种：自然排序Comparable的使用</strong></p>
<ul>
<li>使用<code>空参构造</code>创建TreeSet的集合</li>
<li>自定义的Student类实现<code>Comparable</code>接口</li>
<li>重写接口里面的<code>compareTo</code>方法</li>
</ul>
<p><strong>自然排序简单原理图</strong></p>
<ul>
<li>如果返回值为负数，表示当前存入的元素是较小者，存左边</li>
<li>如果返回值为0，表示当前存入的元素跟集合中的元素重复了，不存</li>
<li>如果返回值为正数，表示当前存入的元素是较大者，存右边</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age - a.age;</span><br><span class="line">    result = result == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(a.name):result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种比较器排序Comparator的使用</strong></p>
<ul>
<li><p>TreeSet的带参构造方法使用的是<code>比较器排序</code>对元素进行排序的</p>
</li>
<li><p>比较器排序，就是<code>让集合构造方法接收Comparetor的实现类对象</code>，重写</p>
<p>compare（T a , T b）方法</p>
</li>
<li><p>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">   	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o1.age - o2.age;</span><br><span class="line">  	result = result == <span class="number">0</span> ? o1.name.compareTo(o2.name):result;</span><br><span class="line">   	<span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p>==下面是Collection接口拥有的方法也是Set拥有的方法==</p>
<table>
<thead>
<tr>
<th><code>boolean</code></th>
<th><code>add(E e)</code>确保此集合包含指定的元素（可选操作）。</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>将指定集合中的所有元素添加到此集合（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>从此集合中删除所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>将指定的对象与此集合进行比较如果所有元素都一样则相同返回true</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>返回此集合的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>删除指定集合中包含的所有此集合的元素（可选操作）请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>删除满足给定谓词的此集合的所有元素。（可用lambda表达式）</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>仅保留此集合中包含在指定集合中的元素（可选操作）。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>返回此集合中的元素数。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code>返回以此集合作为源的顺序 <code>Stream</code> 。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>返回一个包含此集合中所有元素的数组。默认为object类型，因此最好用下面的重载形式，免去类型转换</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>返回包含此集合中所有元素的数组;返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h2 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h2><h3 id="1-1Map集合概述和特点【理解】"><a href="#1-1Map集合概述和特点【理解】" class="headerlink" title="1.1Map集合概述和特点【理解】"></a>1.1Map集合概述和特点【理解】</h3><ul>
<li><p>Map集合概述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;  K：键的类型；V：值的类型</span><br></pre></td></tr></table></figure></li>
<li><p>Map集合的特点</p>
<ul>
<li>双列集合,一个键对应一个值</li>
<li>键不可以重复,值可以重复</li>
</ul>
</li>
</ul>
<h3 id="1-2Map集合的基本功能【应用】"><a href="#1-2Map集合的基本功能【应用】" class="headerlink" title="1.2Map集合的基本功能【应用】"></a>1.2Map集合的基本功能【应用】</h3><ul>
<li><p>方法介绍</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V   put(K key,V   value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V   remove(Object key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>void   clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
<tr>
<td>getOrDefault（Object key, 默认值）</td>
<td>获取对应的值，如果不存在则用默认值</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-3Map集合的获取功能【应用】"><a href="#1-3Map集合的获取功能【应用】" class="headerlink" title="1.3Map集合的获取功能【应用】"></a>1.3Map集合的获取功能【应用】</h3><ul>
<li><p>方法介绍</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V   get(Object key)</td>
<td>根据键获取值</td>
</tr>
<tr>
<td>Set<K>   keySet()</td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>Collection<V>   values()</td>
<td>获取所有值的集合</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt;   entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td>replace(Object key,Value a,Value b)</td>
<td>找到key和value为a的键值对，并替换a值为b</td>
</tr>
</tbody></table>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         Map&lt;Integer, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;(Map.of(<span class="number">1</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">2</span>, <span class="string">&quot;value2&quot;</span>, <span class="number">3</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">        map1.replace(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map1.replace(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        map1.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4Map集合的遍历-方式1-【应用】"><a href="#1-4Map集合的遍历-方式1-【应用】" class="headerlink" title="1.4Map集合的遍历(方式1)【应用】"></a>1.4Map集合的遍历(方式1)【应用】</h3><ul>
<li><p>遍历思路</p>
<ul>
<li>我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合<ul>
<li>把所有的丈夫给集中起来</li>
<li>遍历丈夫的集合，获取到每一个丈夫</li>
<li>根据丈夫去找对应的妻子</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤分析</p>
<ul>
<li>获取所有键的集合。用keySet()方法实现</li>
<li>遍历键的集合，获取到每一个键。用增强for实现  </li>
<li>根据键去找值。用get(Object key)方法实现</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有键的集合。用keySet()方法实现</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        <span class="comment">//遍历键的集合，获取到每一个键。用增强for实现</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="comment">//根据键去找值。用get(Object key)方法实现</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5Map集合的遍历-方式2-【应用】"><a href="#1-5Map集合的遍历-方式2-【应用】" class="headerlink" title="1.5Map集合的遍历(方式2)【应用】"></a>1.5Map集合的遍历(方式2)【应用】</h3><ul>
<li><p>遍历思路</p>
<ul>
<li>我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合<ul>
<li>获取所有结婚证的集合</li>
<li>遍历结婚证的集合，得到每一个结婚证</li>
<li>根据结婚证获取丈夫和妻子</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤分析</p>
<ul>
<li>获取所有键值对对象的集合<ul>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合</li>
</ul>
</li>
<li>遍历键值对对象的集合，得到每一个键值对对象<ul>
<li>用增强for实现，得到每一个Map.Entry</li>
</ul>
</li>
<li>根据键值对对象获取键和值<ul>
<li>用getKey()得到键</li>
<li>用getValue()得到值</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有键值对对象的集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="comment">//遍历键值对对象的集合，得到每一个键值对对象</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; me : entrySet) &#123;</span><br><span class="line">            <span class="comment">//根据键值对对象获取键和值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> me.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> me.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-6用forEach遍历"><a href="#1-6用forEach遍历" class="headerlink" title="1.6用forEach遍历"></a>1.6用forEach遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map1.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;&quot;</span>+v));</span><br></pre></td></tr></table></figure>



<h3 id="2-1HashMap集合概述和特点【理解】"><a href="#2-1HashMap集合概述和特点【理解】" class="headerlink" title="2.1HashMap集合概述和特点【理解】"></a>2.1HashMap集合概述和特点【理解】</h3><ul>
<li>HashMap底层是哈希表结构的</li>
<li>依赖hashCode方法和equals方法保证键的唯一</li>
<li>如果键要存储的是自定义对象，需要重写hashCode和equals方法</li>
</ul>
<h3 id="2-2HashMap集合应用案例【应用】"><a href="#2-2HashMap集合应用案例【应用】" class="headerlink" title="2.2HashMap集合应用案例【应用】"></a>2.2HashMap集合应用案例【应用】</h3><ul>
<li><p>案例需求</p>
<ul>
<li>创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。</li>
<li>要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象</li>
</ul>
</li>
<li><p>代码实现</p>
<p>学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(student.name) : student.name == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建HashMap集合对象</span></span><br><span class="line">        HashMap&lt;Student, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">35</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王祖贤&quot;</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王祖贤&quot;</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把学生添加到集合</span></span><br><span class="line">        hm.put(s1, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        hm.put(s2, <span class="string">&quot;武汉&quot;</span>);</span><br><span class="line">        hm.put(s3, <span class="string">&quot;郑州&quot;</span>);</span><br><span class="line">        hm.put(s4, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        Set&lt;Student&gt; keySet = hm.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Student key : keySet) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">            System.out.println(key.getName() + <span class="string">&quot;,&quot;</span> + key.getAge() + <span class="string">&quot;,&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-1TreeMap集合概述和特点【理解】"><a href="#3-1TreeMap集合概述和特点【理解】" class="headerlink" title="3.1TreeMap集合概述和特点【理解】"></a>3.1TreeMap集合概述和特点【理解】</h3><ul>
<li>TreeMap底层是红黑树结构</li>
<li>依赖自然排序或者比较器排序,对键进行排序</li>
<li>如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则</li>
</ul>
<h3 id="3-2TreeMap集合应用案例一【应用】"><a href="#3-2TreeMap集合应用案例一【应用】" class="headerlink" title="3.2TreeMap集合应用案例一【应用】"></a>3.2TreeMap集合应用案例一【应用】</h3><ul>
<li><p>案例需求</p>
<ul>
<li>创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历</li>
<li>要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序</li>
</ul>
</li>
<li><p>代码实现</p>
<p>学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//按照年龄进行排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o.getAge() - <span class="built_in">this</span>.getAge();</span><br><span class="line">        <span class="comment">//次要条件，按照姓名排序。</span></span><br><span class="line">        result = result == <span class="number">0</span> ? o.getName().compareTo(<span class="built_in">this</span>.getName()) : result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建TreeMap集合对象</span></span><br><span class="line">        TreeMap&lt;Student,String&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaohei&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;dapang&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaomei&quot;</span>,<span class="number">22</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 将学生对象添加到TreeMap集合中</span></span><br><span class="line">        tm.put(s1,<span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        tm.put(s2,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        tm.put(s3,<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 遍历TreeMap集合,打印每个学生的信息</span></span><br><span class="line">        tm.forEach(</span><br><span class="line">                (Student key, String value)-&gt;&#123;</span><br><span class="line">                    System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3TreeMap集合应用案例二【应用】"><a href="#3-3TreeMap集合应用案例二【应用】" class="headerlink" title="3.3TreeMap集合应用案例二【应用】"></a>3.3TreeMap集合应用案例二【应用】</h3><ul>
<li><p>案例需求</p>
<ul>
<li>给定一个字符串,要求统计字符串中每个字符出现的次数。</li>
<li>举例: 给定字符串是“aababcabcdabcde”,在控制台输出: “a(5)b(4)c(3)d(2)e(1)”</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 给定字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;aababcabcdabcde&quot;</span>;</span><br><span class="line">		<span class="comment">// 创建TreeMap集合对象,键是Character,值是Integer</span></span><br><span class="line">        TreeMap&lt;Character,Integer&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//c依次表示字符串中的每一个字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">          	<span class="comment">// 判断当前遍历到的字符是否在集合中出现过</span></span><br><span class="line">            <span class="keyword">if</span>(!tm.containsKey(c))&#123;</span><br><span class="line">                <span class="comment">//表示当前字符是第一次出现。</span></span><br><span class="line">                tm.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//存在，表示当前字符已经出现过了</span></span><br><span class="line">                <span class="comment">//先获取这个字符已经出现的次数</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> tm.get(c);</span><br><span class="line">                <span class="comment">//自增，表示这个字符又出现了依次</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//将自增后的结果再次添加到集合中。</span></span><br><span class="line">                tm.put(c,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  a（5）b（4）c（3）d（2）e（1）</span></span><br><span class="line">        <span class="comment">//System.out.println(tm);</span></span><br><span class="line">        tm.forEach(</span><br><span class="line">                (Character key,Integer value)-&gt;&#123;</span><br><span class="line">                    System.out.print(key + <span class="string">&quot;（&quot;</span> + value + <span class="string">&quot;）&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十三、函数式编程"><a href="#十三、函数式编程" class="headerlink" title="十三、函数式编程"></a>十三、函数式编程</h1><blockquote>
<p>函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。</p>
</blockquote>
<p>这就是<strong>函数式编程</strong>（FP）的意义所在。通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。至少在某些情况下，这套理论似乎很有用。在这一过程中，一些非函数式语言已经习惯了使用函数式编程产生的优雅的语法。</p>
<p>你也可以这样想：</p>
<p>OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。</p>
<p>纯粹的函数式语言在安全性方面更进一步。它强加了额外的约束，即所有数据必须是不可变的：设置一次，永不改变。将值传递给函数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。当强制执行此操作时，你知道任何错误都不是由所谓的副作用引起的，因为该函数仅创建并返回结果，而不是其他任何错误。</p>
<p>更好的是，“不可变对象和无副作用”范式解决了并发编程中最基本和最棘手的问题之一（当程序的某些部分同时在多个处理器上运行时）。这是可变共享状态的问题，这意味着代码的不同部分（在不同的处理器上运行）可以尝试同时修改同一块内存（谁赢了？没人知道）。如果函数永远不会修改现有值但只生成新值，则不会对内存产生争用，这是纯函数式语言的定义。 因此，经常提出纯函数式语言作为并行编程的解决方案（还有其他可行的解决方案）。</p>
<p>FP 思想值得融入非 FP 语言，如 Python。Java 8 也从中吸收并支持了 FP。我们将在此章探讨。</p>
<h2 id="新旧对比"><a href="#新旧对比" class="headerlink" title="新旧对比"></a>新旧对比</h2><p>通常，传递给方法的数据不同，结果不同。如果我们希望方法在调用时行为不同，该怎么做呢？结论是：只要能将代码传递给方法，我们就可以控制它的行为。此前，我们通过在方法中创建包含所需行为的对象，然后将该对象传递给我们想要控制的方法来完成此操作。下面我们用传统形式和 Java 8 的方法引用、Lambda 表达式分别演示。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/Strategize.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  String <span class="title function_">approach</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soft</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">approach</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toLowerCase() + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unrelated</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> String <span class="title function_">twice</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg + <span class="string">&quot; &quot;</span> + msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Strategize</span> &#123;</span><br><span class="line">  Strategy strategy;</span><br><span class="line">  String msg;</span><br><span class="line">  Strategize(String msg) &#123;</span><br><span class="line">    strategy = <span class="keyword">new</span> <span class="title class_">Soft</span>(); <span class="comment">// [1]在 Strategize 中，Soft作为默认策略，在构造函数中赋值。</span></span><br><span class="line">    <span class="built_in">this</span>.msg = msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">communicate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(strategy.approach(msg));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">changeStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Strategy[] strategies = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Strategy</span>() &#123; <span class="comment">// [2]一种略显简短且更自发的方法是创建一个**匿名内部类**。即使这样，仍有相当数量的冗余代码。你总是要仔细观察：“哦，原来这样，这里使用了匿名内部类。”</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">approach</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> msg.toUpperCase() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      msg -&gt; msg.substring(<span class="number">0</span>, <span class="number">5</span>), <span class="comment">// [3]Java 8 的 Lambda 表达式。由箭头 -&gt; 分隔开参数和函数体，箭头左边是参数，箭头右侧是从 Lambda 返回的表达式，即函数体。这实现了与定义类、匿名内部类相同的效果，但代码少得多。</span></span><br><span class="line">      Unrelated::twice <span class="comment">// [4]Java 8 的方法引用，由 :: 区分。在 :: 的左边是类或对象的名称，在 :: 的右边是方法的名称，但没有参数列表。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Strategize</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Strategize</span>(<span class="string">&quot;Hello there&quot;</span>);</span><br><span class="line">    s.communicate();</span><br><span class="line">    <span class="keyword">for</span>(Strategy newStrategy : strategies) &#123;</span><br><span class="line">      s.changeStrategy(newStrategy); <span class="comment">// [5]在使用默认的 Soft strategy 之后，我们逐步遍历数组中的所有 Strategy，并使用 changeStrategy() 方法将每个Strategy放入 变量 s 中。</span></span><br><span class="line">      s.communicate(); <span class="comment">// [6]现在，每次调用 communicate() 都会产生不同的行为，具体取决于此刻正在使用的策略代码对象。我们传递的是行为，而非仅数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello there?</span><br><span class="line">HELLO THERE!</span><br><span class="line">Hello</span><br><span class="line">Hello there Hello there</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p>
<ol>
<li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li>
<li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li>
</ol>
<p>任何 Lambda 表达式的基本语法是：</p>
<ol>
<li><p>参数。</p>
</li>
<li><p>接着 <code>-&gt;</code>，可视为“产出”。</p>
</li>
<li><p><code>-&gt;</code> 之后的内容都是方法体。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/LambdaExpressions.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Description</span> &#123;</span><br><span class="line">  String <span class="title function_">brief</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Body</span> &#123;</span><br><span class="line">  String <span class="title function_">detailed</span><span class="params">(String head)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Multi</span> &#123;</span><br><span class="line">  String <span class="title function_">twoArg</span><span class="params">(String head, Double d)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExpressions</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Body</span> <span class="variable">bod</span> <span class="operator">=</span> h -&gt; h + <span class="string">&quot; No Parens!&quot;</span>; <span class="comment">// [1]当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Body</span> <span class="variable">bod2</span> <span class="operator">=</span> (h) -&gt; h + <span class="string">&quot; More details&quot;</span>; <span class="comment">// [2]正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Description</span> <span class="variable">desc</span> <span class="operator">=</span> () -&gt; <span class="string">&quot;Short info&quot;</span>; <span class="comment">// [3] 如果没有参数，则必须使用括号()表示空参数列表。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Multi</span> <span class="variable">mult</span> <span class="operator">=</span> (h, n) -&gt; h + n; <span class="comment">// [4]对于多个参数，将参数列表放在括号 () 中。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Description</span> <span class="variable">moreLines</span> <span class="operator">=</span> () -&gt; &#123; <span class="comment">// [5]多行，则必须将这些行放在花括号中。需要使用return。单行的话省略return</span></span><br><span class="line">    System.out.println(<span class="string">&quot;moreLines()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from moreLines()&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(bod.detailed(<span class="string">&quot;Oh!&quot;</span>));</span><br><span class="line">    System.out.println(bod2.detailed(<span class="string">&quot;Hi!&quot;</span>));</span><br><span class="line">    System.out.println(desc.brief());</span><br><span class="line">    System.out.println(mult.twoArg(<span class="string">&quot;Pi! &quot;</span>, <span class="number">3.14159</span>));</span><br><span class="line">    System.out.println(moreLines.brief());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oh! No Parens!</span><br><span class="line">Hi! More details</span><br><span class="line">Short info</span><br><span class="line">Pi! 3.14159</span><br><span class="line">moreLines()</span><br><span class="line">from moreLines()</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>编写递归的 Lambda 表达式，需要注意：递归方法必须是实例变量或静态变量，否则会出现编译时错误。 我们将为每个案例创建一个示例。</p>
<p>这两个示例都需要一个接受 <strong>int</strong> 型参数并生成 <strong>int</strong> 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/IntCall.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IntCall</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">call</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/RecursiveFactorial.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursiveFactorial</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> IntCall fact;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    fact = n -&gt; n == <span class="number">0</span> ? <span class="number">1</span> : n * fact.call(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">      System.out.println(fact.call(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里，<code>fact</code> 是一个静态变量。 注意使用三元 <strong>if-else</strong>。 递归函数将一直调用自己，直到 <code>i == 0</code>。所有递归函数都有“停止条件”，否则将无限递归并产生异常。</p>
<p>我们可以将 <code>Fibonacci</code> 序列改为使用递归 Lambda 表达式来实现，这次使用实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/RecursiveFibonacci.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursiveFibonacci</span> &#123;</span><br><span class="line">  IntCall fib;</span><br><span class="line"></span><br><span class="line">  RecursiveFibonacci() &#123;</span><br><span class="line">    fib = n -&gt; n == <span class="number">0</span> ? <span class="number">0</span> :</span><br><span class="line">               n == <span class="number">1</span> ? <span class="number">1</span> :</span><br><span class="line">               fib.call(n - <span class="number">1</span>) + fib.call(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="keyword">return</span> fib.call(n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RecursiveFibonacci</span> <span class="variable">rf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecursiveFibonacci</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">      System.out.println(rf.fibonacci(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 <code>::</code> ，然后跟方法名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/MethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callable</span> &#123; <span class="comment">// [1]</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Describe</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String msg)</span> &#123; <span class="comment">// [2]show() 的签名（参数类型和返回类型）符合 Callable的 call() 的签名。</span></span><br><span class="line">    System.out.println(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReferences</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span> &#123; <span class="comment">// [3]hello() 也符合 call() 的签名。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Description</span> &#123;</span><br><span class="line">    String about;</span><br><span class="line">    Description(String desc) &#123; about = desc; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">help</span><span class="params">(String msg)</span> &#123; <span class="comment">// [4]help()也符合，它是静态内部类中的非静态方法。</span></span><br><span class="line">      System.out.println(about + <span class="string">&quot; &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Helper</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assist</span><span class="params">(String msg)</span> &#123; <span class="comment">// [5]assist()是静态内部类中的静态方法。</span></span><br><span class="line">      System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Describe</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Describe</span>();</span><br><span class="line">    <span class="type">Callable</span> <span class="variable">c</span> <span class="operator">=</span> d::show; <span class="comment">// [6]我们将 Describe 对象的方法引用赋值给 Callable ，它没有 show()`方法，而是 call() 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 Callable 的 call() 方法的签名。</span></span><br><span class="line">    c.call(<span class="string">&quot;call()&quot;</span>); <span class="comment">// [7]我们现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show()。</span></span><br><span class="line"></span><br><span class="line">    c = MethodReferences::hello; <span class="comment">// [8]这是一个静态方法引用</span></span><br><span class="line">    c.call(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    c = <span class="keyword">new</span> <span class="title class_">Description</span>(<span class="string">&quot;valuable&quot;</span>)::help; <span class="comment">// [9]这是 [6]的另一个版本：对已实例化对象的方法的引用，有时称为绑定方法引用。</span></span><br><span class="line">    c.call(<span class="string">&quot;information&quot;</span>);</span><br><span class="line"></span><br><span class="line">    c = Helper::assist; <span class="comment">// [10]最后，获取静态内部类的方法引用的操作与 [8]中外部类方式一样。</span></span><br><span class="line">    c.call(<span class="string">&quot;Help!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call()</span><br><span class="line">Hello, Bob</span><br><span class="line">valuable information</span><br><span class="line">Help!</span><br></pre></td></tr></table></figure>

<h3 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h3><p><strong>Runnable</strong> 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 <code>run()</code> 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/RunnableMethodReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用与 Runnable 接口的结合使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Go</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Go::go()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableMethodReference</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Anonymous&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">      () -&gt; System.out.println(<span class="string">&quot;lambda&quot;</span>)</span><br><span class="line">    ).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(Go::go).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Anonymous</span><br><span class="line">lambda</span><br><span class="line">Go::go()</span><br></pre></td></tr></table></figure>

<p><strong>Thread</strong> 对象将 <strong>Runnable</strong> 作为其构造函数参数，并具有会调用 <code>run()</code> 的方法 <code>start()</code>。 <strong>注意</strong>，只有<strong>匿名内部类</strong>才需要具有名为 <code>run()</code> 的方法。</p>
<h3 id="未绑定的方法引用"><a href="#未绑定的方法引用" class="headerlink" title="未绑定的方法引用"></a>未绑定的方法引用</h3><p>未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/UnboundMethodReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有方法引用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  String <span class="title function_">f</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;X::f()&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MakeString</span> &#123;</span><br><span class="line">  String <span class="title function_">make</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TransformX</span> &#123;</span><br><span class="line">  String <span class="title function_">transform</span><span class="params">(X x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnboundMethodReference</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// MakeString ms = X::f; // [1]</span></span><br><span class="line">    <span class="type">TransformX</span> <span class="variable">sp</span> <span class="operator">=</span> X::f;</span><br><span class="line">    <span class="type">X</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line">    System.out.println(sp.transform(x)); <span class="comment">// [2]</span></span><br><span class="line">    System.out.println(x.f()); <span class="comment">// 同等效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X::f()</span><br><span class="line">X::f()</span><br></pre></td></tr></table></figure>

<p>截止目前，我们已经知道了与接口方法同名的方法引用。 在 **[1]**，我们尝试把 <code>X</code> 的 <code>f()</code> 方法引用赋值给 <strong>MakeString</strong>。结果：即使 <code>make()</code> 与 <code>f()</code> 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 <code>this</code>。 你不能在没有 <code>X</code> 对象的前提下调用 <code>f()</code>。 因此，<code>X :: f</code> 表示未绑定的方法引用，因为它尚未“绑定”到对象。</p>
<p>要解决这个问题，我们需要一个 <code>X</code> 对象，所以我们的接口实际上需要一个额外的参数的接口，如上例中的 <strong>TransformX</strong>。 如果将 <code>X :: f</code> 赋值给 <strong>TransformX</strong>，这在 Java 中是允许的。这次我们需要调整下心里预期——使用未绑定的引用时，函数方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 理由是：你需要一个对象来调用方法。</p>
<p><strong>[2]</strong> 的结果有点像脑筋急转弯。 我接受未绑定的引用并对其调用 <code>transform()</code>，将其传递给 <code>X</code>，并以某种方式导致对 <code>x.f()</code> 的调用。 Java 知道它必须采用第一个参数，这实际上就是 <code>this</code>，并在其上调用方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/MultiUnbound.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未绑定的方法与多参数的结合运用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">This</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">two</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> d)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">three</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> d, String s)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">four</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> d, String s, <span class="type">char</span> c)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TwoArgs</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">call2</span><span class="params">(This athis, <span class="type">int</span> i, <span class="type">double</span> d)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThreeArgs</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">call3</span><span class="params">(This athis, <span class="type">int</span> i, <span class="type">double</span> d, String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FourArgs</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">call4</span><span class="params">(</span></span><br><span class="line"><span class="params">    This athis, <span class="type">int</span> i, <span class="type">double</span> d, String s, <span class="type">char</span> c)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiUnbound</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">TwoArgs</span> <span class="variable">twoargs</span> <span class="operator">=</span> This::two;</span><br><span class="line">    <span class="type">ThreeArgs</span> <span class="variable">threeargs</span> <span class="operator">=</span> This::three;</span><br><span class="line">    <span class="type">FourArgs</span> <span class="variable">fourargs</span> <span class="operator">=</span> This::four;</span><br><span class="line">    <span class="type">This</span> <span class="variable">athis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">This</span>();</span><br><span class="line">    twoargs.call2(athis, <span class="number">11</span>, <span class="number">3.14</span>);</span><br><span class="line">    threeargs.call3(athis, <span class="number">11</span>, <span class="number">3.14</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">    fourargs.call4(athis, <span class="number">11</span>, <span class="number">3.14</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了说明这一点，我将类命名为 <strong>This</strong> ，函数方法的第一个参数则是 <strong>athis</strong>，但是你应该选择其他名称以防止生产代码混淆。</p>
<h3 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h3><p>你还可以捕获构造函数的引用，然后通过引用调用该构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functional/CtorReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// For &quot;unknown&quot;</span></span><br><span class="line">  Dog() &#123; name = <span class="string">&quot;stray&quot;</span>; &#125;</span><br><span class="line">  Dog(String nm) &#123; name = nm; &#125;</span><br><span class="line">  Dog(String nm, <span class="type">int</span> yrs) &#123; name = nm; age = yrs; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MakeNoArgs</span> &#123;</span><br><span class="line">  Dog <span class="title function_">make</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Make1Arg</span> &#123;</span><br><span class="line">  Dog <span class="title function_">make</span><span class="params">(String nm)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Make2Args</span> &#123;</span><br><span class="line">  Dog <span class="title function_">make</span><span class="params">(String nm, <span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CtorReference</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MakeNoArgs</span> <span class="variable">mna</span> <span class="operator">=</span> Dog::<span class="keyword">new</span>; <span class="comment">// [1]</span></span><br><span class="line">    <span class="type">Make1Arg</span> <span class="variable">m1a</span> <span class="operator">=</span> Dog::<span class="keyword">new</span>;   <span class="comment">// [2]</span></span><br><span class="line">    <span class="type">Make2Args</span> <span class="variable">m2a</span> <span class="operator">=</span> Dog::<span class="keyword">new</span>;  <span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dn</span> <span class="operator">=</span> mna.make();</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> m1a.make(<span class="string">&quot;Comet&quot;</span>);</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> m2a.make(<span class="string">&quot;Ralph&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Dog</strong> 有三个构造函数，函数接口内的 <code>make()</code> 方法反映了构造函数参数列表（ <code>make()</code> 方法名称可以不同）。</p>
<p><strong>注意</strong>我们如何对 <strong>[1]<strong>，</strong>[2]</strong> 和 <strong>[3]</strong> 中的每一个使用 <code>Dog :: new</code>。 这 3 个构造函数只有一个相同名称：<code>:: new</code>，但在每种情况下都赋值给不同的接口。编译器可以检测并知道从哪个构造函数引用。</p>
<p>编译器能识别并调用你的构造函数（ 在本例中为 <code>make()</code>）。</p>
<p>#十四、流式编程</p>
<p>流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。</p>
<p>利用流，我们无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道。</p>
<p>在大多数情况下，将对象存储在集合中是为了处理他们，因此你将会发现你将把编程的主要焦点从集合转移到了流上。流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更具吸引力。</p>
<p>举个例子，假如你要随机展示 5 至 20 之间不重复的整数并进行排序。实际上，你的关注点首先是创建一个有序集合。围绕这个集合进行后续的操作。但是使用流式编程，你就可以简单陈述你想做什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Randoms.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Randoms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>)</span><br><span class="line">            .ints(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">            .distinct()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先，我们给 <strong>Random</strong> 对象一个种子（以便程序再次运行时产生相同的输出）。<code>ints()</code> 方法产生一个流并且 <code>ints()</code> 方法有多种方式的重载 — 两个参数限定了数值产生的边界。这将生成一个整数流。我们可以使用中间流操作（intermediate stream operation） <code>distinct()</code> 来获取它们的非重复值，然后使用 <code>limit()</code> 方法获取前 7 个元素。接下来，我们使用 <code>sorted()</code> 方法排序。最终使用 <code>forEach()</code> 方法遍历输出，它根据传递给它的函数对每个流对象执行操作。在这里，我们传递了一个可以在控制台显示每个元素的方法引用。<code>System.out::println</code> 。</p>
<p>注意 <code>Randoms.java</code> 中没有声明任何变量。流流可以在不使用赋值或可变数据的情况下对有状态的系统建模，这非常有用。</p>
<p>声明式编程（Declarative programming）是一种：声明要做什么，而非怎么做的编程风格。正如我们在函数式编程中所看到的。<strong>注意</strong>，命令式编程的形式更难以理解。</p>
<p><code>Randoms.java</code> 中，流式编程采用内部迭代，这是流式编程的核心特性之一。这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。通过放弃对迭代过程的控制，我们把控制权交给并行化机制。我们将在<a href="24-Concurrent-Programming.md">并发编程</a>一章中学习这部分内容。</p>
<p>另一个重要方面，流是懒加载的。这代表着它只在绝对必要时才计算。你可以将流看作“延迟列表”。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。</p>
<h2 id="流支持"><a href="#流支持" class="headerlink" title="流支持"></a>流支持</h2><p>Java 设计者面临着这样一个难题：现存的大量类库不仅为 Java 所用，同时也被应用在整个 Java 生态圈数百万行的代码中。如何将一个全新的流的概念融入到现有类库中呢？</p>
<p>比如在 <strong>Random</strong> 中添加更多的方法。只要不改变原有的方法，现有代码就不会受到干扰。</p>
<p>问题是，接口部分怎么改造呢？特别是涉及集合类接口的部分。如果你想把一个集合转换为流，直接向接口添加新方法会破坏所有老的接口实现类。</p>
<p>Java 8 采用的解决方案是：在<a href="10-Interfaces.md">接口</a>中添加被 <code>default</code>（<code>默认</code>）修饰的方法。通过这种方案，设计者们可以将流式（_stream_）方法平滑地嵌入到现有类中。流方法预置的操作几乎已满足了我们平常所有的需求。流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。</p>
<p>下面我们来看下每种类型的流操作。</p>
<p>##流创建</p>
<p>你可以通过 <code>Stream.of()</code> 很容易地将一组元素转化成为流（<code>Bubble</code> 类在本章的后面定义）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOf.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamOf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="keyword">new</span> <span class="title class_">Bubble</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Bubble</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Bubble</span>(<span class="number">3</span>))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">        Stream.of(<span class="string">&quot;It&#x27;s &quot;</span>, <span class="string">&quot;a &quot;</span>, <span class="string">&quot;wonderful &quot;</span>, <span class="string">&quot;day &quot;</span>, <span class="string">&quot;for &quot;</span>, <span class="string">&quot;pie!&quot;</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Stream.of(<span class="number">3.14159</span>, <span class="number">2.718</span>, <span class="number">1.618</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>除此之外，每个集合都可以通过调用 <code>stream()</code> 方法来产生一个流。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/CollectionToStream.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionToStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Bubble&gt; bubbles = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Bubble</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Bubble</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Bubble</span>(<span class="number">3</span>));</span><br><span class="line">        System.out.println(bubbles.stream()</span><br><span class="line">            .mapToInt(b -&gt; b.i)</span><br><span class="line">            .sum());</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; w = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;It&#x27;s a wonderful day for pie!&quot;</span>.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">        w.stream()</span><br><span class="line">         .map(x -&gt; x + <span class="string">&quot; &quot;</span>)</span><br><span class="line">         .forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Double&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        m.put(<span class="string">&quot;pi&quot;</span>, <span class="number">3.14159</span>);</span><br><span class="line">        m.put(<span class="string">&quot;e&quot;</span>, <span class="number">2.718</span>);</span><br><span class="line">        m.put(<span class="string">&quot;phi&quot;</span>, <span class="number">1.618</span>);</span><br><span class="line">        m.entrySet().stream()</span><br><span class="line">                    .map(e -&gt; e.getKey() + <span class="string">&quot;: &quot;</span> + e.getValue())</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">a pie! It&#x27;s for wonderful day</span><br><span class="line">phi: 1.618</span><br><span class="line">e: 2.718</span><br><span class="line">pi: 3.14159</span><br></pre></td></tr></table></figure>

<p>在创建 <code>List&lt;Bubble&gt;</code> 对象之后，我们只需要简单地调用所有集合中都有的 <code>stream()</code>。中间操作 <code>map()</code> 会获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。通常 <code>map()</code> 会获取对象并产生新的对象，但在这里产生了特殊的用于数值类型的流。例如，<code>mapToInt()</code> 方法将一个对象流（object stream）转换成为包含整型数字的 <code>IntStream</code>。同样，针对 <code>Float</code> 和 <code>Double</code> 也有类似名字的操作。</p>
<p>我们通过调用字符串的 <code>split()</code>（该方法会根据参数来拆分字符串）来获取元素用于定义变量 <code>w</code>。稍后你会知道 <code>split()</code> 参数可以是十分复杂，但在这里我们只是根据空格来分割字符串。</p>
<p>为了从 <strong>Map</strong> 集合中产生流数据，我们首先调用 <code>entrySet()</code> 产生一个对象流，每个对象都包含一个 <code>key</code> 键以及与其相关联的 <code>value</code> 值。然后分别调用 <code>getKey()</code> 和 <code>getValue()</code> 获取值。</p>
<h3 id="随机数流"><a href="#随机数流" class="headerlink" title="随机数流"></a>随机数流</h3><p><code>Random</code> 类被一组生成流的方法增强了。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/RandomGenerators.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomGenerators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Stream&lt;T&gt; stream)</span> &#123;</span><br><span class="line">        stream</span><br><span class="line">        .limit(<span class="number">4</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">        show(rand.ints().boxed());</span><br><span class="line">        show(rand.longs().boxed());</span><br><span class="line">        show(rand.doubles().boxed());</span><br><span class="line">        <span class="comment">// 控制上限和下限：</span></span><br><span class="line">        show(rand.ints(<span class="number">10</span>, <span class="number">20</span>).boxed());</span><br><span class="line">        show(rand.longs(<span class="number">50</span>, <span class="number">100</span>).boxed());</span><br><span class="line">        show(rand.doubles(<span class="number">20</span>, <span class="number">30</span>).boxed());</span><br><span class="line">        <span class="comment">// 控制流大小：</span></span><br><span class="line">        show(rand.ints(<span class="number">2</span>).boxed());</span><br><span class="line">        show(rand.longs(<span class="number">2</span>).boxed());</span><br><span class="line">        show(rand.doubles(<span class="number">2</span>).boxed());</span><br><span class="line">        <span class="comment">// 控制流的大小和界限</span></span><br><span class="line">        show(rand.ints(<span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>).boxed());</span><br><span class="line">        show(rand.longs(<span class="number">3</span>, <span class="number">12</span>, <span class="number">22</span>).boxed());</span><br><span class="line">        show(rand.doubles(<span class="number">3</span>, <span class="number">11.5</span>, <span class="number">12.3</span>).boxed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1172028779</span><br><span class="line">1717241110</span><br><span class="line">-2014573909</span><br><span class="line">229403722</span><br><span class="line">++++++++</span><br><span class="line">2955289354441303771</span><br><span class="line">3476817843704654257</span><br><span class="line">-8917117694134521474</span><br><span class="line">4941259272818818752</span><br><span class="line">++++++++</span><br><span class="line">0.2613610344283964</span><br><span class="line">0.0508673570556899</span><br><span class="line">0.8037155449603999</span><br><span class="line">0.7620665811558285</span><br><span class="line">++++++++</span><br><span class="line">16</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">++++++++</span><br><span class="line">65</span><br><span class="line">99</span><br><span class="line">54</span><br><span class="line">58</span><br><span class="line">++++++++</span><br><span class="line">29.86777681078574</span><br><span class="line">24.83968447804611</span><br><span class="line">20.09247112332014</span><br><span class="line">24.046793846338723</span><br><span class="line">++++++++</span><br><span class="line">1169976606</span><br><span class="line">1947946283</span><br><span class="line">++++++++</span><br><span class="line">2970202997824602425</span><br><span class="line">-2325326920272830366</span><br><span class="line">++++++++</span><br><span class="line">0.7024254510631527</span><br><span class="line">0.6648552384607359</span><br><span class="line">++++++++</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">++++++++</span><br><span class="line">17</span><br><span class="line">12</span><br><span class="line">20</span><br><span class="line">++++++++</span><br><span class="line">12.27872414236691</span><br><span class="line">11.732085449736195</span><br><span class="line">12.196509449817267</span><br><span class="line">++++++++</span><br></pre></td></tr></table></figure>

<p>为了消除冗余代码，我创建了一个泛型方法 <code>show(Stream&lt;T&gt; stream)</code> （在讲解泛型之前就使用这个特性，确实有点作弊，但是回报是值得的）。类型参数 <code>T</code> 可以是任何类型，所以这个方法对 <strong>Integer</strong>、<strong>Long</strong> 和 <strong>Double</strong> 类型都生效。但是 <strong>Random</strong> 类只能生成基本类型 <strong>int</strong>， <strong>long</strong>， <strong>double</strong> 的流。幸运的是， <code>boxed()</code> 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 <code>show()</code> 能够接受流。</p>
<p>我们可以使用 <strong>Random</strong> 为任意对象集合创建 <strong>Supplier</strong>。如下是一个文本文件提供字符串对象的例子。</p>
<p>Cheese.dat 文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// streams/Cheese.dat</span><br><span class="line">Not much of a cheese shop really, is it?</span><br><span class="line">Finest in the district, sir.</span><br><span class="line">And what leads you to that conclusion?</span><br><span class="line">Well, it&#x27;s so clean.</span><br><span class="line">It&#x27;s certainly uncontaminated by cheese.</span><br></pre></td></tr></table></figure>

<p>我们通过 <strong>File</strong> 类将 Cheese.dat 文件的所有行读取到 <code>List&lt;String&gt;</code> 中。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/RandomWords.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomWords</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;String&gt; &#123;</span><br><span class="line">    List&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    RandomWords(String fname) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname));</span><br><span class="line">        <span class="comment">// 略过第一行</span></span><br><span class="line">        <span class="keyword">for</span> (String line : lines.subList(<span class="number">1</span>, lines.size())) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : line.split(<span class="string">&quot;[ .?,]+&quot;</span>))</span><br><span class="line">                words.add(word.toLowerCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.get(rand.nextInt(words.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words.stream()</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            Stream.generate(<span class="keyword">new</span> <span class="title class_">RandomWords</span>(<span class="string">&quot;Cheese.dat&quot;</span>))</span><br><span class="line">                .limit(<span class="number">10</span>)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it shop sir the much cheese by conclusion district is</span><br></pre></td></tr></table></figure>

<p>在这里你可以看到更为复杂的 <code>split()</code> 运用。在构造器中，每一行都被 <code>split()</code> 通过空格或者被方括号包裹的任意标点符号进行分割。在结束方括号后面的 <code>+</code> 代表 <code>+</code> 前面的东西可以出现一次或者多次。</p>
<p>我们注意到在构造函数中循环体使用命令式编程（外部迭代）。在以后的例子中，你甚至会看到我们如何消除这一点。这种旧的形式虽不是特别糟糕，但使用流会让人感觉更好。</p>
<p>在 <code>toString()</code> 和主方法中你看到了 <code>collect()</code> 收集操作，它根据参数来组合所有流中的元素。</p>
<p>当你使用 <strong>Collectors.</strong><code>joining()</code>，你将会得到一个 <code>String</code> 类型的结果，每个元素都根据 <code>joining()</code> 的参数来进行分割。还有许多不同的 <code>Collectors</code> 用于产生不同的结果。</p>
<p>在主方法中，我们提前看到了 <strong>Stream.</strong><code>generate()</code> 的用法，它可以把任意 <code>Supplier&lt;T&gt;</code> 用于生成 <code>T</code> 类型的流。</p>
<h3 id="int-类型的范围"><a href="#int-类型的范围" class="headerlink" title="int 类型的范围"></a>int 类型的范围</h3><p><code>IntStream</code> 类提供了 <code>range()</code> 方法用于生成整型序列的流。编写循环时，这个方法会更加便利：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Ranges.java</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.IntStream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ranges</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 传统方法:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            result += i;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// for-in 循环:</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : range(<span class="number">10</span>, <span class="number">20</span>).toArray())</span><br><span class="line">            result += i;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// 使用流:</span></span><br><span class="line">        System.out.println(range(<span class="number">10</span>, <span class="number">20</span>).sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">145</span><br><span class="line">145</span><br><span class="line">145</span><br></pre></td></tr></table></figure>

<p>在主方法中的第一种方式是我们传统编写 <code>for</code> 循环的方式；第二种方式，我们使用 <code>range()</code> 创建了流并将其转化为数组，然后在 <code>for-in</code> 代码块中使用。但是，如果你能像第三种方法那样全程使用流是更好的。我们对范围中的数字进行求和。在流中可以很方便的使用 <code>sum()</code> 操作求和。</p>
<p>注意 <strong>IntStream.</strong><code>range()</code> 相比 <code>onjava.Range.range()</code> 拥有更多的限制。这是由于其可选的第三个参数，后者允许步长大于 1，并且可以从大到小来生成。</p>
<p>实用小功能 <code>repeat()</code> 可以用来替换简单的 <code>for</code> 循环。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onjava/Repeat.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.IntStream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Repeat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">int</span> n, Runnable action)</span> &#123;</span><br><span class="line">        range(<span class="number">0</span>, n).forEach(i -&gt; action.run());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其产生的循环更加清晰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Looping.java</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Repeat.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Looping</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        repeat(<span class="number">3</span>, () -&gt; System.out.println(<span class="string">&quot;Looping!&quot;</span>));</span><br><span class="line">        repeat(<span class="number">2</span>, Looping::hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Looping!</span><br><span class="line">Looping!</span><br><span class="line">Looping!</span><br><span class="line">Hi!</span><br><span class="line">Hi!</span><br></pre></td></tr></table></figure>

<p>原则上，在代码中包含并解释 <code>repeat()</code> 并不值得。诚然它是一个相当透明的工具，但结果取决于你的团队和公司的运作方式。</p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate()"></a>generate()</h3><p>参照 <code>RandomWords.java</code> 中 <strong>Stream.</strong><code>generate()</code> 搭配 <code>Supplier&lt;T&gt;</code> 使用的例子。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Generator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generator</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="type">char</span>[] letters = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + letters[rand.nextInt(letters.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> Stream.generate(<span class="keyword">new</span> <span class="title class_">Generator</span>())</span><br><span class="line">                            .limit(<span class="number">30</span>)</span><br><span class="line">                            .collect(Collectors.joining());</span><br><span class="line">        System.out.println(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YNZBRNYGCFOWZNTCQRGSEGZMMJMROE</span><br></pre></td></tr></table></figure>

<p>使用 <code>Random.nextInt()</code> 方法来挑选字母表中的大写字母。<code>Random.nextInt()</code> 的参数代表可以接受的最大的随机数范围，所以使用数组边界是经过深思熟虑的。</p>
<p>如果要创建包含相同对象的流，只需要传递一个生成那些对象的 <code>lambda</code> 到 <code>generate()</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Duplicator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duplicator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.generate(() -&gt; <span class="string">&quot;duplicate&quot;</span>)</span><br><span class="line">              .limit(<span class="number">3</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">duplicate</span><br><span class="line">duplicate</span><br><span class="line">duplicate</span><br></pre></td></tr></table></figure>

<p>如下是在本章之前例子中使用过的 <code>Bubble</code> 类。<strong>注意</strong>它包含了自己的静态生成器（Static generator）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Bubble.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bubble</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        i = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bubble(&quot;</span> + i + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bubble <span class="title function_">bubbler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bubble</span>(count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>bubbler()</code> 与 <code>Supplier&lt;Bubble&gt;</code> 是接口兼容的，我们可以将其方法引用直接传递给 <strong>Stream.</strong><code>generate()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Bubbles.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubbles</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.generate(Bubble::bubbler)</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bubble(0)</span><br><span class="line">Bubble(1)</span><br><span class="line">Bubble(2)</span><br><span class="line">Bubble(3)</span><br><span class="line">Bubble(4)</span><br></pre></td></tr></table></figure>

<p>这是创建单独工厂类（Separate Factory class）的另一种方式。在很多方面它更加整洁，但是这是一个对于代码组织和品味的问题——你总是可以创建一个完全不同的工厂类。</p>
<h3 id="iterate"><a href="#iterate" class="headerlink" title="iterate()"></a>iterate()</h3><p><strong>Stream.</strong><code>iterate()</code> 以种子（第一个参数）开头，并将其传给方法（第二个参数）。方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code>，依次类推。我们可以利用 <code>iterate()</code> 生成一个斐波那契数列。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Fibonacci.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; <span class="title function_">numbers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">0</span>, i -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + i;</span><br><span class="line">            x = i;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Fibonacci</span>().numbers()</span><br><span class="line">                       .skip(<span class="number">20</span>) <span class="comment">// 过滤前 20 个</span></span><br><span class="line">                       .limit(<span class="number">10</span>) <span class="comment">// 然后取 10 个</span></span><br><span class="line">                       .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6765</span><br><span class="line">10946</span><br><span class="line">17711</span><br><span class="line">28657</span><br><span class="line">46368</span><br><span class="line">75025</span><br><span class="line">121393</span><br><span class="line">196418</span><br><span class="line">317811</span><br><span class="line">514229</span><br></pre></td></tr></table></figure>

<p>斐波那契数列将数列中最后两个元素进行求和以产生下一个元素。<code>iterate()</code> 只能记忆结果，因此我们需要利用一个变量 <code>x</code> 追踪另外一个元素。</p>
<p>在主方法中，我们使用了一个之前没有见过的 <code>skip()</code> 操作。它根据参数丢弃指定数量的流元素。在这里，我们丢弃了前 20 个元素。</p>
<h3 id="流的建造者模式"><a href="#流的建造者模式" class="headerlink" title="流的建造者模式"></a>流的建造者模式</h3><p>在建造者设计模式（也称构造器模式）中，首先创建一个 <code>builder</code> 对象，传递给它多个构造器信息，最后执行“构造”。<strong>Stream</strong> 库提供了这样的 <code>Builder</code>。在这里，我们重新审视文件读取并将其转换成为单词流的过程。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FileToWordsBuilder.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileToWordsBuilder</span> &#123;</span><br><span class="line">    Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileToWordsBuilder</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Files.lines(Paths.get(filePath))</span><br><span class="line">             .skip(<span class="number">1</span>) <span class="comment">// 略过开头的注释行</span></span><br><span class="line">             .forEach(line -&gt; &#123;</span><br><span class="line">                  <span class="keyword">for</span> (String w : line.split(<span class="string">&quot;[ .?,]+&quot;</span>))</span><br><span class="line">                      builder.add(w);</span><br><span class="line">              &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stream&lt;String&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileToWordsBuilder</span>(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not much of a cheese shop really</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，构造器会添加文件中的所有单词（除了第一行，它是包含文件路径信息的注释），但是其并没有调用 <code>build()</code>。只要你不调用 <code>stream()</code> 方法，就可以继续向 <code>builder</code> 对象中添加单词。</p>
<p>在该类的更完整形式中，你可以添加一个标志位用于查看 <code>build()</code> 是否被调用，并且可能的话增加一个可以添加更多单词的方法。在 <code>Stream.Builder</code> 调用 <code>build()</code> 方法后继续尝试添加单词会产生一个异常。</p>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p><code>Arrays</code> 类中含有一个名为 <code>stream()</code> 的静态方法用于把数组转换成为流。我们可以重写 <code>interfaces/Machine.java</code> 中的主方法用于创建一个流，并将 <code>execute()</code> 应用于每一个元素。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Machine2.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Operations;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Machine2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="title class_">Operations</span>[] &#123;</span><br><span class="line">            () -&gt; Operations.show(<span class="string">&quot;Bing&quot;</span>),</span><br><span class="line">            () -&gt; Operations.show(<span class="string">&quot;Crack&quot;</span>),</span><br><span class="line">            () -&gt; Operations.show(<span class="string">&quot;Twist&quot;</span>),</span><br><span class="line">            () -&gt; Operations.show(<span class="string">&quot;Pop&quot;</span>)</span><br><span class="line">        &#125;).forEach(Operations::execute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bing</span><br><span class="line">Crack</span><br><span class="line">Twist</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure>

<p><code>new Operations[]</code> 表达式动态创建了 <code>Operations</code> 对象的数组。</p>
<p><code>stream()</code> 同样可以产生 <strong>IntStream</strong>，<strong>LongStream</strong> 和 <strong>DoubleStream</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/ArrayStreams.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStreams</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="title class_">double</span>[] &#123; <span class="number">3.14159</span>, <span class="number">2.718</span>, <span class="number">1.618</span> &#125;)</span><br><span class="line">            .forEach(n -&gt; System.out.format(<span class="string">&quot;%f &quot;</span>, n));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;)</span><br><span class="line">            .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="title class_">long</span>[] &#123; <span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">66</span> &#125;)</span><br><span class="line">            .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择一个子域:</span></span><br><span class="line">        Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">37</span> &#125;, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">            .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.141590 2.718000 1.618000</span><br><span class="line">1 3 5</span><br><span class="line">11 22 44 66</span><br><span class="line">7 15 28</span><br></pre></td></tr></table></figure>

<p>最后一次 <code>stream()</code> 的调用有两个额外的参数。第一个参数告诉 <code>stream()</code> 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止。每种不同类型的 <code>stream()</code> 都有类似的操作。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Java 的正则表达式将在<a href="18-Strings.md">字符串</a>这一章节详细介绍。Java 8 在 <code>java.util.regex.Pattern</code> 中增加了一个新的方法 <code>splitAsStream()</code>。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 <strong>CharSequence</strong>，因此不能将流作为 <code>splitAsStream()</code> 的参数。</p>
<p>我们再一次查看将文件处理为单词流的过程。这一次，我们使用流将文件分割为单独的字符串，接着使用正则表达式将字符串转化为单词流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FileToWordsRegexp.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileToWordsRegexp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String all;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileToWordsRegexp</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        all = Files.lines(Paths.get(filePath))</span><br><span class="line">        .skip(<span class="number">1</span>) <span class="comment">// First (comment) line</span></span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Stream&lt;String&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern</span><br><span class="line">        .compile(<span class="string">&quot;[ .,?]+&quot;</span>).splitAsStream(all);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileToWordsRegexp</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileToWordsRegexp</span>(<span class="string">&quot;Cheese.dat&quot;</span>);</span><br><span class="line">        fw.stream()</span><br><span class="line">          .limit(<span class="number">7</span>)</span><br><span class="line">          .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">          .forEach(System.out::print);</span><br><span class="line">        fw.stream()</span><br><span class="line">          .skip(<span class="number">7</span>)</span><br><span class="line">          .limit(<span class="number">2</span>)</span><br><span class="line">          .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">          .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not much of a cheese shop really is it</span><br></pre></td></tr></table></figure>

<p>在构造器中我们读取了文件中的所有内容（跳过第一行注释，并将其转化成为单行字符串）。现在，当你调用 <code>stream()</code> 的时候，可以像往常一样获取一个流，但这次你可以多次调用 <code>stream()</code> 在已存储的字符串中创建一个新的流。这里有个限制，整个文件必须存储在内存中；在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势：</p>
<ol>
<li>流“不需要存储”。当然它们需要一些内部存储，但是这只是序列的一小部分，和持有整个序列并不相同。</li>
<li>它们是懒加载计算的。</li>
</ol>
<p>幸运的是，我们稍后就会知道如何解决这个问题。</p>
<h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p>
<h3 id="跟踪和调试"><a href="#跟踪和调试" class="headerlink" title="跟踪和调试"></a>跟踪和调试</h3><p><code>peek()</code> 操作的目的是帮助调试。它允许你无修改地查看流中的元素。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Peeking.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Peeking</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FileToWords.stream(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">        .skip(<span class="number">21</span>)</span><br><span class="line">        .limit(<span class="number">4</span>)</span><br><span class="line">        .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .peek(System.out::print)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .peek(System.out::print)</span><br><span class="line">        .map(String::toLowerCase)</span><br><span class="line">        .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Well WELL well it IT it s S s so SO so</span><br></pre></td></tr></table></figure>

<p><code>FileToWords</code> 稍后定义，但它的功能实现貌似和之前我们看到的差不多：产生字符串对象的流。之后在其通过管道时调用 <code>peek()</code> 进行处理。</p>
<p>因为 <code>peek()</code> 符合无返回值的 <strong>Consumer</strong> 函数式接口，所以我们只能观察，无法使用不同的元素来替换流中的对象。</p>
<h3 id="流元素排序"><a href="#流元素排序" class="headerlink" title="流元素排序"></a>流元素排序</h3><p>在 <code>Randoms.java</code> 中，我们熟识了 <code>sorted()</code> 的默认比较器实现。其实它还有另一种形式的实现：传入一个 <strong>Comparator</strong> 参数。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/SortedComparator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortedComparator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FileToWords.stream(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">        .skip(<span class="number">10</span>)</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .sorted(Comparator.reverseOrder())</span><br><span class="line">        .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">        .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you what to the that sir leads in district And</span><br></pre></td></tr></table></figure>

<p><code>sorted()</code> 预设了一些默认的比较器。这里我们使用的是反转“自然排序”。当然你也可以把 Lambda 函数作为参数传递给 <code>sorted()</code>。</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><ul>
<li><p><code>distinct()</code>：在 <code>Randoms.java</code> 类中的 <code>distinct()</code> 可用于消除流中的重复元素。相比创建一个 <strong>Set</strong> 集合，该方法的工作量要少得多。</p>
</li>
<li><p><code>filter(Predicate)</code>：过滤操作会保留与传递进去的过滤器函数计算结果为 <code>true</code> 元素。</p>
</li>
</ul>
<p>在下例中，<code>isPrime()</code> 作为过滤器函数，用于检测质数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/Prime.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.LongStream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isPrime</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeClosed(<span class="number">2</span>, (<span class="type">long</span>)Math.sqrt(n))</span><br><span class="line">        .noneMatch(i -&gt; n % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> LongStream <span class="title function_">numbers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iterate(<span class="number">2</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .filter(Prime::isPrime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Prime</span>().numbers()</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Prime</span>().numbers()</span><br><span class="line">        .skip(<span class="number">90</span>)</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 5 7 11 13 17 19 23 29</span><br><span class="line">467 479 487 491 499 503 509 521 523 541</span><br></pre></td></tr></table></figure>

<p><code>rangeClosed()</code> 包含了上限值。如果不能整除，即余数不等于 0，则 <code>noneMatch()</code> 操作返回 <code>true</code>，如果出现任何等于 0 的结果则返回 <code>false</code>。 <code>noneMatch()</code> 操作一旦有失败就会退出。</p>
<h3 id="应用函数到元素"><a href="#应用函数到元素" class="headerlink" title="应用函数到元素"></a>应用函数到元素</h3><ul>
<li><p><code>map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</p>
</li>
<li><p><code>mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</p>
</li>
<li><p><code>mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</p>
</li>
<li><p><code>mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</p>
</li>
</ul>
<p>在这里，我们使用 <code>map()</code> 映射多种函数到一个字符串流中。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FunctionMap.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String[] elements = &#123; <span class="string">&quot;12&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;45&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">static</span> Stream&lt;String&gt;</span><br><span class="line">    <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(elements);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String descr, Function&lt;String, String&gt; func)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; ---( &quot;</span> + descr + <span class="string">&quot; )---&quot;</span>);</span><br><span class="line">        testStream()</span><br><span class="line">        .map(func)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="string">&quot;add brackets&quot;</span>, s -&gt; <span class="string">&quot;[&quot;</span> + s + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        test(<span class="string">&quot;Increment&quot;</span>, s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(s) + <span class="number">1</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(NumberFormatException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">        test(<span class="string">&quot;Replace&quot;</span>, s -&gt; s.replace(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;9&quot;</span>));</span><br><span class="line">        test(<span class="string">&quot;Take last digit&quot;</span>, s -&gt; s.length() &gt; <span class="number">0</span> ?</span><br><span class="line">        s.charAt(s.length() - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> : s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---( add brackets )---</span><br><span class="line">[12]</span><br><span class="line">[]</span><br><span class="line">[23]</span><br><span class="line">[45]</span><br><span class="line">---( Increment )---</span><br><span class="line">13</span><br><span class="line">24</span><br><span class="line">46</span><br><span class="line">---( Replace )---</span><br><span class="line">19</span><br><span class="line">93</span><br><span class="line">45</span><br><span class="line">---( Take last digit )---</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>在上面的自增示例中，我们使用 <code>Integer.parseInt()</code> 尝试将一个字符串转化为整数。如果字符串不能转化成为整数就会抛出 <strong>NumberFormatException</strong> 异常，我们只须回过头来将原始字符串放回到输出流中。</p>
<p>在以上例子中，<code>map()</code> 将一个字符串映射为另一个字符串，但是我们完全可以产生和接收类型完全不同的类型，从而改变流的数据类型。下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FunctionMap2.java</span></span><br><span class="line"><span class="comment">// Different input and output types （不同的输入输出类型）</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Numbered</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">    Numbered(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Numbered(&quot;</span> + n + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionMap2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>)</span><br><span class="line">        .map(Numbered::<span class="keyword">new</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Numbered(1)</span><br><span class="line">Numbered(5)</span><br><span class="line">Numbered(7)</span><br><span class="line">Numbered(9)</span><br><span class="line">Numbered(11)</span><br><span class="line">Numbered(13)</span><br></pre></td></tr></table></figure>

<p>我们将获取到的整数通过构造器 <code>Numbered::new</code> 转化成为 <code>Numbered</code> 类型。</p>
<p>如果使用 <strong>Function</strong> 返回的结果是数值类型的一种，我们必须使用合适的 <code>mapTo数值类型</code> 进行替代。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FunctionMap3.java</span></span><br><span class="line"><span class="comment">// Producing numeric output streams（ 产生数值输出流）</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionMap3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;9&quot;</span>)</span><br><span class="line">        .mapToInt(Integer::parseInt)</span><br><span class="line">        .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">        System.out.println();</span><br><span class="line">        Stream.of(<span class="string">&quot;17&quot;</span>, <span class="string">&quot;19&quot;</span>, <span class="string">&quot;23&quot;</span>)</span><br><span class="line">        .mapToLong(Long::parseLong)</span><br><span class="line">        .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">        System.out.println();</span><br><span class="line">        Stream.of(<span class="string">&quot;17&quot;</span>, <span class="string">&quot;1.9&quot;</span>, <span class="string">&quot;.23&quot;</span>)</span><br><span class="line">        .mapToDouble(Double::parseDouble)</span><br><span class="line">        .forEach(n -&gt; System.out.format(<span class="string">&quot;%f &quot;</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 9</span><br><span class="line">17 19 23</span><br><span class="line">17.000000 1.900000 0.230000</span><br></pre></td></tr></table></figure>

<p>遗憾的是，Java 设计者并没有尽最大努力去消除基本类型。</p>
<h3 id="在-map-中组合流"><a href="#在-map-中组合流" class="headerlink" title="在 map() 中组合流"></a>在 <code>map()</code> 中组合流</h3><p>假设我们现在有了一个传入的元素流，并且打算对流元素使用 <code>map()</code> 函数。现在你已经找到了一些可爱并独一无二的函数功能，但是问题来了：这个函数功能是产生一个流。我们想要产生一个元素流，而实际却产生了一个元素流的流。</p>
<p><code>flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code>map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。</p>
<p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p>
<p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p>
<p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p>
<p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p>
<p>为了弄清它的工作原理，我们从传入一个刻意设计的函数给 <code>map()</code> 开始。该函数接受一个整数并产生一个字符串流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOfStreams.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamOfStreams</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .map(i -&gt; Stream.of(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;Kermit&quot;</span>, <span class="string">&quot;Beaker&quot;</span>))</span><br><span class="line">        .map(e-&gt; e.getClass().getName())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.stream.ReferencePipeline$Head</span><br><span class="line">java.util.stream.ReferencePipeline$Head</span><br><span class="line">java.util.stream.ReferencePipeline$Head</span><br></pre></td></tr></table></figure>

<p>我们天真地希望能够得到字符串流，但实际得到的却是“Head”流的流。我们可以使用 <code>flatMap()</code> 解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FlatMap.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlatMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .flatMap(i -&gt; Stream.of(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;Fozzie&quot;</span>, <span class="string">&quot;Beaker&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br></pre></td></tr></table></figure>

<p>从映射返回的每个流都会自动扁平为组成它的字符串。</p>
<p>下面是另一个演示，我们从一个整数流开始，然后使用每一个整数去创建更多的随机数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOfRandoms.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamOfRandoms</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">            .flatMapToInt(i -&gt; IntStream.concat(</span><br><span class="line">        rand.ints(<span class="number">0</span>, <span class="number">100</span>).limit(i), IntStream.of(-<span class="number">1</span>)))</span><br><span class="line">            .forEach(n -&gt; System.out.format(<span class="string">&quot;%d &quot;</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">58 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9 -1</span><br></pre></td></tr></table></figure>

<p>在这里我们引入了 <code>concat()</code>，它以参数顺序组合两个流。 如此，我们在每个随机 <code>Integer</code> 流的末尾添加一个 -1 作为标记。你可以看到最终流确实是从一组扁平流中创建的。</p>
<p>因为 <code>rand.ints()</code> 产生的是一个 <code>IntStream</code>，所以我必须使用 <code>flatMap()</code>、<code>concat()</code> 和 <code>of()</code> 的特定整数形式。</p>
<p>让我们再看一下将文件划分为单词流的任务。我们最后使用到的是 <strong>FileToWordsRegexp.java</strong>，它的问题是需要将整个文件读入行列表中 —— 显然需要存储该列表。而我们真正想要的是创建一个不需要中间存储层的单词流。</p>
<p>下面，我们再使用 <code>flatMap()</code> 来解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FileToWords.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileToWords</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title function_">stream</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.lines(Paths.get(filePath))</span><br><span class="line">        .skip(<span class="number">1</span>) <span class="comment">// First (comment) line</span></span><br><span class="line">        .flatMap(line -&gt;</span><br><span class="line">        Pattern.compile(<span class="string">&quot;\\W+&quot;</span>).splitAsStream(line));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stream()</code> 现在是一个静态方法，因为它可以自己完成整个流创建过程。</p>
<p><strong>注意</strong>：<code>\\W+</code> 是一个正则表达式。他表示“非单词字符”，<code>+</code> 表示“可以出现一次或者多次”。小写形式的 <code>\\w</code> 表示“单词字符”。</p>
<p>我们之前遇到的问题是 <code>Pattern.compile().splitAsStream()</code> 产生的结果为流，这意味着当我们只是想要一个简单的单词流时，在传入的行流（stream of lines）上调用 <code>map()</code> 会产生一个单词流的流。幸运的是，<code>flatMap()</code> 可以将元素流的流扁平化为一个简单的元素流。或者，我们可以使用 <code>String.split()</code> 生成一个数组，其可以被 <code>Arrays.stream()</code> 转化成为流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot;\\W+&quot;</span>))))</span><br></pre></td></tr></table></figure>

<p>有了真正的、而非 <code>FileToWordsRegexp.java</code> 中基于集合存储的流，我们每次使用都必须从头创建，因为流并不能被复用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streams/FileToWordsTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileToWordsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FileToWords.stream(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">        .limit(<span class="number">7</span>)</span><br><span class="line">        .forEach(s -&gt; System.out.format(<span class="string">&quot;%s &quot;</span>, s));</span><br><span class="line">        System.out.println();</span><br><span class="line">        FileToWords.stream(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">        .skip(<span class="number">7</span>)</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .forEach(s -&gt; System.out.format(<span class="string">&quot;%s &quot;</span>, s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not much of a cheese shop really</span><br></pre></td></tr></table></figure>

<p>在 <code>System.out.format()</code> 中的 <code>%s</code> 表明参数为 <strong>String</strong> 类型。</p>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><h1 id="十五、异常"><a href="#十五、异常" class="headerlink" title="十五、异常"></a>十五、异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。把异常情形与普通问题相区分很重要，所谓的普通问题是指，在当前环境下能得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题。你所能做的就是从当前环境跳出，并且把问题提交给上一级环境。这就是抛出异常时所发生的事情。</p>
<p>除法就是一个简单的例子。除数有可能为 0，所以先进行检查很有必要。但除数为 0 代表的究竟是什么意思呢？通过当前正在解决的问题环境，或许能知道该如何处理除数为 0 的情况。但如果这是一个意料之外的值，你也不清楚该如何处理，那就要抛出异常，而不是顺着原来的路径继续执行下去。</p>
<p>当抛出异常后，有几件事会随之发生。首先，同 Java 中其他对象的创建一样，将使用 new 在堆上创建异常对象。然后，当前的执行路径（它不能继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。</p>
<p>举一个抛出异常的简单例子。对于对象引用 t，传给你的时候可能尚未被初始化。所以在使用这个对象引用调用其方法之前，会先对引用进行检查。可以创建一个代表错误信息的对象，并且将它从当前环境中“抛出”，这样就把错误信息传播到了“更大”的环境中。这被称为<em>抛出一个异常</em>，看起来像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>

<p>这就抛出了异常，于是在当前环境下就不必再为这个问题操心了，它将在别的地方得到处理。具体是哪个“地方”后面很快就会介绍。</p>
<p>异常使得我们可以将每件事都当作一个事务来考虑，而异常可以看护着这些事务的底线“…事务的基本保障是我们所需的在分布式计算中的异常处理。事务是计算机中的合同法，如果出了什么问题，我们只需要放弃整个计算。”我们还可以将异常看作是一种内建的恢复（undo）系统，因为（在细心使用的情况下）我们在程序中可以拥有各种不同的恢复点。如果程序的某部分失败了，异常将“恢复”到程序中某个已知的稳定点上。</p>
<p>异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。在 C 和 C++ 这样的语言中，这可真是个问题，尤其是 C，它没有任何办法可以强制程序在出现问题时停止在某条路径上运行下去，因此我们有可能会较长时间地忽略问题，从而会陷入完全不恰当的状态中。异常允许我们（如果没有其他手段）强制程序停止运行，并告诉我们出现了什么问题，或者（理想状态下）强制程序处理问题，并返回到稳定状态。</p>
<h2 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h2><p>与使用 Java 中的其他对象一样，我们总是用 new 在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;t = null&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不久读者将看到，要把这个字符串的内容提取出来可以有多种不同的方法。</p>
<p>关键字 <strong>throw</strong> 将产生许多有趣的结果。在使用 <strong>new</strong> 创建了异常对象之后，此对象的引用将传给 <strong>throw</strong>。尽管异常对象的类型通常与方法设计的返回类型不同，但从效果上看，它就像是从方法“返回”的。可以简单地把异常处理看成一种不同的返回机制，当然若过分强调这种类比的话，就会有麻烦了。另外还能用抛出异常的方式从当前的作用域退出。在这两种情况下，将会返回一个异常对象，然后退出方法或作用域。</p>
<p>抛出异常与方法正常返回的相似之处到此为止。因为异常返回的“地点”与普通方法调用返回的“地点”完全不同。（异常将在一个恰当的异常处理程序中得到解决，它的位置可能离异常被抛出的地方很远，也可能会跨越方法调用栈的许多层级。）</p>
<p>此外，能够抛出任意类型的 <strong>Throwable</strong> 对象，它是异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象内部或者用异常类的名称来暗示。上一层环境通过这些信息来决定如何处理异常。（通常，唯一的信息只有异常的类型名，而在异常对象内部没有任何有意义的信息。）</p>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>要明白异常是如何被捕获的，必须首先理解监控区域（guarded region）的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。</p>
<h3 id="try-语句块"><a href="#try-语句块" class="headerlink" title="try 语句块"></a>try 语句块</h3><p>如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种（可能产生异常的）方法调用，所以称为 try 块。它是跟在 try 关键字之后的普通程序块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Code that might generate exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不支持异常处理的程序语言，要想仔细检查错误，就得在每个方法调用的前后加上设置和错误检查的代码，甚至在每次调用同一方法时也得这么做。有了异常处理机制，可以把所有动作都放在 try 块里，然后只需在一个地方就可以捕获所有异常。这意味着你的代码将更容易编写和阅读，因为代码的意图和错误检查不是混淆在一起的。</p>
<h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>当然，抛出的异常必须在某处得到处理。这个“地点”就是异常处理程序，而且针对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在 try 块之后，以关键字 catch 表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Code that might generate exceptions</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type1 id1) &#123;</span><br><span class="line">    <span class="comment">// Handle exceptions of Type1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type2 id2) &#123;</span><br><span class="line">    <span class="comment">// Handle exceptions of Type2</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type3 id3) &#123;</span><br><span class="line">    <span class="comment">// Handle exceptions of Type3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// etc.</span></span><br></pre></td></tr></table></figure>

<p>每个 catch 子句（异常处理程序）看起来就像是接收且仅接收一个特殊类型的参数的方法。可以在处理程序的内部使用标识符（id1，id2 等等），这与方法参数的使用很相似。有时可能用不到标识符，因为异常的类型已经给了你足够的信息来对异常进行处理，但标识符并不可以省略。</p>
<p>异常处理程序必须紧跟在 try 块之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入 catch 子句执行，此时认为异常得到了处理。一旦 catch 子句结束，则处理程序的查找过程结束。注意，只有匹配的 catch 子句才能得到执行；这与 switch 语句不同，switch 语句需要在每一个 case 后面跟一个 break，以避免执行后续的 case 子句。</p>
<p>注意在 try 块的内部，许多不同的方法调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。</p>
<h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>异常处理理论上有两种基本模型。Java 支持终止模型（它是 Java 和 C++所支持的模型）。在这种模型中，将假设错误非常严重，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。</p>
<p>另一种称为恢复模型。意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。如果想要用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把 try 块放在 while 循环里，这样就不断地进入 try 块，直到得到满意的结果。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2>]]></content>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2022/08/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="第一章-Redis基础"><a href="#第一章-Redis基础" class="headerlink" title="第一章 Redis基础"></a>第一章 Redis基础</h1><p><strong>课程计划</strong></p>
<table>
<thead>
<tr>
<th>1. Redis 入 门</th>
<th><strong>（了解）</strong></th>
<th><strong>（操作）</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2. 数据类型</td>
<td><strong>（重点）</strong></td>
<td><strong>（操作）</strong></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>3. 常用指令</td>
<td></td>
<td><strong>（操作）</strong></td>
<td></td>
</tr>
<tr>
<td>4. Jedis</td>
<td><strong>（重点）</strong></td>
<td><strong>（操作）</strong></td>
<td></td>
</tr>
<tr>
<td>5. 持 久 化</td>
<td><strong>（重点）</strong></td>
<td></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>6. 数据删除与淘汰策略</td>
<td></td>
<td></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>7. 主从复制</td>
<td><strong>（重点）</strong></td>
<td><strong>（操作）</strong></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>8. 哨 兵</td>
<td><strong>（重点）</strong></td>
<td><strong>（操作）</strong></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>9. Cluster集群方案</td>
<td><strong>（重点）</strong></td>
<td><strong>（操作）</strong></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>10. 企业级缓存解决方案</td>
<td><strong>（重点）</strong></td>
<td></td>
<td><strong>（理解）</strong></td>
</tr>
<tr>
<td>11. 性能指标监控</td>
<td><strong>（了解）</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><p>目标1：能够说出NoSQL的概念，redis的应用场景，能够完成redis的下载安装与启动以及一些常用的配置</p>
<p>目标2：能够说出redis常用的5种数据类型，对应这些数据类型的基本操作，应用场景及对应的解决方案</p>
<p>目标3：能够说出redis中常用的一些基本指令</p>
<p>目标4：能够使用jedis完成客户端应用程序的开发</p>
<p>目标5：能够说出redis数据持久化的两种方式，各自相关的操作配置及指令，以及两种方式的优缺点比较</p>
<h2 id="1-Redis-简介"><a href="#1-Redis-简介" class="headerlink" title="1. Redis 简介"></a>1. Redis 简介</h2><p>在这个部分，我们将学习以下3个部分的内容，分别是：</p>
<p>◆ Redis 简介（NoSQL概念、Redis概念）</p>
<p>◆ Redis 的下载与安装</p>
<p>◆ Redis 的基本操作</p>
<h3 id="1-1-NoSQL概念"><a href="#1-1-NoSQL概念" class="headerlink" title="1.1 NoSQL概念"></a>1.1 NoSQL概念</h3><h4 id="1-1-1-问题现象"><a href="#1-1-1-问题现象" class="headerlink" title="1.1.1 问题现象"></a>1.1.1 问题现象</h4><p>在讲解NoSQL的概念之前呢，我们先来看一个现象：</p>
<p>（1）问题现象</p>
<p>每年到了过年期间，大家都会自觉自发的组织一场活动，叫做春运！以前我们买票都是到火车站排队，后来呢有了12306，有了他以后就更方便了，我们可以在网上买票，但是带来的问题，大家也很清楚，春节期间买票进不去，进去了刷不着票。什么原因呢，人太多了！</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032349717.png"></p>
<p>除了这种做铁路的，它系统做的不专业以外，还有马爸爸做的淘宝，它面临一样的问题。淘宝也崩，也是用户量太大！作为我们整个电商界的东哥来说，他第一次做图书促销的时候，也遇到了服务器崩掉的这样一个现象，原因同样是因为用户量太大！</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032350907.png"></p>
<p>（2）现象特征</p>
<p>再来看这几个现象，有两个非常相似的特征：</p>
<p>第一，用户比较多，海量用户</p>
<p>第二，高并发</p>
<p>这两个现象出现以后，对应的就会造成我们的服务器瘫痪。核心本质是什么呢？其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首！</p>
<p>（3）造成原因</p>
<p>什么样的原因导致的整个系统崩掉的呢：</p>
<p>1.性能瓶颈：磁盘IO性能低下</p>
<p>关系型数据库菜存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的。</p>
<p>2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群</p>
<p>我们说关系型数据库，它里面表与表之间的关系非常复杂，不知道大家能不能想象一点，就是一张表，通过它的外键关联了七八张表，这七八张表又通过她的外件，每张又关联了四五张表。你想想，查询一下，你要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难!</p>
<p>（4）解决思路</p>
<p>面对这样的现象，我们要想解决怎么版呢。两方面：</p>
<p>一，降低磁盘IO次数，越低越好。</p>
<p>二，去除数据间关系，越简单越好。</p>
<p>降低磁盘IO次数，越低越好，怎么搞？我不用你磁盘不就行了吗？于是，内存存储的思想就提出来了，我数据不放到你磁盘里边，放内存里，这样是不是效率就高了。</p>
<p>第二，你的数据关系很复杂，那怎么办呢？干脆简单点，我断开你的关系，我不存关系了，我只存数据，这样不就没这事了吗？</p>
<p>把这两个特征一合并一起，就出来了一个新的概念：NoSQL</p>
<h4 id="1-1-2-NoSQL的概念"><a href="#1-1-2-NoSQL的概念" class="headerlink" title="1.1.2 NoSQL的概念"></a>1.1.2 NoSQL的概念</h4><p>（1）概念</p>
<p>NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。</p>
<p>他说这句话说的非常客气，什么意思呢？就是我们数据存储要用SQL，但是呢可以不仅仅用SQL，还可以用别的东西，那别的东西叫什么呢？于是他定义了一句话叫做NoSQL。这个意思就是说我们存储数据，可以不光使用SQL，我们还可以使用非SQL的这种存储方案，这就是所谓的NoSQL。</p>
<p>（2）特征</p>
<p>可扩容，可伸缩。SQL数据关系过于复杂，你扩容一下难度很高，那我们Nosql 这种的，不存关系，所以它的扩容就简单一些。</p>
<p>大数据量下高性能。包数据非常多的时候，它的性能高，因为你不走磁盘IO，你走的是内存，性能肯定要比磁盘IO的性能快一些。</p>
<p>灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它！</p>
<p>（3）常见 Nosql 数据库</p>
<p>目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB</p>
<p>（4）应用场景-电商为例</p>
<p>我们以电商为例，来看一看他在这里边起到的作用。</p>
<p>第一类，在电商中我们的基础数据一定要存储起来，比如说商品名称，价格，生产厂商，这些都属于基础数据，这些数据放在MySQL数据库。</p>
<p>第二类，我们商品的附加信息，比如说，你买了一个商品评价了一下，这个评价它不属于商品本身。就像你买一个苹果，“这个苹果很好吃”就是评论，但是你能说很好吃是这个商品的属性嘛？不能这么说，那只是一个人对他的评论而已。这一类数据呢，我们放在另外一个地方，我们放到MongoDB。它也可以用来加快我们的访问，他属于NoSQL的一种。</p>
<p>第三，图片内的信息。注意这种信息相对来说比较固定，他有专用的存储区，我们一般用文件系统来存储。至于是不是分布式，要看你的系统的一个整个   瓶颈   了？如果说你发现你需要做分布式，那就做，不需要的话，一台主机就搞定了。</p>
<p>第四，搜索关键字。为了加快搜索，我们会用到一些技术，有些人可能了解过，像分ES、Lucene、solr都属于搜索技术。那说的这么热闹，我们的电商解决方案中还没出现我们的redis啊！注意第五类信息。</p>
<p>第五，热点信息。访问频度比较高的信息，这种东西的第二特征就是它具有波段性。换句话说他不是稳定的，它具有一个时效性的。那么这类信息放哪儿了，放到我们的redis这个解决方案中来进行存储。</p>
<p>具体的我们从我们的整个数据存储结构的设计上来看一下。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032351303.png"></p>
<p>我们的基础数据都存MySQL,在它的基础之上，我们把它连在一块儿，同时对外提供服务。向上走，有一些信息加载完以后,要放到我们的MongoDB中。还有一类信息，我们放到我们专用的文件系统中（比如图片），就放到我们的这个搜索专用的，如Lucene、solr及集群里边，或者用ES的这种技术里边。那么剩下来的热点信息，放到我们的redis里面。</p>
<h3 id="1-2-Redis概念"><a href="#1-2-Redis概念" class="headerlink" title="1.2 Redis概念"></a>1.2 Redis概念</h3><h4 id="1-2-1-redis概念"><a href="#1-2-1-redis概念" class="headerlink" title="1.2.1 redis概念"></a>1.2.1 redis概念</h4><p>概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。</p>
<p>特征：</p>
<p>（1）数据间没有必然的关联关系；</p>
<p>（2）内部采用单线程机制进行工作；</p>
<p>（3）高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</p>
<p>（4）多数据类型支持</p>
<p>字符串类型，string  list</p>
<p>列表类型，hash  set</p>
<p>散列类型，zset/sorted_set</p>
<p>集合类型</p>
<p>有序集合类型</p>
<p>（5）支持持久化，可以进行数据灾难恢复</p>
<h4 id="1-2-2-redis的应用场景"><a href="#1-2-2-redis的应用场景" class="headerlink" title="1.2.2 redis的应用场景"></a>1.2.2 redis的应用场景</h4><p>（1）为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。</p>
<p>（2）即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。</p>
<p>（3）时效性信息控制。如验证码控制、投票控制等。</p>
<p>（4）分布式数据共享。如分布式集群架构中的 session 分离<br>消息队列.</p>
<h3 id="1-3-Redis-的下载与安装"><a href="#1-3-Redis-的下载与安装" class="headerlink" title="1.3 Redis 的下载与安装"></a>1.3 Redis 的下载与安装</h3><p>后期所有资料分4中不同色块显示，详情如下：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032352663.png"></p>
<h4 id="1-3-1-Redis-的下载与安装"><a href="#1-3-1-Redis-的下载与安装" class="headerlink" title="1.3.1 Redis 的下载与安装"></a>1.3.1 Redis 的下载与安装</h4><p>本课程所示，均基于Center OS7安装Redis。</p>
<p>（1)下载Redis</p>
<p>下载安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar –xvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>

<p>编译（在解压的目录中执行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>安装（在解压的目录中执行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>（2）安装 Redis</p>
<p>redis-server，服务器启动命令 客户端启动命令</p>
<p>redis-cli，redis核心配置文件</p>
<p>redis.conf，RDB文件检查工具（快照持久化文件）</p>
<p>redis-check-dump，AOF文件修复工具</p>
<p>redis-check-aof</p>
<h3 id="1-4-Redis服务器启动"><a href="#1-4-Redis服务器启动" class="headerlink" title="1.4 Redis服务器启动"></a>1.4 Redis服务器启动</h3><h4 id="1-4-1-Redis服务器启动"><a href="#1-4-1-Redis服务器启动" class="headerlink" title="1.4.1 Redis服务器启动"></a>1.4.1 Redis服务器启动</h4><p>启动服务器——参数启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server [--port port]</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server --port 6379</span><br></pre></td></tr></table></figure>

<p>启动服务器——配置文件启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-Redis客户端启动"><a href="#1-4-2-Redis客户端启动" class="headerlink" title="1.4.2 Redis客户端启动"></a>1.4.2 Redis客户端启动</h4><p>启动客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli [-h host] [-p port]</span><br></pre></td></tr></table></figure>

<p>范 例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli –h 61.129.65.248 –p 6384</span><br></pre></td></tr></table></figure>

<p>注意：服务器启动指定端口使用的是–port，客户端启动指定端口使用的是-p。-的数量不同。</p>
<h4 id="1-4-3-Redis基础环境设置约定"><a href="#1-4-3-Redis基础环境设置约定" class="headerlink" title="1.4.3 Redis基础环境设置约定"></a>1.4.3 Redis基础环境设置约定</h4><p>创建配置文件存储目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> conf</span><br></pre></td></tr></table></figure>

<p>创建服务器文件存储目录（包含日志、数据、临时配置文件等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> data</span><br></pre></td></tr></table></figure>

<p>创建快速访问链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s redis-5.0.0 redis</span><br></pre></td></tr></table></figure>

<h3 id="1-5-配置文件启动与常用配置"><a href="#1-5-配置文件启动与常用配置" class="headerlink" title="1.5 配置文件启动与常用配置"></a>1.5 配置文件启动与常用配置</h3><h4 id="1-5-1-服务器端设定"><a href="#1-5-1-服务器端设定" class="headerlink" title="1.5.1 服务器端设定"></a>1.5.1 服务器端设定</h4><p>设置服务器以守护进程的方式运行，开启后服务器控制台中将打印服务器运行信息（同日志内容相同）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>

<p>绑定主机地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> ip</span><br></pre></td></tr></table></figure>

<p>设置服务器端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port port</span><br></pre></td></tr></table></figure>

<p>设置服务器文件保存地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-客户端配置"><a href="#1-5-2-客户端配置" class="headerlink" title="1.5.2  客户端配置"></a>1.5.2  客户端配置</h4><p> 服务器允许客户端连接最大数量，默认0，表示无限制。当客户端连接到达上限后，Redis会拒绝新的连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients count</span><br></pre></td></tr></table></figure>

<p>客户端闲置等待最大时长，达到最大值后关闭对应连接。如需关闭该功能，设置为 0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> seconds</span><br></pre></td></tr></table></figure>

<h4 id="1-5-3-日志配置"><a href="#1-5-3-日志配置" class="headerlink" title="1.5.3  日志配置"></a>1.5.3  日志配置</h4><p>设置服务器以指定日志记录级别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure>

<p>日志记录文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logfile filename</span><br></pre></td></tr></table></figure>

<p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。</p>
<h3 id="1-6-Redis基本操作"><a href="#1-6-Redis基本操作" class="headerlink" title="1.6 Redis基本操作"></a>1.6 Redis基本操作</h3><h4 id="1-6-1-命令行模式工具使用思考"><a href="#1-6-1-命令行模式工具使用思考" class="headerlink" title="1.6.1  命令行模式工具使用思考"></a>1.6.1  命令行模式工具使用思考</h4><p>功能性命令</p>
<p>帮助信息查阅</p>
<p>退出指令</p>
<p>清除屏幕信息</p>
<h4 id="1-6-2-信息读写"><a href="#1-6-2-信息读写" class="headerlink" title="1.6.2  信息读写"></a>1.6.2  信息读写</h4><p>设置 key，value 数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> name itheima</span><br></pre></td></tr></table></figure>

<p>根据 key 查询对应的 value，如果不存在，返回空（nil）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-帮助信息"><a href="#1-6-3-帮助信息" class="headerlink" title="1.6.3  帮助信息"></a>1.6.3  帮助信息</h4><p>获取命令帮助文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<p>获取组中所有命令信息名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [@group-name]</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> @string</span><br></pre></td></tr></table></figure>

<p>1.6.4  退出命令行客户端模式</p>
<p>退出客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">quit</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>快捷键</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure>

<h4 id="1-6-4-redis入门总结"><a href="#1-6-4-redis入门总结" class="headerlink" title="1.6.4  redis入门总结"></a>1.6.4  redis入门总结</h4><p>到这里，Redis 入门的相关知识，我们就全部学习完了，再来回顾一下，这个部分我们主要讲解了哪些内容呢？</p>
<p>首先，我们对Redis进行了一个简单介绍，包括NoSQL的概念、Redis的概念等。</p>
<p>然后，我们介绍了Redis 的下载与安装。包括下载与安装、服务器与客户端启动、以及相关配置文件（3类）。</p>
<p>最后，我们介绍了Redis 的基本操作。包括数据读写、退出与帮助信息获取。</p>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>在这个部分，我们将学习一共要学习三大块内容，首先需要了解一下数据类型，接下来将针对着我们要学习的数据类型进行逐一的讲解，如string、hash、list、set等，最后我们通过一个案例来总结前面的数据类型的使用场景。</p>
<h3 id="2-1-数据存储类型介绍"><a href="#2-1-数据存储类型介绍" class="headerlink" title="2.1  数据存储类型介绍"></a>2.1  数据存储类型介绍</h3><h4 id="2-1-1-业务数据的特殊性"><a href="#2-1-1-业务数据的特殊性" class="headerlink" title="2.1.1  业务数据的特殊性"></a>2.1.1  业务数据的特殊性</h4><p>在讲解数据类型之前，我们得先思考一个问题，数据类型既然是用来描述数据的存储格式的，如果你不知道哪些数据未来会进入到我们来的redis中，那么对应的数据类型的选择，你就会出现问题，我们一块来看一下：</p>
<p>（1）原始业务功能设计</p>
<p>秒杀。他这个里边数据变化速度特别的快，访问量也特别的高，用户大量涌入以后都会针对着一部分数据进行操作，这一类要记住。</p>
<p>618活动。对于我们京东的618活动、以及天猫的双11活动，相信大家不用说都知道这些数据一定要进去，因为他们的访问频度实在太高了。</p>
<p>排队购票。我们12306的票务信息。这些信息在原始设计的时候，他们就注定了要进redis。</p>
<p>（2）运营平台监控到的突发高频访问数据</p>
<p>此类平台临时监控到的这些数据，比如说现在出来的一个八卦的信息，这个新闻一旦出现以后呢，顺速的被围观了，那么这个时候，这个数据就会变得访量特别高，那么这类信息也要进入进去。</p>
<p>（3）高频、复杂的统计数据</p>
<p>在线人数。比如说直播现在很火，直播里边有很多数据，例如在线人数。进一个人出一个人，这个数据就要跳动，那么这个访问速度非常的快，而且访量很高，并且它里边有一个复杂的数据统计，在这里这种信息也要进入到我们的redis中。</p>
<p>投票排行榜。投票投票类的信息他的变化速度也比较快，为了追求一个更快的一个即时投票的名次变化，这种数据最好也放到redis中。</p>
<h4 id="2-1-2-Redis-数据类型-5种常用"><a href="#2-1-2-Redis-数据类型-5种常用" class="headerlink" title="2.1.2  Redis 数据类型(5种常用)"></a>2.1.2  Redis 数据类型(5种常用)</h4><p>基于以上数据特征我们进行分析，最终得出来我们的Redis中要设计5种 数据类型：</p>
<p>string、hash、list、set、sorted_set/zset（应用性较低）</p>
<h3 id="2-2-string数据类型"><a href="#2-2-string数据类型" class="headerlink" title="2.2  string数据类型"></a>2.2  string数据类型</h3><p>在学习第一个数据类型之前，先给大家介绍一下，在随后这部分内容的学习过程中，我们每一种数据类型都分成三块来讲：首先是讲下它的基本操作，接下来讲一些它的扩展操作，最后我们会去做一个小的案例分析。</p>
<h4 id="2-2-1Redis-数据存储格式"><a href="#2-2-1Redis-数据存储格式" class="headerlink" title="2.2.1Redis 数据存储格式"></a>2.2.1Redis 数据存储格式</h4><p>在学习string这个数据形式之前，我们先要明白string到底是修饰什么的。我们知道redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储。</p>
<p>对于这种结构来说，我们用来存储数据一定是一个值前面对应一个名称。我们通过名称来访问后面的值。按照这种形势，我们可以对出来我们的存储格式。前面这一部分我们称为key。后面的一部分称为value，而我们的数据类型，他一定是修饰value的。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032352284.png"></p>
<p>数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。</p>
<h4 id="2-2-2-string-类型"><a href="#2-2-2-string-类型" class="headerlink" title="2.2.2  string 类型"></a>2.2.2  string 类型</h4><p>（1）存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型。</p>
<p>string，他就是存一个字符串儿，注意是value那一部分是一个字符串，它是redis中最基本、最简单的存储数据的格式。</p>
<p>（2）存储数据的格式：一个存储空间保存一个数据</p>
<p>每一个空间中只能保存一个字符串信息，这个信息里边如果是存的纯数字，他也能当数字使用，我们来看一下，这是我们的数据的存储空间。</p>
<p>（3）存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用.</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032353453.png"></p>
<p>一个key对一个value，而这个itheima就是我们所说的string类型，当然它也可以是一个纯数字的格式。</p>
<h4 id="2-2-3-string-类型数据的基本操作"><a href="#2-2-3-string-类型数据的基本操作" class="headerlink" title="2.2.3  string 类型数据的基本操作"></a>2.2.3  string 类型数据的基本操作</h4><p>（1）基础指令</p>
<p>添加/修改数据添加/修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure>

<p>获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure>

<p>删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure>

<p>判定性添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure>

<p>添加/修改多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mset key1 value1 key2 value2 …</span><br></pre></td></tr></table></figure>

<p>获取多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mget key1 key2 …</span><br></pre></td></tr></table></figure>

<p>获取数据字符个数（字符串长度）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure>

<p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure>

<p>（2）单数据操作与多数据操作的选择之惑</p>
<p>即set 与mset的关系。这对于这两个操作来说，没有什么你应该选哪个，而是他们自己的特征是什么，你要根据这个特征去比对你的业务，看看究竟适用于哪个。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032353965.png"></p>
<p>假如说这是我们现在的服务器，他要向redis要数据的话，它会发出一条指令。那么当这条指令发过来的时候，比如说是这个set指令过来，那么它会把这个结果返回给你，这个时候我们要思考这里边一共经过了多长时间。</p>
<p>首先，发送set指令要时间，这是网络的一个时间，接下来redis要去运行这个指令要消耗时间，最终把这个结果返回给你又有一个时间，这个时间又是一个网络的时间，那我们可以理解为：一个指令发送的过程中需要消耗这样的时间.</p>
<p>但是如果说现在不是一条指令了，你要发3个set的话，还要多长时间呢？对应的发送时间要乘3了，因为这是三个单条指令,而运行的操作时间呢，它也要乘3了，但最终返回的也要发3次，所以这边也要乘3。</p>
<p>于是我们可以得到一个结论：单指令发3条它需要的时间，假定他们两个一样，是6个网络时间加3个处理时间，如果我们把它合成一个mset呢，我们想一想。</p>
<p>假如说用多指令发3个指令的话，其实只需要发一次就行了。这样我们可以得到一个结论，多指令发3个指令的话，其实它是两个网络时间加上3个redis的操作时间，为什么这写一个小加号呢，就是因为毕竟发的信息量变大了，所以网络时间有可能会变长。</p>
<p>那么通过这张图，你就可以得到一个结论，我们单指令和多指令他们的差别就在于你发送的次数是多还是少。当你影响的数据比较少的时候，你可以用单指令，也可以用多指令。但是一旦这个量大了，你就要选择多指令了，他的效率会高一些。</p>
<h3 id="2-3-string-类型数据的扩展操作"><a href="#2-3-string-类型数据的扩展操作" class="headerlink" title="2.3  string 类型数据的扩展操作"></a>2.3  string 类型数据的扩展操作</h3><h4 id="2-3-1-string-类型数据的扩展操作"><a href="#2-3-1-string-类型数据的扩展操作" class="headerlink" title="2.3.1  string 类型数据的扩展操作"></a>2.3.1  string 类型数据的扩展操作</h4><p>下面我们来看一string的扩展操作，分成两大块：一块是对数字进行操作的，第二块是对我们的key的时间进行操作的。</p>
<p>设置数值数据增加指定范围的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure>

<p>设置数值数据减少指定范围的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure>

<p>设置数据具有指定的生命周期</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-string-类型数据操作的注意事项"><a href="#2-3-2-string-类型数据操作的注意事项" class="headerlink" title="2.3.2  string 类型数据操作的注意事项"></a>2.3.2  string 类型数据操作的注意事项</h4><p>(1)数据操作不成功的反馈与数据正常操作之间的差异</p>
<p>表示运行结果是否成功</p>
<p>(integer) 0  → false                 失败</p>
<p>(integer) 1  → true                  成功</p>
<p>表示运行结果值</p>
<p>(integer) 3  → 3                        3个</p>
<p>(integer) 1  → 1                         1个</p>
<p>(2)数据未获取到时，对应的数据为（nil），等同于null</p>
<p>(3)数据最大存储量：512MB</p>
<p>(4)string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算</p>
<p>(5)按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错<br>9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE）</p>
<p>(6)redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响.</p>
<h3 id="2-4string应用场景与key命名约定"><a href="#2-4string应用场景与key命名约定" class="headerlink" title="2.4string应用场景与key命名约定"></a>2.4string应用场景与key命名约定</h3><h4 id="2-4-1-应用场景"><a href="#2-4-1-应用场景" class="headerlink" title="2.4.1  应用场景"></a>2.4.1  应用场景</h4><p>它的应用场景在于：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032354454.png"></p>
<p>我们来思考一下：这些信息是不是你进入大V的页面儿以后就要读取这写信息的啊，那这种信息一定要存储到我们的redis中，因为他的访问量太高了！那这种数据应该怎么存呢？我们来一块儿看一下方案！</p>
<h4 id="2-4-2-解决方案"><a href="#2-4-2-解决方案" class="headerlink" title="2.4.2  解决方案"></a>2.4.2  解决方案</h4><p>（1）在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">eg:	user:id:3506728370:fans		→	12210947</span><br><span class="line">eg:	user:id:3506728370:blogs	→	6164</span><br><span class="line">eg:	user:id:3506728370:focuses	→	83</span><br></pre></td></tr></table></figure>

<p>（2）也可以使用json格式保存数据</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">eg:	user:id:3506728370    →	&#123;“fans”：12210947，“blogs”：6164，“ focuses ”：83 &#125;</span><br></pre></td></tr></table></figure>

<p>（3） key 的设置约定</p>
<p>数据库中的热点数据key命名惯例</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>表名</strong></th>
<th><strong>主键名</strong></th>
<th>主键值</th>
<th><strong>字段名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>eg1：</td>
<td>order</td>
<td>id</td>
<td>29437595</td>
<td>name</td>
</tr>
<tr>
<td>eg2：</td>
<td>equip</td>
<td>id</td>
<td>390472345</td>
<td>type</td>
</tr>
<tr>
<td>eg3：</td>
<td>news</td>
<td>id</td>
<td>202004150</td>
<td>title</td>
</tr>
</tbody></table>
<h3 id="2-5-hash的基本操作"><a href="#2-5-hash的基本操作" class="headerlink" title="2.5  hash的基本操作"></a>2.5  hash的基本操作</h3><p>下面我们来学习第二个数据类型hash。</p>
<h4 id="2-5-1-数据存储的困惑"><a href="#2-5-1-数据存储的困惑" class="headerlink" title="2.5.1  数据存储的困惑"></a>2.5.1  数据存储的困惑</h4><p>对象类数据的存储如果具有较频繁的更新需求操作会显得笨重！</p>
<p>在正式学习之前，我们先来看一个关于数据存储的困惑：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032354269.png"></p>
<p>比如说前面我们用以上形式存了数据，如果我们用单条去存的话，它存的条数会很多。但如果我们用json格式，它存一条数据就够了。问题来了，假如说现在粉丝数量发生变化了，你要把整个值都改了。但是用单条存的话就不存在这个问题，你只需要改其中一个就行了。这个时候我们就想，有没有一种新的存储结构，能帮我们解决这个问题呢。</p>
<p>我们一块儿来分析一下：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032355280.png"></p>
<p>如上图所示：单条的话是对应的数据在后面放着。仔细观察：我们看左边是不是长得都一模一样啊，都是对应的表名、ID等的一系列的东西。我们可以将右边红框中的这个区域给他封起来。</p>
<p>那如果要是这样的形式的话，如下图，我们把它一合并，并把右边的东西给他变成这个格式，这不就行了吗？</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032355356.png"></p>
<p>这个图其实大家并不陌生，第一，你前面学过一个东西叫hashmap不就这格式吗？第二，redis自身不也是这格式吗？那是什么意思呢？注意，这就是我们要讲的第二种格式，hash。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032356147.png"></p>
<p>在右边对应的值，我们就存具体的值，那左边儿这就是我们的key。问题来了，那中间的这一块叫什么呢？这个东西我们给他起个名儿，叫做field字段。那么右边儿整体这块儿空间我们就称为hash，也就是说hash是存了一个key value的存储空间。</p>
<h4 id="2-5-2-hash-类型"><a href="#2-5-2-hash-类型" class="headerlink" title="2.5.2  hash 类型"></a>2.5.2  hash 类型</h4><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p>
<p>需要的存储结构：一个存储空间保存多个键值对数据</p>
<p>hash类型：底层使用哈希表结构实现数据存储</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032356346.png"></p>
<p>如上图所示，这种结构叫做hash，左边一个key，对右边一个存储空间。这里要明确一点，右边这块儿存储空间叫hash，也就是说hash是指的一个数据类型，他指的不是一个数据，是这里边的一堆数据，那么它底层呢，是用hash表的结构来实现的。</p>
<p>值得注意的是：</p>
<p>如果field数量较少，存储结构优化为类数组结构</p>
<p>如果field数量较多，存储结构使用HashMap结构</p>
<h4 id="2-5-3-hash-类型数据的基本操作"><a href="#2-5-3-hash-类型数据的基本操作" class="headerlink" title="2.5.3  hash 类型数据的基本操作"></a>2.5.3  hash 类型数据的基本操作</h4><p>添加/修改数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure>

<p>获取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hget key field</span><br><span class="line">hgetall key</span><br></pre></td></tr></table></figure>

<p>删除数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure>

<p>设置field的值，如果该field存在则不做任何操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure>

<p>添加/修改多个数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2 …</span><br></pre></td></tr></table></figure>

<p>获取多个数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hmget key field1 field2 …</span><br></pre></td></tr></table></figure>

<p>获取哈希表中字段的数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure>

<p>获取哈希表中是否存在指定的字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure>

<h3 id="2-6-hash的拓展操作"><a href="#2-6-hash的拓展操作" class="headerlink" title="2.6  hash的拓展操作"></a>2.6  hash的拓展操作</h3><p>在看完hash的基本操作后，我们再来看他的拓展操作，他的拓展操作相对比较简单：</p>
<h4 id="2-6-1-hash-类型数据扩展操作"><a href="#2-6-1-hash-类型数据扩展操作" class="headerlink" title="2.6.1  hash 类型数据扩展操作"></a>2.6.1  hash 类型数据扩展操作</h4><p>获取哈希表中所有的字段名或字段值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure>

<p>设置指定字段的数值数据增加指定范围的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-hash类型数据操作的注意事项"><a href="#2-6-2-hash类型数据操作的注意事项" class="headerlink" title="2.6.2  hash类型数据操作的注意事项"></a>2.6.2  hash类型数据操作的注意事项</h4><p>(1)hash类型中value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）。</p>
<p>(2）每个 hash 可以存储 232 - 1 个键值对<br>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计 的，切记不可滥用，更不可以将hash作为对象列表使用。</p>
<p>(3)hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。</p>
<h3 id="2-7-hash应用场景"><a href="#2-7-hash应用场景" class="headerlink" title="2.7  hash应用场景"></a>2.7  hash应用场景</h3><h4 id="2-7-1-应用场景"><a href="#2-7-1-应用场景" class="headerlink" title="2.7.1  应用场景"></a>2.7.1  应用场景</h4><p>双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000  张。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032357036.png"></p>
<p>也就是商家有了，商品有了，数量有了。最终我们的用户买东西就是在改变这个数量。那你说这个结构应该怎么存呢？对应的商家的ID作为key，然后这些充值卡的ID作为field，最后这些数量作为value。而我们所谓的操作是其实就是increa这个操作，只不过你传负值就行了。看一看对应的解决方案：</p>
<h4 id="2-7-2-解决方案"><a href="#2-7-2-解决方案" class="headerlink" title="2.7.2  解决方案"></a>2.7.2  解决方案</h4><p>以商家id作为key</p>
<p>将参与抢购的商品id作为field</p>
<p>将参与抢购的商品数量作为对应的value</p>
<p>抢购时使用降值的方式控制产品数量</p>
<p>注意：实际业务中还有超卖等实际问题，这里不做讨论</p>
<h3 id="2-8-list基本操作"><a href="#2-8-list基本操作" class="headerlink" title="2.8  list基本操作"></a>2.8  list基本操作</h3><p>前面我们存数据的时候呢，单个数据也能存，多个数据也能存，但是这里面有一个问题，我们存多个数据用hash的时候它是没有顺序的。我们平时操作，实际上数据很多情况下都是有顺序的，那有没有一种能够用来存储带有顺序的这种数据模型呢，list就专门来干这事儿。</p>
<h4 id="2-8-1-list-类型"><a href="#2-8-1-list-类型" class="headerlink" title="2.8.1  list 类型"></a>2.8.1  list 类型</h4><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p>
<p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p>
<p>list类型：保存多个数据，底层使用双向链表存储结构实现</p>
<p>先来通过一张图，回忆一下顺序表、链表、双向链表。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032357710.png"></p>
<p>list对应的存储结构是什么呢？里边存的这个东西是个列表，他有一个对应的名称。就是key存一个list的这样结构。对应的基本操作，你其实是可以想到的。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032357161.png"></p>
<p>来看一下，因为它是双向的，所以他左边右边都能操作，它对应的操作结构两边都能进数据。这就是链表的一个存储结构。往外拿数据的时候怎么拿呢？通常是从一端拿，当然另一端也能拿。如果两端都能拿的话，这就是个双端队列，两边儿都能操作。如果只能从一端进一端出，这个模型咱们前面了解过，叫做栈。</p>
<h4 id="2-8-2-list-类型数据基本操作"><a href="#2-8-2-list-类型数据基本操作" class="headerlink" title="2.8.2 list 类型数据基本操作"></a>2.8.2 list 类型数据基本操作</h4><p>最后看一下他的基本操作</p>
<p>添加/修改数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lpush key value1 [value2] ……</span><br><span class="line">rpush key value1 [value2] ……</span><br></pre></td></tr></table></figure>

<p>获取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure>

<p>获取并移除数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure>

<h3 id="2-9-list扩展操作"><a href="#2-9-list扩展操作" class="headerlink" title="2.9  list扩展操作"></a>2.9  list扩展操作</h3><h4 id="2-9-1-list-类型数据扩展操作"><a href="#2-9-1-list-类型数据扩展操作" class="headerlink" title="2.9.1  list 类型数据扩展操作"></a>2.9.1  list 类型数据扩展操作</h4><p>移除指定数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>

<p>规定时间内获取并移除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line">brpoplpush source destination timeout</span><br></pre></td></tr></table></figure>

<h4 id="2-9-2-list-类型数据操作注意事项"><a href="#2-9-2-list-类型数据操作注意事项" class="headerlink" title="2.9.2  list 类型数据操作注意事项"></a>2.9.2  list 类型数据操作注意事项</h4><p>（1）list中保存的数据都是string类型的，数据总容量是有限的，最多232 - 1 个元素(4294967295)。</p>
<p>（2）list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</p>
<p>（3）获取全部数据操作结束索引设置为-1</p>
<p>（4）list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</p>
<h3 id="2-10-list-应用场景"><a href="#2-10-list-应用场景" class="headerlink" title="2.10 list 应用场景"></a>2.10 list 应用场景</h3><h4 id="2-10-1-应用场景"><a href="#2-10-1-应用场景" class="headerlink" title="2.10.1  应用场景"></a>2.10.1  应用场景</h4><p>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032358660.png"></p>
<p>假如现在你有多台服务器，每一台服务器都会产生它的日志，假设你是一个运维人员，你想看它的操作日志，你怎么看呢？打开A机器的日志看一看，打开B机器的日志再看一看吗？这样的话你会可能会疯掉的！因为左边看的有可能它的时间是11:01，右边11:02，然后再看左边11:03，它们本身是连续的，但是你在看的时候就分成四个文件了，这个时候你看起来就会很麻烦。能不能把他们合并呢？答案是可以的！怎么做呢？建立起redis服务器。当他们需要记日志的时候，记在哪儿,全部发给redis。等到你想看的时候，通过服务器访问redis获取日志。然后得到以后，就会得到一个完整的日志信息。那么这里面就可以获取到完整的日志了，依靠什么来实现呢？就依靠我们的list的模型的顺序来实现。进来一组数据就往里加，谁先进来谁先加进去，它是有一定的顺序的。</p>
<h4 id="2-10-2-解决方案"><a href="#2-10-2-解决方案" class="headerlink" title="2.10.2  解决方案"></a>2.10.2  解决方案</h4><p>依赖list的数据具有顺序的特征对信息进行管理</p>
<p>使用队列模型解决多路信息汇总合并的问题</p>
<p>使用栈模型解决最新消息的问题</p>
<h3 id="2-11-set-基本操作"><a href="#2-11-set-基本操作" class="headerlink" title="2.11  set 基本操作"></a>2.11  set 基本操作</h3><h4 id="2-11-1-set类型"><a href="#2-11-1-set类型" class="headerlink" title="2.11.1 set类型"></a>2.11.1 set类型</h4><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p>
<p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p>
<p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032358049.png"></p>
<p>通过这个名称，大家也基本上能够认识到和我们Java中的set完全一样。我们现在要存储大量的数据，并且要求提高它的查询效率。用list这种链表形式，它的查询效率是不高的，那怎么办呢？这时候我们就想，有没有高效的存储机制。其实前面咱讲Java的时候说过hash表的结构就非常的好，但是这里边我们已经有hash了，他做了这么一个设定，干嘛呢，他把hash的存储空间给改一下，右边你原来存数据改掉,全部存空，那你说数据放哪儿了？放到原来的filed的位置，也就在这里边存真正的值，那么这个模型就是我们的set 模型。</p>
<p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。</p>
<p>看一下它的整个结构：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032359858.png"></p>
<h4 id="2-11-2-set类型数据的基本操作"><a href="#2-11-2-set类型数据的基本操作" class="headerlink" title="2.11.2 set类型数据的基本操作"></a>2.11.2 set类型数据的基本操作</h4><p>添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure>

<p>获取全部数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure>

<p>删除数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure>

<p>获取集合数据总量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure>

<p>判断集合中是否包含指定数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure>

<p>随机获取集合中指定数量的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure>

<p>随机获取集中的某个数据并将该数据移除集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spop key [count]</span><br></pre></td></tr></table></figure>

<h3 id="2-12-set-类型数据的扩展操作"><a href="#2-12-set-类型数据的扩展操作" class="headerlink" title="2.12  set 类型数据的扩展操作"></a>2.12  set 类型数据的扩展操作</h3><h4 id="2-12-1-set-类型数据的扩展操作"><a href="#2-12-1-set-类型数据的扩展操作" class="headerlink" title="2.12.1  set 类型数据的扩展操作"></a>2.12.1  set 类型数据的扩展操作</h4><p>求两个集合的交、并、差集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinter key1 [key2 …]  </span><br><span class="line">sunion key1 [key2 …]  </span><br><span class="line">sdiff key1 [key2 …]</span><br></pre></td></tr></table></figure>

<p>求两个集合的交、并、差集并存储到指定集合中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinterstore destination key1 [key2 …]  </span><br><span class="line">sunionstore destination key1 [key2 …]  </span><br><span class="line">sdiffstore destination key1 [key2 …]</span><br></pre></td></tr></table></figure>

<p>将指定数据从原始集合中移动到目标集合中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure>

<p>通过下面一张图回忆一下交、并、差</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032359204.png"></p>
<h4 id="2-12-2-set-类型数据操作的注意事项"><a href="#2-12-2-set-类型数据操作的注意事项" class="headerlink" title="2.12.2  set 类型数据操作的注意事项"></a>2.12.2  set 类型数据操作的注意事项</h4><p>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。</p>
<p>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。</p>
<h3 id="2-13-set应用场景"><a href="#2-13-set应用场景" class="headerlink" title="2.13  set应用场景"></a>2.13  set应用场景</h3><h4 id="2-13-1-set应用场景"><a href="#2-13-1-set应用场景" class="headerlink" title="2.13.1  set应用场景"></a>2.13.1  set应用场景</h4><p>（1）黑名单</p>
<p>资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，  快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火 车票、机票、酒店刷票代购软件，电商刷评论、刷好评。</p>
<p>同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。</p>
<p>ps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</p>
<p>（2）白名单</p>
<p>对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证。</p>
<h4 id="2-13-2-解决方案"><a href="#2-13-2-解决方案" class="headerlink" title="2.13.2  解决方案"></a>2.13.2  解决方案</h4><p>基于经营战略设定问题用户发现、鉴别规则</p>
<p>周期性更新满足规则的用户黑名单，加入set集合</p>
<p>用户行为信息达到后与黑名单进行比对，确认行为去向</p>
<p>黑名单过滤IP地址：应用于开放游客访问权限的信息源</p>
<p>黑名单过滤设备信息：应用于限定访问设备的信息源</p>
<p>黑名单过滤用户：应用于基于访问权限的信息源</p>
<h3 id="2-14-实践案例"><a href="#2-14-实践案例" class="headerlink" title="2.14  实践案例"></a>2.14  实践案例</h3><h4 id="2-14-1业务场景"><a href="#2-14-1业务场景" class="headerlink" title="2.14.1业务场景"></a>2.14.1业务场景</h4><p>使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发 送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示。</p>
<p>我们分析一下：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032359610.png"></p>
<p>100这台手机代表你。而200、300、400这三台代表你好友的手机。在这里有一些东西需要交代一下，因为我们每个人的都会对自己的微信中的一些比较重要的人设置会话置顶，将他的那条对话放在最上面。我们假定这个人有两个会话置顶的好友，分别是400和500，而这里边就包含400.</p>
<p>下面呢，我们就来发这个消息，第一个发消息的是300，他发了个消息给100。发完以后，这个东西应该怎么存储呢？在这里面一定要分开，记录置顶的这些人的会话，对应的会话显示顺序和非置顶的一定要分两。</p>
<p>这里面我们创建两个模型，一个是普通的，一个是置顶的，而上面的这个置顶的用户呢，我们用set来存储，因为不重复。而下面这些因为有顺序，很容易想到用list去存储,不然你怎么表达顺序呢？</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040000639.png"></p>
<p>那当300发给消息给100以后，这个时候我们先判定你在置顶人群中吗？不在,那好，300的消息对应的顺序就应该放在普通的列表里边。而在这里边，我们把300加进去。第一个数据也就是现在300。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040000003.png"></p>
<p>接下来400，发了个消息。判断一下，他是需要置顶的，所以400将进入list的置顶里边放着。当前还没有特殊的地方。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040001285.png"></p>
<p>再来200发消息了，和刚才的判定方法一样，先看在不在置顶里，不在的话进普通，然后在普通里边把200加入就行了，OK，到这里目前还没有顺序变化。</p>
<p>接下来200又发消息过来，同一个人给你连发了两条，那这个时候200的消息到达以后，先判断是否在置顶范围，不在，接下来他要放在list普通中，这里你要注意一点，因为这里边已经有200，所以进来以后先干一件事儿，把200杀掉，没有200，然后再把200加进来，那你想一下，现在这个位置顺序是什么呢？就是新的都在右边，对不对？</p>
<p>还记得我们说list模型，如果是一个双端队列，它是可以两头进两头出。当然我们双端从一头进一头出，这就是栈模型，现在咱们运用的就是list模型中的栈模型。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040001577.png"></p>
<p>现在300发消息，先判定他在不在，不在，用普通的队列，接下来按照刚才的操作，不管你里边原来有没有300，我先把300杀掉，没了，200自然就填到300的位置了，他现在是list里面唯一一个，然后让300进来，注意是从右侧进来的，那么现在300就是最新的。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040001364.png"></p>
<p>那么到这里呢，我们让100来读取消息。你觉得这个消息顺序应该是什么样的？首先置顶的400有一个，他跑在最上面，然后list普通如果出来的话，300是最新的消息，而200在他后面的。用这种形式，我们就可以做出来他的消息顺序来。</p>
<h4 id="2-14-2-解决方案"><a href="#2-14-2-解决方案" class="headerlink" title="2.14.2  解决方案"></a>2.14.2  解决方案</h4><p>看一下最终的解决方案：</p>
<p>依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用</p>
<p>置顶与普通会话分别创建独立的list分别管理</p>
<p>当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）</p>
<p>多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id</p>
<p>推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据<br>消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新</p>
<h4 id="2-14-3-数据类型总结"><a href="#2-14-3-数据类型总结" class="headerlink" title="2.14.3  数据类型总结"></a>2.14.3  数据类型总结</h4><p>总结一下，在整个数据类型的部分，我们主要介绍了哪些内容：</p>
<p>首先我们了解了一下数据类型，接下来针对着我们要学习的数据类型，进行逐一讲解了string、hash、list、set等，最后通过一个案例总结了一下前面的数据类型的使用场景。</p>
<h2 id="3-常用指令"><a href="#3-常用指令" class="headerlink" title="3. 常用指令"></a>3. 常用指令</h2><p>在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西:</p>
<h3 id="3-1-key-操作分析"><a href="#3-1-key-操作分析" class="headerlink" title="3.1  key 操作分析"></a>3.1  key 操作分析</h3><h4 id="3-1-1-key应该设计哪些操作？"><a href="#3-1-1-key应该设计哪些操作？" class="headerlink" title="3.1.1  key应该设计哪些操作？"></a>3.1.1  key应该设计哪些操作？</h4><p>key是一个字符串，通过key获取redis中保存的数据</p>
<p>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</p>
<p>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</p>
<p>对于key快速查询操作，例如：按指定策略查询key</p>
<h4 id="3-1-2-key-基本操作"><a href="#3-1-2-key-基本操作" class="headerlink" title="3.1.2  key 基本操作"></a>3.1.2  key 基本操作</h4><p>删除指定key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure>

<p>获取key是否存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure>

<p>获取key的类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> key</span><br></pre></td></tr></table></figure>

<p>3.1.3  拓展操作</p>
<p>排序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span></span><br></pre></td></tr></table></figure>

<p>改名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-key-扩展操作（时效性控制）"><a href="#3-1-3-key-扩展操作（时效性控制）" class="headerlink" title="3.1.3  key 扩展操作（时效性控制）"></a>3.1.3  key 扩展操作（时效性控制）</h4><p>为指定key设置有效期</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure>

<p>获取key的有效时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure>

<p>切换key从时效性转换为永久性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-key-扩展操作（查询模式）"><a href="#3-1-4-key-扩展操作（查询模式）" class="headerlink" title="3.1.4  key 扩展操作（查询模式）"></a>3.1.4  key 扩展操作（查询模式）</h4><p>查询key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure>

<p>查询模式规则</p>
<p>*匹配任意数量的任意符号      ?    配合一个任意符号    []    匹配一个指定符号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys *  keys    查询所有</span><br><span class="line">it*  keys       查询所有以it开头</span><br><span class="line">*heima          查询所有以heima结尾</span><br><span class="line">keys ??heima    查询所有前面两个字符任意，后面以heima结尾 查询所有以</span><br><span class="line">keys user:?     user:开头，最后一个字符任意</span><br><span class="line">keys u[st]er:1  查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span><br></pre></td></tr></table></figure>

<h3 id="3-2-数据库指令"><a href="#3-2-数据库指令" class="headerlink" title="3.2  数据库指令"></a>3.2  数据库指令</h3><h4 id="3-2-1-key-的重复问题"><a href="#3-2-1-key-的重复问题" class="headerlink" title="3.2.1  key 的重复问题"></a>3.2.1  key 的重复问题</h4><p>在这个地方我们来讲一下数据库的常用指令，在讲这个东西之前，我们先思考一个问题：</p>
<p>假如说你们十个人同时操作redis，会不会出现key名字命名冲突的问题。</p>
<p>一定会，为什么?因为你的key是由程序而定义的。你想写什么写什么，那在使用的过程中大家都在不停的加，早晚有一天他会冲突的。</p>
<p>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。</p>
<p>那这个问题我们要不要解决？要！怎么解决呢？我们最好把数据进行一个分类，除了命名规范我们做统一以外，如果还能把它分开，这样是不是冲突的机率就会小一些了，这就是咱们下面要说的解决方案！</p>
<h4 id="3-2-2-解决方案"><a href="#3-2-2-解决方案" class="headerlink" title="3.2.2  解决方案"></a>3.2.2  解决方案</h4><p>redis为每个服务提供有16个数据库，编号从0到15</p>
<p>每个数据库之间的数据相互独立</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040002770.png"></p>
<p>在对应的数据库中划出一块区域，说他就是几，你就用几那块，同时，其他的这些都可以进行定义，一共是16个，这里边需要注意一点，他们这16个共用redis的内存。没有说谁大谁小，也就是说数字只是代表了一块儿区域，区域具体多大未知。这是数据库的一个分区的一个策略！</p>
<h4 id="3-2-3-数据库的基本操作"><a href="#3-2-3-数据库的基本操作" class="headerlink" title="3.2.3   数据库的基本操作"></a>3.2.3   数据库的基本操作</h4><p>切换数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure>

<p>其他操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-数据库扩展操作"><a href="#3-2-4-数据库扩展操作" class="headerlink" title="3.2.4  数据库扩展操作"></a>3.2.4  数据库扩展操作</h4><p>数据移动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure>

<p>数据总量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>

<p>数据清除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb  flushall</span><br></pre></td></tr></table></figure>

<h2 id="4-Jedis"><a href="#4-Jedis" class="headerlink" title="4. Jedis"></a>4. Jedis</h2><p>在学习完redis后，我们现在就要用Java来连接redis了，也就是我们的这一章要学的Jedis了。在这个部分，我们主要讲解以下3个内容：</p>
<p>HelloWorld（Jedis版）</p>
<p>Jedis简易工具类开发</p>
<p>可视化客户端</p>
<h3 id="4-1-Jedis简介"><a href="#4-1-Jedis简介" class="headerlink" title="4.1  Jedis简介"></a>4.1  Jedis简介</h3><h4 id="4-1-1-编程语言与redis"><a href="#4-1-1-编程语言与redis" class="headerlink" title="4.1.1  编程语言与redis"></a>4.1.1  编程语言与redis</h4><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040002555.png"></p>
<p>对于我们现在的数据来说，它是在我们的redis中，而最终我们是要做程序。那么程序就要和我们的redis进行连接。干什么事情呢？两件事：程序中有数据的时候，我们要把这些数据全部交给redis管理。同时，redis中的数据还能取出来，回到我们的应用程序中。那在这个过程中，在Java与redis之间打交道的这个东西就叫做Jedis.简单说，Jedis就是提供了Java与redis的连接服务的，里边有各种各样的API接口，你可以去调用它。</p>
<p>除了Jedis外，还有没有其他的这种连接服务呢？其实还有很多，了解一下：</p>
<p>Java语言连接redis服务 Jedis（SpringData、Redis 、 Lettuce）</p>
<p>其它语言：C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala</p>
<h4 id="4-1-2-准备工作"><a href="#4-1-2-准备工作" class="headerlink" title="4.1.2  准备工作"></a>4.1.2  准备工作</h4><p>(1)jar包导入</p>
<p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a></p>
<p>基于maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2)客户端连接redis</p>
<p>连接redis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure>

<p>操作redis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.set(&quot;name&quot;, &quot;itheima&quot;);  jedis.get(&quot;name&quot;);</span><br></pre></td></tr></table></figure>

<p>关闭redis连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<p>API文档</p>
<p><a href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a></p>
<h4 id="4-1-3-代码实现"><a href="#4-1-3-代码实现" class="headerlink" title="4.1.3 代码实现"></a>4.1.3 代码实现</h4><p>创建：com.itheima.JedisTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.40.130&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2.执行操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;39&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = jedis.lrange(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:list1 ) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;poi&quot;</span>,<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">len</span> <span class="operator">=</span> jedis.scard(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="comment">//3.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-Jedis简易工具类开发"><a href="#4-2-Jedis简易工具类开发" class="headerlink" title="4.2  Jedis简易工具类开发"></a>4.2  Jedis简易工具类开发</h3><p>前面我们做的程序还是有点儿小问题，就是我们的Jedis对象的管理是我们自己创建的，真实企业开发中是不可能让你去new一个的，那接下来咱们就要做一个工具类，简单来说，就是做一个创建Jedis的这样的一个工具。</p>
<h4 id="4-2-1-基于连接池获取连接"><a href="#4-2-1-基于连接池获取连接" class="headerlink" title="4.2.1  基于连接池获取连接"></a>4.2.1  基于连接池获取连接</h4><p>JedisPool：Jedis提供的连接池技术 </p>
<p>poolConfig:连接池配置对象 </p>
<p>host:redis服务地址</p>
<p>port:redis服务端口号</p>
<p>JedisPool的构造器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (String)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-封装连接参数"><a href="#4-2-2-封装连接参数" class="headerlink" title="4.2.2  封装连接参数"></a>4.2.2  封装连接参数</h4><p>创建jedis的配置文件：jedis.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jedis.host</span>=<span class="string">192.168.40.130  </span></span><br><span class="line"><span class="attr">jedis.port</span>=<span class="string">6379  </span></span><br><span class="line"><span class="attr">jedis.maxTotal</span>=<span class="string">50  </span></span><br><span class="line"><span class="attr">jedis.maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-加载配置信息"><a href="#4-2-3-加载配置信息" class="headerlink" title="4.2.3  加载配置信息"></a>4.2.3  加载配置信息</h4><p> 创建JedisUtils：com.itheima.util.JedisUtils，使用静态代码块初始化资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxIdel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jpc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        maxTotal = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">        maxIdel = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxIdel&quot;</span>));</span><br><span class="line">        host = bundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">        port = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line">        <span class="comment">//Jedis连接池配置</span></span><br><span class="line">        jpc = <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jpc.setMaxTotal(maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdel);</span><br><span class="line">        jp = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jpc,host,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-获取连接"><a href="#4-2-4-获取连接" class="headerlink" title="4.2.4  获取连接"></a>4.2.4  获取连接</h4><p> 对外访问接口，提供jedis连接对象，连接从连接池获取，在JedisUtils中添加一个获取jedis的方法：getJedis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">	<span class="keyword">return</span> jedis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-可视化客户端"><a href="#4-3-可视化客户端" class="headerlink" title="4.3  可视化客户端"></a>4.3  可视化客户端</h3><p>4.3.1  Redis Desktop Manager</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040003545.png"></p>
<h2 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5. 持久化"></a>5. 持久化</h2><p>下面呢，进入到持久化的学习.这部分内容理解的东西多，操作的东西少。在这个部分，我们将讲解四个东西：</p>
<p>持久化简介</p>
<p>RDB</p>
<p>AOF</p>
<p>RDB与AOF区别</p>
<h3 id="5-1-持久化简介"><a href="#5-1-持久化简介" class="headerlink" title="5.1  持久化简介"></a>5.1  持久化简介</h3><h4 id="5-1-1-场景-意外断电"><a href="#5-1-1-场景-意外断电" class="headerlink" title="5.1.1  场景-意外断电"></a>5.1.1  场景-意外断电</h4><p>不知道大家有没有遇见过，就是正工作的时候停电了，如果你用的是笔记本电脑还好，你有电池，但如果你用的是台式机呢，那恐怕就比较灾难了，假如你现在正在写一个比较重要的文档，如果你要使用的是word，这种办公自动化软件的话，他一旦遇到停电，其实你不用担心，因为它会给你生成一些其他的文件。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040003682.png"></p>
<p>其实他们都在做一件事儿，帮你自动恢复，有了这个文件，你前面的东西就不再丢了。那什么是自动恢复呢？你要先了解他的整个过程。</p>
<p>我们说自动恢复，其实基于的一个前提就是他提前把你的数据给存起来了。你平常操作的所有信息都是在内存中的，而我们真正的信息是保存在硬盘中的，内存中的信息断电以后就消失了，硬盘中的信息断电以后还可以保留下来！</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040004614.png"></p>
<p>我们将文件由内存中保存到硬盘中的这个过程，我们叫做数据保存，也就叫做持久化。但是把它保存下来不是你的目的，最终你还要把它再读取出来，它加载到内存中这个过程，我们叫做数据恢复，这就是我们所说的word为什么断电以后还能够给你保留文件，因为它执行了一个自动备份的过程，也就是通过自动的形式，把你的数据存储起来，那么有了这种形式以后，我们的数据就可以由内存到硬盘上实现保存。</p>
<h4 id="5-1-2-什么是持久化"><a href="#5-1-2-什么是持久化" class="headerlink" title="5.1.2  什么是持久化"></a>5.1.2  什么是持久化</h4><p>(1)什么是持久化</p>
<p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 。</p>
<p>持久化用于防止数据的意外丢失，确保数据安全性。</p>
<p>(2)持久化过程保存什么？</p>
<p>我们知道一点，计算机中的数据全部都是二进制，如果现在我要你给我保存一组数据的话，你有什么样的方式呢，其实最简单的就是现在长什么样，我就记下来就行了，那么这种是记录纯粹的数据，也叫做快照存储，也就是它保存的是某一时刻的数据状态。</p>
<p>还有一种形式，它不记录你的数据，它记录你所有的操作过程，比如说大家用idea的时候，有没有遇到过写错了ctrl+z撤销，然后ctrl+y还能恢复，这个地方它也是在记录，但是记录的是你所有的操作过程，那我想问一下，操作过程，我都给你留下来了，你说数据还会丢吗？肯定不会丢，因为你所有的操作过程我都保存了。这种保存操作过程的存储，用专业术语来说可以说是日志，这是两种不同的保存数据的形式啊。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040004627.png"></p>
<p>总结一下：</p>
<p>第一种：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。</p>
<p>第二种：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。</p>
<h3 id="5-2-RDB"><a href="#5-2-RDB" class="headerlink" title="5.2  RDB"></a>5.2  RDB</h3><h4 id="5-2-1-save指令"><a href="#5-2-1-save指令" class="headerlink" title="5.2.1  save指令"></a>5.2.1  save指令</h4><p>手动执行一次保存操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure>

<p><strong>save指令相关配置</strong></p>
<p>设置本地数据库文件名，默认值为 dump.rdb，通常设置为dump-端口号.rdb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbfilename filename</span><br></pre></td></tr></table></figure>

<p>设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir path</span><br></pre></td></tr></table></figure>

<p>设置存储至本地数据库时是否压缩数据，默认yes，设置为no，节省 CPU 运行时间，但存储文件变大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbcompression yes|no</span><br></pre></td></tr></table></figure>

<p>设置读写文件过程是否进行RDB格式校验，默认yes，设置为no，节约读写10%时间消耗，单存在数据损坏的风险</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbchecksum yes|no</span><br></pre></td></tr></table></figure>

<p><strong>save指令工作原理</strong></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040004782.png"></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040005022.png"></p>
<p>需要注意一个问题，来看一下，现在有四个客户端各自要执行一个指令，把这些指令发送到redis服务器后，他们执行有一个先后顺序问题，假定就是按照1234的顺序放过去的话，那会是什么样的？</p>
<p>记得redis是个单线程的工作模式，它会创建一个任务队列，所有的命令都会进到这个队列里边，在这儿排队执行，执行完一个消失一个，当所有的命令都执行完了，OK，结果达到了。</p>
<p>但是如果现在我们执行的时候save指令保存的数据量很大会是什么现象呢？</p>
<p>他会非常耗时，以至于影响到它在执行的时候，后面的指令都要等，所以说这种模式是不友好的，这是save指令对应的一个问题，当cpu执行的时候会阻塞redis服务器，直到他执行完毕，所以说我们不建议大家在线上环境用save指令。</p>
<h4 id="5-2-2-bgsave指令"><a href="#5-2-2-bgsave指令" class="headerlink" title="5.2.2  bgsave指令"></a>5.2.2  bgsave指令</h4><p>之前我们讲到了当save指令的数据量过大时，单线程执行方式造成效率过低，那应该如何处理？</p>
<p>此时我们可以使用：<strong>bgsave</strong>指令，bg其实是background的意思，后台执行的意思</p>
<p>手动启动后台保存操作，但不是立即执行</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bgsave</span></span><br></pre></td></tr></table></figure>

<p><strong>bgsave指令相关配置</strong></p>
<p>后台存储过程中如果出现错误现象，是否停止保存操作，默认yes</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">stop-writes-on-bgsave-error</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<p>其 他</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dbfilename</span> <span class="string">filename  </span></span><br><span class="line"><span class="attr">dir</span> <span class="string">path  </span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes|no  </span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<p><strong>bgsave指令工作原理</strong></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040005685.png"></p>
<p>当执行bgsave的时候，客户端发出bgsave指令给到redis服务器。注意，这个时候服务器马上回一个结果告诉客户端后台已经开始了，与此同时它会创建一个子进程，使用Linux的fork函数创建一个子进程，让这个子进程去执行save相关的操作，此时我们可以想一下，我们主进程一直在处理指令，而子进程在执行后台的保存，它会不会干扰到主进程的执行吗？</p>
<p>答案是不会，所以说他才是主流方案。子进程开始执行之后，它就会创建啊RDB文件把它存起来，操作完以后他会把这个结果返回，也就是说bgsave的过程分成两个过程，第一个是服务端拿到指令直接告诉客户端开始执行了；另外一个过程是一个子进程在完成后台的保存操作，操作完以后回一个消息。</p>
<h4 id="5-2-3-save配置自动执行"><a href="#5-2-3-save配置自动执行" class="headerlink" title="5.2.3 save配置自动执行"></a>5.2.3 save配置自动执行</h4><p>设置自动持久化的条件，满足限定时间范围内key的变化数量达到指定数量即进行持久化</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">save</span> <span class="string">second changes</span></span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>second：监控时间范围</p>
<p>changes：监控key的变化量</p>
<p>范例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>其他相关配置：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dbfilename filename</span><br><span class="line">dir path</span><br><span class="line">rdbcompression yes|no</span><br><span class="line">rdbchecksum yes|no</span><br><span class="line">stop-writes-on-bgsave-error yes|no</span><br></pre></td></tr></table></figure>

<p><strong>save配置工作原理</strong></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040005513.png"></p>
<h4 id="5-2-4-RDB三种启动方式对比"><a href="#5-2-4-RDB三种启动方式对比" class="headerlink" title="5.2.4 RDB三种启动方式对比"></a>5.2.4 RDB三种启动方式对比</h4><table>
<thead>
<tr>
<th>方式</th>
<th>save指令</th>
<th>bgsave指令</th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>启动新进程</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>RDB特殊启动形式</strong></p>
<p>服务器运行过程中重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure>

<p>关闭服务器时指定保存数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure>

<p>全量复制（在主从复制中详细讲解）</p>
<p><strong>RDB优点：</strong></p>
<ul>
<li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据的速度要比AOF快很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li>
</ul>
<p><strong>RDB缺点</strong></p>
<ul>
<li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
<h3 id="5-3-AOF"><a href="#5-3-AOF" class="headerlink" title="5.3  AOF"></a>5.3  AOF</h3><p>为什么要有AOF,这得从RDB的存储的弊端说起：</p>
<ul>
<li>存储数据量较大，效率较低，基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li>
<li>大数据量下的IO性能较低</li>
<li>基于fork创建子进程，内存产生额外消耗</li>
<li>宕机带来的数据丢失风险</li>
</ul>
<p>那解决的思路是什么呢？</p>
<ul>
<li>不写全数据，仅记录部分数据</li>
<li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li>
<li>对所有操作均进行记录，排除丢失数据的风险</li>
</ul>
<h4 id="5-3-1-AOF概念"><a href="#5-3-1-AOF概念" class="headerlink" title="5.3.1 AOF概念"></a>5.3.1 AOF概念</h4><p><strong>AOF</strong>(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。<strong>与RDB相比可以简单理解为由记录数据改为记录数据产生的变化</strong></p>
<p>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p>
<p><strong>AOF写数据过程</strong></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040006065.png"></p>
<p><strong>启动AOF相关配置</strong></p>
<p>开启AOF持久化功能，默认no，即不开启状态</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">appendonly</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<p>AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">appendfilename</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure>

<p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dir</span></span><br></pre></td></tr></table></figure>

<p>AOF写数据策略，默认为everysec</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">appendfsync</span> <span class="string">always|everysec|no</span></span><br></pre></td></tr></table></figure>



<h4 id="5-3-2-AOF执行策略"><a href="#5-3-2-AOF执行策略" class="headerlink" title="5.3.2 AOF执行策略"></a>5.3.2 AOF执行策略</h4><p>AOF写数据三种策略(appendfsync)</p>
<ul>
<li><strong>always</strong>(每次）：每次写入操作均同步到AOF文件中数据零误差，性能较低，不建议使用。</li>
</ul>
<ul>
<li><strong>everysec</strong>（每秒）：每秒将缓冲区中的指令同步到AOF文件中，在系统突然宕机的情况下丢失1秒内的数据 数据准确性较高，性能较高，建议使用，也是默认配置</li>
</ul>
<ul>
<li><strong>no</strong>（系统控制）：由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li>
</ul>
<h4 id="5-3-3-AOF重写"><a href="#5-3-3-AOF重写" class="headerlink" title="5.3.3 AOF重写"></a>5.3.3 AOF重写</h4><p>场景：AOF写数据遇到的问题，如果连续执行如下指令该如何处理</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040006782.png"></p>
<p><strong>什么叫AOF重写？</strong></p>
<p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录。</p>
<p><strong>AOF重写作用</strong></p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<p><strong>AOF重写规则</strong></p>
<ul>
<li>进程内具有时效性的数据，并且数据已超时将不再写入文件</li>
</ul>
<ul>
<li><p>非写入类的无效指令将被忽略，只保留最终数据的写入命令</p>
<p>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</p>
<p>如select指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录</p>
</li>
<li><p>对同一数据的多条写命令合并为一条命令</p>
</li>
</ul>
<p>如lpushlist1 a、lpush list1 b、lpush list1 c可以转化为：lpush list1 a b c。</p>
<p>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</p>
<p><strong>AOF重写方式</strong></p>
<ul>
<li>手动重写</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bgrewriteaof</span></span><br></pre></td></tr></table></figure>

<p><strong>手动重写原理分析：</strong></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040006229.png"></p>
<ul>
<li>自动重写</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">size</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">percentage</span></span><br></pre></td></tr></table></figure>

<p>自动重写触发条件设置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">size</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">percent</span></span><br></pre></td></tr></table></figure>

<p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">aof_current_size</span>  <span class="string"></span></span><br><span class="line"><span class="attr">aof_base_size</span></span><br></pre></td></tr></table></figure>

<p> 自动重写触发条件公式：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007155.png"></p>
<h4 id="5-3-4-AOF工作流程及重写流程"><a href="#5-3-4-AOF工作流程及重写流程" class="headerlink" title="5.3.4 AOF工作流程及重写流程"></a>5.3.4 AOF工作流程及重写流程</h4><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007616.png"></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007514.png"></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007420.png"></p>
<h3 id="5-4-RDB与AOF区别"><a href="#5-4-RDB与AOF区别" class="headerlink" title="5.4  RDB与AOF区别"></a>5.4  RDB与AOF区别</h3><h4 id="5-4-1-RDB与AOF对比（优缺点）"><a href="#5-4-1-RDB与AOF对比（优缺点）" class="headerlink" title="5.4.1 RDB与AOF对比（优缺点）"></a>5.4.1 RDB与AOF对比（优缺点）</h4><table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用存储空间</td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重写）</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h4 id="5-4-2-RDB与AOF应用场景"><a href="#5-4-2-RDB与AOF应用场景" class="headerlink" title="5.4.2 RDB与AOF应用场景"></a>5.4.2 RDB与AOF应用场景</h4><p>RDB与AOF的选择之惑</p>
<ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案</li>
</ul>
<p>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。</p>
<p>注意：由于AOF文件存储体积较大，且恢复速度较慢</p>
<ul>
<li>数据呈现阶段有效性，建议使用RDB持久化方案</li>
</ul>
<p>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案</p>
<p>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</p>
<p><strong>综合比对</strong></p>
<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，同时开启 RDB和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Redis高级</title>
    <url>/2022/08/01/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Redis%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="第二章：Redis高级"><a href="#第二章：Redis高级" class="headerlink" title="第二章：Redis高级"></a>第二章：Redis高级</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>目标1：能够说出redis中的数据删除策与略淘汰策略</p>
<p>目标2：能够说出主从复制的概念，工作流程以及场景问题及解决方案</p>
<p>目标3：能够说出哨兵的作用以及工作原理，以及如何启用哨兵</p>
<p>目标4：能够说出集群的架构设计，完成集群的搭建</p>
<p>目标5：能够说出缓存预热，雪崩，击穿，穿透的概念，能说出redis的相关监控指标</p>
<h2 id="1-数据删除与淘汰策略"><a href="#1-数据删除与淘汰策略" class="headerlink" title="1.数据删除与淘汰策略"></a>1.数据删除与淘汰策略</h2><h3 id="1-1-过期数据"><a href="#1-1-过期数据" class="headerlink" title="1.1 过期数据"></a>1.1 过期数据</h3><h4 id="1-1-1-Redis中的数据特征"><a href="#1-1-1-Redis中的数据特征" class="headerlink" title="1.1.1 Redis中的数据特征"></a><strong>1.1.1 Redis中的数据特征</strong></h4><p>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态</p>
<p>TTL返回的值有三种情况：正数，-1，-2</p>
<ul>
<li><strong>正数</strong>：代表该数据在内存中还能存活的时间</li>
<li><strong>-1</strong>：永久有效的数据</li>
<li><strong>2</strong> ：已经过期的数据 或被删除的数据 或 未定义的数据</li>
</ul>
<p><strong>删除策略就是针对已过期数据的处理策略</strong>，已过期的数据是真的就立即删除了吗？其实也不是，我们会有多种删除策略，是分情况的，在不同的场景下使用不同的删除方式会有不同效果，这也正是我们要将的数据的删除策略的问题</p>
<h4 id="1-1-2-时效性数据的存储结构"><a href="#1-1-2-时效性数据的存储结构" class="headerlink" title="1.1.2 时效性数据的存储结构"></a>1.1.2 时效性数据的存储结构</h4><p>在Redis中，如何给数据设置它的失效周期呢？数据的时效在redis中如何存储呢？看下图：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032338242.png"></p>
<p>过期数据是一块独立的存储空间，Hash结构，field是内存地址，value是过期时间，保存了所有key的过期描述，在最终进行过期处理的时候，对该空间的数据进行检测， 当时间到期之后通过field找到内存该地址处的数据，然后进行相关操作。</p>
<h3 id="1-2-数据删除策略"><a href="#1-2-数据删除策略" class="headerlink" title="1.2 数据删除策略"></a>1.2 数据删除策略</h3><h4 id="1-2-1-数据删除策略的目标"><a href="#1-2-1-数据删除策略的目标" class="headerlink" title="1.2.1 数据删除策略的目标"></a>1.2.1 数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或 内存泄露</p>
<p>针对过期数据要进行删除的时候都有哪些删除策略呢？</p>
<ul>
<li>1.定时删除</li>
<li>2.惰性删除</li>
<li>3.定期删除</li>
</ul>
<h4 id="1-2-2-定时删除"><a href="#1-2-2-定时删除" class="headerlink" title="1.2.2 定时删除"></a>1.2.2 定时删除</h4><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
<ul>
<li><strong>优点</strong>：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li><strong>缺点</strong>：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li><strong>总结</strong>：用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339557.png"></p>
<h4 id="1-2-3-惰性删除"><a href="#1-2-3-惰性删除" class="headerlink" title="1.2.3 惰性删除"></a>1.2.3 惰性删除</h4><p>数据到达过期时间，不做处理。等下次访问该数据时，我们需要判断</p>
<ol>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ol>
<ul>
<li><strong>优点</strong>：节约CPU性能，发现必须删除的时候才删除</li>
<li><strong>缺点</strong>：内存压力很大，出现长期占用内存的数据</li>
<li><strong>总结</strong>：用存储空间换取处理器性能（拿时间换空间）</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339637.png"></p>
<h4 id="1-2-4-定期删除"><a href="#1-2-4-定期删除" class="headerlink" title="1.2.4 定期删除"></a>1.2.4 定期删除</h4><p>定时删除和惰性删除这两种方案都是走的极端，那有没有折中方案？</p>
<p>我们来讲redis的定期删除方案：</p>
<ul>
<li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p>
</li>
<li><p>每秒钟执行server.hz次<strong>serverCron()</strong>——–&gt;<strong>databasesCron()</strong>———&gt;<strong>activeExpireCycle()</strong></p>
</li>
<li><p>**activeExpireCycle()*<em>对每个expires[</em>]逐一进行检测，每次执行耗时：250ms/server.hz</p>
</li>
<li><p>对某个expires[*]检测时，随机挑选W个key检测</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果key超时，删除key</span><br><span class="line"></span><br><span class="line">如果一轮中删除的key的数量&gt;W<span class="emphasis">*25%，循环该过程</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果一轮中删除的key的数量≤W*</span>25%，检查下一个expires[<span class="emphasis">*]，0-15循环</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数current_db用于记录<strong>activeExpireCycle()</strong> 进入哪个expires[*] 执行</p>
</li>
<li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行</p>
</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339400.png"></p>
<p>总的来说：定期删除就是周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p>
<ul>
<li><strong>特点1</strong>：CPU性能占用设置有峰值，检测频度可自定义设置</li>
<li><strong>特点2</strong>：内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
<li><strong>总结</strong>：周期性抽查存储空间（随机抽查，重点抽查）</li>
</ul>
<h4 id="1-2-5-删除策略对比"><a href="#1-2-5-删除策略对比" class="headerlink" title="1.2.5 删除策略对比"></a>1.2.5 删除策略对比</h4><p>1：定时删除：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">节约内存，无占用,</span><br><span class="line">不分时段占用CPU资源，频度高,</span><br><span class="line">拿时间换空间</span><br></pre></td></tr></table></figure>

<p>2：惰性删除：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">内存占用严重</span><br><span class="line">延时执行，CPU利用率高</span><br><span class="line">拿空间换时间</span><br></pre></td></tr></table></figure>

<p>3：定期删除：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">内存定期随机清理</span><br><span class="line">每秒花费固定的CPU资源维护内存</span><br><span class="line">随机抽查，重点抽查</span><br></pre></td></tr></table></figure>

<h3 id="1-3-数据淘汰策略（逐出算法）"><a href="#1-3-数据淘汰策略（逐出算法）" class="headerlink" title="1.3 数据淘汰策略（逐出算法）"></a>1.3 数据淘汰策略（逐出算法）</h3><h4 id="1-3-1-淘汰策略概述"><a href="#1-3-1-淘汰策略概述" class="headerlink" title="1.3.1 淘汰策略概述"></a>1.3.1 淘汰策略概述</h4><p>什么叫数据淘汰策略？什么样的应用场景需要用到数据淘汰策略？</p>
<p>当新数据进入redis时，如果内存不足怎么办？在执行每一个命令前，会调用**freeMemoryIfNeeded()**检测内存是否充足。如果内存不满足新 加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</p>
<p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕，  如不能达到内存清理的要求，将出现错误信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(error) OOM command not allowed when used memory &gt;&#x27;maxmemory&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-策略配置"><a href="#1-3-2-策略配置" class="headerlink" title="1.3.2 策略配置"></a>1.3.2 策略配置</h4><p>影响数据淘汰的相关配置如下：</p>
<p>1：最大可使用内存，即占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure>

<p>2：每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory-samples</span> <span class="string">count</span></span><br></pre></td></tr></table></figure>

<p>3：对数据进行删除的选择策略</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">policy</span></span><br></pre></td></tr></table></figure>

<p>那数据删除的策略policy到底有几种呢？一共是<strong>3类8种</strong></p>
<p><strong>第一类</strong>：检测易失数据（可能会过期的数据集server.db[i].expires ）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">volatile-lru：挑选最近最少使用的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-lfu：挑选最近使用次数最少的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-ttl：挑选将要过期的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-random：任意选择数据淘汰</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339450.png"></p>
<p><strong>第二类</strong>：检测全库数据（所有数据集server.db[i].dict ）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">allkeys-lru：挑选最近最少使用的数据淘汰</span></span><br><span class="line"><span class="attr">allkeLyRs-lfu：：挑选最近使用次数最少的数据淘汰</span></span><br><span class="line"><span class="attr">allkeys-random：任意选择数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure>

<p><strong>第三类</strong>：放弃数据驱逐</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">no-enviction（驱逐）：禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out</span> <span class="string">Of Memory)</span></span><br></pre></td></tr></table></figure>

<p>注意：这些策略是配置到哪个属性上？怎么配置？如下所示</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">volatile-lru</span></span><br></pre></td></tr></table></figure>

<p><strong>数据淘汰策略配置依据</strong></p>
<p> 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p>
<h2 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h2><h3 id="2-1-主从复制简介"><a href="#2-1-主从复制简介" class="headerlink" title="2.1 主从复制简介"></a>2.1 主从复制简介</h3><h4 id="2-1-1-高可用"><a href="#2-1-1-高可用" class="headerlink" title="2.1.1 高可用"></a>2.1.1 高可用</h4><p>首先我们要理解互联网应用因为其独有的特性我们演化出的<strong>三高</strong>架构</p>
<ul>
<li><p>高并发</p>
<blockquote>
<p>应用要提供某一业务要能支持很多客户端同时访问的能力，我们称为并发，高并发意思就很明确了</p>
</blockquote>
</li>
<li><p>高性能</p>
<blockquote>
<p>性能带给我们最直观的感受就是：速度快，时间短</p>
</blockquote>
</li>
<li><p>高可用</p>
</li>
</ul>
<p><strong>可用性</strong>：一年中应用服务正常运行的时间占全年时间的百分比，如下图：表示了应用服务在全年宕机的时间</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339749.png"></p>
<p>我们把这些时间加在一起就是全年应用服务不可用的时间，然后我们可以得到应用服务全年可用的时间</p>
<blockquote>
<p>4小时27分15秒+11分36秒+2分16秒=4小时41分7秒=16867秒</p>
<p>1年=365<em>24</em>60*60=31536000秒</p>
<p>可用性=（31536000-16867）/31536000*100%=99.9465151%</p>
</blockquote>
<p>业界可用性目标**5个9，即99.999%**，即服务器年宕机时长低于315秒，约5.25分钟</p>
<h4 id="2-1-2-主从复制概念"><a href="#2-1-2-主从复制概念" class="headerlink" title="2.1.2 主从复制概念"></a>2.1.2 主从复制概念</h4><p>知道了三高的概念之后，我们想：你的“Redis”是否高可用？那我们要来分析单机redis的风险与问题</p>
<p>问题1.机器故障</p>
<ul>
<li>现象：硬盘故障、系统崩溃</li>
<li>本质：数据丢失，很可能对业务造成灾难性打击</li>
<li>结论：基本上会放弃使用redis.</li>
</ul>
<p>问题2.容量瓶颈</p>
<ul>
<li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li>
<li>本质：穷，硬件条件跟不上</li>
<li>结论：放弃使用redis</li>
</ul>
<p>结论：</p>
<p>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</p>
<p>多台服务器连接方案：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339819.png"></p>
<ul>
<li>提供数据方：<strong>master</strong></li>
</ul>
<p>主服务器，主节点，主库主客户端</p>
<ul>
<li>接收数据方：<strong>slave</strong></li>
</ul>
<p>从服务器，从节点，从库</p>
<p>从客户端</p>
<ul>
<li>需要解决的问题：</li>
</ul>
<p>数据同步（master的数据复制到slave中）</p>
<p>这里我们可以来解释主从复制的概念：</p>
<p><strong>概念：主从复制即将master中的数据即时、有效的复制到slave中</strong></p>
<p><strong>特征</strong>：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p><strong>职责</strong>：master和slave各自的职责不一样</p>
<p>master:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">写数据</span><br><span class="line"></span><br><span class="line">执行写操作时，将出现变化的数据自动同步到slave</span><br><span class="line"></span><br><span class="line">读数据（可忽略）</span><br></pre></td></tr></table></figure>

<p>slave:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">读数据</span><br><span class="line"></span><br><span class="line">写数据（禁止）</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-主从复制的作用"><a href="#2-1-3-主从复制的作用" class="headerlink" title="2.1.3 主从复制的作用"></a>2.1.3 主从复制的作用</h4><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h3 id="2-2-主从复制工作流程"><a href="#2-2-主从复制工作流程" class="headerlink" title="2.2 主从复制工作流程"></a>2.2 主从复制工作流程</h3><p>主从复制过程大体可以分为3个阶段</p>
<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段（反复同步）</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339463.png"></p>
<p>而命令的传播其实有4种，分别如下：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339043.png"></p>
<h4 id="2-2-1-主从复制的工作流程（三个阶段）"><a href="#2-2-1-主从复制的工作流程（三个阶段）" class="headerlink" title="2.2.1 主从复制的工作流程（三个阶段）"></a>2.2.1 主从复制的工作流程（三个阶段）</h4><h5 id="2-2-1-1-阶段一：建立连接"><a href="#2-2-1-1-阶段一：建立连接" class="headerlink" title="2.2.1.1 阶段一：建立连接"></a>2.2.1.1 阶段一：建立连接</h5><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p>
<p>流程如下：</p>
<ol>
<li>步骤1：设置master的地址和端口，保存master信息</li>
<li>步骤2：建立socket连接</li>
<li>步骤3：发送ping命令（定时器任务）</li>
<li>步骤4：身份验证</li>
<li>步骤5：发送slave端口信息</li>
</ol>
<p>至此，主从连接成功！</p>
<p>当前状态：</p>
<p>slave：保存master的地址与端口</p>
<p>master：保存slave的端口</p>
<p>总体：之间创建了连接的socket</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340745.png"></p>
<p><strong>master和slave互联</strong></p>
<p>接下来就要通过某种方式将master和slave连接到一起</p>
<p>方式一：客户端发送命令</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">masterip masterport</span></span><br></pre></td></tr></table></figure>

<p>方式二：启动服务器参数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-server</span> <span class="string">--slaveof masterip masterport</span></span><br></pre></td></tr></table></figure>

<p>方式三：服务器配置（<strong>主流方式</strong>）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">masterip masterport</span></span><br></pre></td></tr></table></figure>

<p>slave系统信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">master_link_down_since_seconds</span></span><br><span class="line"><span class="attr">masterhost</span> <span class="string">&amp; masterport</span></span><br></pre></td></tr></table></figure>

<p>master系统信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">uslave_listening_port(多个)</span></span><br></pre></td></tr></table></figure>

<p><strong>主从断开连接</strong></p>
<p>断开slave与master的连接，slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">no one</span></span><br></pre></td></tr></table></figure>

<p><strong>授权访问</strong></p>
<p>master客户端发送命令设置密码</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">requirepass</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>master配置文件设置密码</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">config</span> <span class="string">set requirepass password</span></span><br><span class="line"><span class="attr">config</span> <span class="string">get requirepass</span></span><br></pre></td></tr></table></figure>

<p>slave客户端发送命令设置密码</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">auth</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>slave配置文件设置密码</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">masterauth</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>slave启动服务器设置密码</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-server</span> <span class="string">–a password</span></span><br></pre></td></tr></table></figure>



<h5 id="2-2-1-2-阶段二：数据同步"><a href="#2-2-1-2-阶段二：数据同步" class="headerlink" title="2.2.1.2 阶段二：数据同步"></a>2.2.1.2 阶段二：数据同步</h5><ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li>将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<p>同步过程如下：</p>
<ol>
<li>步骤1：请求同步数据</li>
<li>步骤2：创建RDB同步数据</li>
<li>步骤3：恢复RDB同步数据</li>
<li>步骤4：请求部分同步数据</li>
<li>步骤5：恢复部分同步数据</li>
</ol>
<p>至此，数据同步工作完成！</p>
<p>当前状态：</p>
<p>slave：具有master端全部数据，包含RDB过程接收的数据</p>
<p>master：保存slave当前数据同步的位置</p>
<p>总体：之间完成了数据克隆</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340237.png"></p>
<p><strong>数据同步阶段master说明</strong></p>
<p>1：如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
<p>2：复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">repl-backlog-size</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li>
</ol>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340078.png"></p>
<p><strong>数据同步阶段slave说明</strong></p>
<ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">slave-serve-stale-data</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择</p>
</li>
</ol>
<h5 id="2-2-1-3-阶段三：命令传播"><a href="#2-2-1-3-阶段三：命令传播" class="headerlink" title="2.2.1.3 阶段三：命令传播"></a>2.2.1.3 阶段三：命令传播</h5><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
</ul>
<p><strong>命令传播阶段的部分复制</strong></p>
<p>命令传播阶段出现了断网现象：</p>
<p>网络闪断闪连：忽略</p>
<p>短时间网络中断：部分复制</p>
<p>长时间网络中断：全量复制</p>
<p>这里我们主要来看部分复制，部分复制的三个核心要素</p>
<ol>
<li>服务器的运行 id（run id）</li>
<li>主服务器的复制积压缓冲区</li>
<li>主从服务器的复制偏移量</li>
</ol>
<ul>
<li>服务器运行ID（runid）</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</span><br><span class="line"></span><br><span class="line">组成：运行id由40位字符组成，是一个随机的十六进制字符</span><br><span class="line">例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</span><br><span class="line"></span><br><span class="line">作用：运行id被用于在服务器间进行传输，识别身份</span><br><span class="line">如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</span><br><span class="line"></span><br><span class="line">实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，</span><br><span class="line">slave保存此ID，通过info Server命令，可以查看节点的runid</span><br></pre></td></tr></table></figure>

<ul>
<li>复制缓冲区</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</span><br><span class="line"><span class="code">	复制缓冲区默认数据存储空间大小是1M</span></span><br><span class="line"><span class="code">	当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</span></span><br><span class="line"><span class="code">作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340249.png"></p>
<p>复制缓冲区内部工作原理：</p>
<p>组成</p>
<ul>
<li><p>偏移量</p>
<blockquote>
<p>概念：一个数字，描述复制缓冲区中的指令字节位置</p>
<p>分类：</p>
<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
<p>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p>
<p>数据来源：</p>
<ul>
<li>master端：发送一次记录一次</li>
<li>slave端：接收一次记录一次</li>
</ul>
</blockquote>
</li>
<li><p>字节值</p>
</li>
</ul>
<p>工作原理</p>
<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340372.png"></p>
<h4 id="2-2-2-流程更新-全量复制-部分复制"><a href="#2-2-2-流程更新-全量复制-部分复制" class="headerlink" title="2.2.2 流程更新(全量复制/部分复制)"></a>2.2.2 流程更新(全量复制/部分复制)</h4><p>我们再次的总结一下主从复制的三个阶段的工作流程：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340838.png"></p>
<h4 id="2-2-3-心跳机制"><a href="#2-2-3-心跳机制" class="headerlink" title="2.2.3 心跳机制"></a>2.2.3 心跳机制</h4><p>什么是心跳机制？</p>
<p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p>
<p>master心跳：</p>
<ul>
<li>内部指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒</li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication  获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
<p>slave心跳任务</p>
<ul>
<li>内部指令：REPLCONF ACK {offset}</li>
<li>周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
<p>心跳阶段注意事项：</p>
<ul>
<li>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">min-slaves-to-write</span> <span class="string">2</span></span><br><span class="line"><span class="attr">min-slaves-max-lag</span> <span class="string">8</span></span><br></pre></td></tr></table></figure>

<p>slave数量少于2个，或者所有slave的延迟都大于等于8秒时，强制关闭master写功能，停止数据同步</p>
<ul>
<li>slave数量由slave发送REPLCONF ACK命令做确认</li>
</ul>
<ul>
<li>slave延迟由slave发送REPLCONF ACK命令做确认</li>
</ul>
<p>至此：我们可以总结出完整的主从复制流程：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340104.png"></p>
<h3 id="2-3-主从复制常见问题"><a href="#2-3-主从复制常见问题" class="headerlink" title="2.3 主从复制常见问题"></a>2.3 主从复制常见问题</h3><h4 id="2-3-1-频繁的全量复制"><a href="#2-3-1-频繁的全量复制" class="headerlink" title="2.3.1 频繁的全量复制"></a>2.3.1 频繁的全量复制</h4><ul>
<li>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</li>
</ul>
<p>内部优化调整方案：</p>
<p>1：master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</p>
<p>2：在master关闭时执行命令shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">repl-id  repl-offset</span><br><span class="line"></span><br><span class="line">通过redis-check-rdb命令可以查看该信息</span><br></pre></td></tr></table></figure>

<p>3：master重启后加载RDB文件，恢复数据，重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">master<span class="emphasis">_repl_</span>id=repl  master<span class="emphasis">_repl_</span>offset =repl-offset</span><br><span class="line"></span><br><span class="line">通过info命令可以查看该信息</span><br></pre></td></tr></table></figure>

<p>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p>
<ul>
<li>第二种出现频繁全量复制的问题现象：网络环境不佳，出现网络中断，slave不提供服务</li>
</ul>
<p>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</p>
<p>最终结果：slave反复进行全量复制</p>
<p>解决方案：修改复制缓冲区大小</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">repl-backlog-size</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure>

<p>建议设置如下：</p>
<p>1.测算从master到slave的重连平均时长second</p>
<p>2.获取master平均每秒产生写命令数据总量write_size_per_second</p>
<p>3.最优复制缓冲区空间 = 2 * second * write_size_per_second</p>
<h4 id="2-3-2-频繁的网络中断"><a href="#2-3-2-频繁的网络中断" class="headerlink" title="2.3.2 频繁的网络中断"></a>2.3.2 频繁的网络中断</h4><ul>
<li>问题现象：master的CPU占用过高 或 slave频繁断开连接</li>
</ul>
<p>问题原因</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">slave每1秒发送REPLCONFACK命令到master</span><br><span class="line"></span><br><span class="line">当slave接到了慢查询时（keys <span class="emphasis">* ，hgetall等），会大量占用CPU性能</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</span></span><br></pre></td></tr></table></figure>

<p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p>
<p>解决方案：通过设置合理的超时时间，确认是否释放slave</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">repl-timeout</span> <span class="string">seconds</span></span><br></pre></td></tr></table></figure>

<p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p>
<ul>
<li>问题现象：slave与master连接断开</li>
</ul>
<p>问题原因</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">master发送ping指令频度较低</span><br><span class="line"></span><br><span class="line">master设定超时时间较短</span><br><span class="line"></span><br><span class="line">ping指令在网络中存在丢包</span><br></pre></td></tr></table></figure>

<p>解决方案：提高ping指令发送的频度</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">repl-ping-slave-period</span> <span class="string">seconds</span></span><br></pre></td></tr></table></figure>

<p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p>
<h4 id="2-3-3-数据不一致"><a href="#2-3-3-数据不一致" class="headerlink" title="2.3.3 数据不一致"></a>2.3.3 数据不一致</h4><p>问题现象：多个slave获取相同数据不同步</p>
<p>问题原因：网络信息不同步，数据发送有延迟</p>
<p>解决方案</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</span><br><span class="line"></span><br><span class="line">监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">slave-serve-stale-data</span>	<span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<p>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p>
<h2 id="3-哨兵模式"><a href="#3-哨兵模式" class="headerlink" title="3.哨兵模式"></a>3.哨兵模式</h2><h3 id="3-1-哨兵简介"><a href="#3-1-哨兵简介" class="headerlink" title="3.1 哨兵简介"></a>3.1 哨兵简介</h3><h4 id="3-1-1-哨兵概念"><a href="#3-1-1-哨兵概念" class="headerlink" title="3.1.1 哨兵概念"></a>3.1.1 哨兵概念</h4><p>首先我们来看一个业务场景：如果redis的master宕机了，此时应该怎么办？</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340435.png"></p>
<p>那此时我们可能需要从一堆的slave中重新选举出一个新的master，那这个操作过程是什么样的呢？这里面会有什么问题出现呢？</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340460.png"></p>
<p>要实现这些功能，我们就需要redis的哨兵，那哨兵是什么呢？</p>
<p><strong>哨兵</strong></p>
<p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过<strong>投票</strong>机制<strong>选择</strong>新的master并将所有slave连接到新的master。</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341820.png"></p>
<h4 id="3-1-2-哨兵作用"><a href="#3-1-2-哨兵作用" class="headerlink" title="3.1.2 哨兵作用"></a>3.1.2 哨兵作用</h4><p>哨兵的作用：</p>
<ul>
<li><p>监控：监控master和slave</p>
<p>不断的检查master和slave是否正常运行</p>
<p>master存活检测、master与slave运行情况检测</p>
</li>
</ul>
<ul>
<li>通知（提醒）：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知</li>
</ul>
<ul>
<li>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接新的master，并告知客户端新的服务器地址</li>
</ul>
<p>注意：哨兵也是一台redis服务器，只是不提供数据相关服务，通常哨兵的数量配置为单数</p>
<h3 id="3-2-启用哨兵"><a href="#3-2-启用哨兵" class="headerlink" title="3.2 启用哨兵"></a>3.2 启用哨兵</h3><p>配置哨兵</p>
<ul>
<li><p>配置一拖二的主从结构（利用之前的方式启动即可）</p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同），参看sentinel.conf</p>
</li>
</ul>
<p>1：设置哨兵监听的主服务器信息， sentinel_number表示参与投票的哨兵数量</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">monitor master_name  master_host	master_port	 sentinel_number</span></span><br></pre></td></tr></table></figure>
<p>2：设置判定服务器宕机时长，该设置控制是否进行主从切换</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">down-after-milliseconds master_name	million_seconds</span></span><br></pre></td></tr></table></figure>

<p>3：设置故障切换的最大超时时</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">failover-timeout master_name	million_seconds</span></span><br></pre></td></tr></table></figure>

<p>4：设置主从切换后，同时进行数据同步的slave数量，数值越大，要求网络资源越高，数值越小，同步时间越长</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">parallel-syncs master_name sync_slave_number</span></span><br></pre></td></tr></table></figure>


<ul>
<li>启动哨兵</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-sentinel</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-哨兵工作原理"><a href="#3-3-哨兵工作原理" class="headerlink" title="3.3 哨兵工作原理"></a>3.3 哨兵工作原理</h3><p>哨兵在进行主从切换过程中经历三个阶段</p>
<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
<h4 id="3-3-1-监控"><a href="#3-3-1-监控" class="headerlink" title="3.3.1 监控"></a>3.3.1 监控</h4><p>用于同步各个节点的状态信息</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341193.png"></p>
<ul>
<li>获取各个sentinel的状态（是否在线）</li>
</ul>
<ul>
<li>获取master的状态</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">master属性</span><br><span class="line"><span class="code">	prunid</span></span><br><span class="line"><span class="code">	prole：master</span></span><br><span class="line"><span class="code">各个slave的详细信息	</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取所有slave的状态（根据master中的slave信息）</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">slave属性</span><br><span class="line"><span class="code">	prunid</span></span><br><span class="line"><span class="code">	prole：slave</span></span><br><span class="line"><span class="code">	pmaster_host、master_port</span></span><br><span class="line"><span class="code">	poffset</span></span><br></pre></td></tr></table></figure>

<p>其内部的工作原理具体如下：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341526.png"></p>
<h4 id="3-3-2-通知"><a href="#3-3-2-通知" class="headerlink" title="3.3.2 通知"></a>3.3.2 通知</h4><p>sentinel在通知阶段要不断的去获取master/slave的信息，然后在各个sentinel之间进行共享，具体的流程如下：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341521.png"></p>
<h4 id="3-3-3-故障转移"><a href="#3-3-3-故障转移" class="headerlink" title="3.3.3 故障转移"></a>3.3.3 故障转移</h4><p>当master宕机后sentinel是如何知晓并判断出master是真的宕机了呢？我们来看具体的操作流程</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341973.png"></p>
<p>当sentinel认定master下线之后，此时需要决定更换master，那这件事由哪个sentinel来做呢？这时候sentinel之间要进行选举，如下图所示：</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341326.png"></p>
<p>在选举的时候每一个人手里都有一票，而每一个人的又都想当这个处理事故的人，那怎么办？大家就开始抢，于是每个人都会发出一个指令，在内网里边告诉大家我要当选举人，比如说现在的sentinel1和sentinel4发出这个选举指令了，那么sentinel2既能接到sentinel1的也能接到sentinel4的，接到了他们的申请以后呢，sentinel2他就会把他的一票投给其中一方，投给谁呢？谁先过来我投给谁，假设sentinel1先过来，所以这个票就给到了sentinel1。那么给过去以后呢，现在sentinel1就拿到了一票，按照这样的一种形式，最终会有一个选举结果。对应的选举最终得票多的，那自然就成为了处理事故的人。需要注意在这个过程中有可能会存在失败的现象，就是一轮选举完没有选取，那就会接着进行第二轮第三轮直到完成选举。</p>
<p>接下来就是由选举胜出的sentinel去从slave中选一个新的master出来的工作，这个流程是什么样的呢？</p>
<p>首先它有一个在服务器列表中挑选备选master的原则</p>
<ul>
<li>不在线的OUT</li>
</ul>
<ul>
<li>响应慢的OUT</li>
</ul>
<ul>
<li>与原master断开时间久的OUT</li>
</ul>
<ul>
<li><p>优先原则</p>
<p>​    优先级<br>​        offset<br>​        runid</p>
</li>
</ul>
<p>选出新的master之后，发送指令（ sentinel ）给其他的slave：</p>
<ul>
<li>向新的master发送slaveof no one</li>
</ul>
<ul>
<li>向其他slave发送slaveof 新masterIP端口</li>
</ul>
<p><strong>总结</strong>：故障转移阶段</p>
<ol>
<li>发现问题，主观下线与客观下线</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li>
</ol>
<h2 id="4-集群cluster"><a href="#4-集群cluster" class="headerlink" title="4.集群cluster"></a>4.集群cluster</h2><p>现状问题：业务发展过程中遇到的峰值瓶颈</p>
<ul>
<li>redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到10万/秒</li>
<li>内存单机容量达到256G，当前业务需求内存容量1T</li>
<li>使用集群的方式可以快速解决上述问题</li>
</ul>
<h3 id="4-1-集群简介"><a href="#4-1-集群简介" class="headerlink" title="4.1 集群简介"></a>4.1 集群简介</h3><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341545.png"></p>
<p><strong>集群作用：</strong></p>
<ul>
<li>分散单台服务器的访问压力，实现负载均衡</li>
<li>分散单台服务器的存储压力，实现可扩展性</li>
<li>降低单台服务器宕机带来的业务灾难</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341078.png"></p>
<h3 id="4-2-Cluster集群结构设计"><a href="#4-2-Cluster集群结构设计" class="headerlink" title="4.2 Cluster集群结构设计"></a>4.2 Cluster集群结构设计</h3><p><strong>数据存储设计：</strong></p>
<ol>
<li><p>通过算法设计，计算出key应该保存的位置</p>
</li>
<li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分</p>
<p>注意：每份代表的是一个存储空间，不是一个key的保存空间</p>
</li>
<li><p>将key按照计算出的结果放到对应的存储空间</p>
</li>
</ol>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341991.png"></p>
<p>那redis的集群是如何增强可扩展性的呢？譬如我们要增加一个集群节点</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032342016.png"></p>
<p>当我们查找数据时，集群是如何操作的呢？</p>
<ul>
<li>各个数据库相互通信，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体位置</li>
</ul>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032342930.png"></p>
<h3 id="4-3-Cluster集群结构搭建"><a href="#4-3-Cluster集群结构搭建" class="headerlink" title="4.3 Cluster集群结构搭建"></a>4.3 Cluster集群结构搭建</h3><p>首先要明确的几个要点：</p>
<ul>
<li>配置服务器（3主3从）</li>
<li>建立通信（Meet）</li>
<li>分槽（Slot）</li>
<li>搭建主从（master-slave）</li>
</ul>
<p><strong>Cluster配置</strong></p>
<ul>
<li>是否启用cluster，加入cluster节点</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster-config-file</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure>

<ul>
<li>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">milliseconds</span></span><br></pre></td></tr></table></figure>

<ul>
<li>master连接的slave最小数量</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster-migration-barrier</span> <span class="string">min_slave_number</span></span><br></pre></td></tr></table></figure>

<p><strong>Cluster节点操作命令</strong></p>
<ul>
<li> 查看集群节点信息</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">nodes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更改slave指向新的master</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">replicate master-id</span></span><br></pre></td></tr></table></figure>

<ul>
<li>发现一个新节点，新增master</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">meet ip:port</span></span><br></pre></td></tr></table></figure>

<ul>
<li>忽略一个没有solt的节点</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">forget server_id</span></span><br></pre></td></tr></table></figure>

<ul>
<li>手动故障转移</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">failover</span></span><br></pre></td></tr></table></figure>

<p><strong>集群操作命令：</strong></p>
<ul>
<li>创建集群</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">–-cluster create masterhost1:masterport1 masterhost2:masterport2  masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1  slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n</span></span><br></pre></td></tr></table></figure>

<p>注意：master与slave的数量要匹配，一个master对应n个slave，由最后的参数n决定</p>
<p>master与slave的匹配顺序为第一个master与前n个slave分为一组，形成主从结构</p>
<ul>
<li>添加master到当前集群中，连接时可以指定任意现有节点地址与端口</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster add-node new-master-host:new-master-port now-host:now-port</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加slave</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除节点，如果删除的节点是master，必须保障其中没有槽slot</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster del-node del-slave-host:del-slave-port del-slave-id</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重新分槽，分槽是从具有槽的master中划分一部分给其他master，过程中不创建新的槽</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster reshard new-master-host:new-master:port --cluster-from src-  master-id1, src-master-id2, src-master-idn --cluster-to target-master-id --  cluster-slots slots</span></span><br></pre></td></tr></table></figure>

<p>注意：将需要参与分槽的所有masterid不分先后顺序添加到参数中，使用，分隔</p>
<p>指定目标得到的槽的数量，所有的槽将平均从每个来源的master处获取</p>
<ul>
<li>重新分配槽，从具有槽的master中分配指定数量的槽到另一个master中，常用于清空指定master中的槽</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster reshard src-master-host:src-master-port --cluster-from src-  master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes</span></span><br></pre></td></tr></table></figure>

<h2 id="5-企业级解决方案"><a href="#5-企业级解决方案" class="headerlink" title="5.企业级解决方案"></a>5.企业级解决方案</h2><h3 id="5-1-缓存预热"><a href="#5-1-缓存预热" class="headerlink" title="5.1 缓存预热"></a>5.1 缓存预热</h3><p><strong>场景</strong>：“宕机”</p>
<p>服务器启动后迅速宕机</p>
<p><strong>问题排查</strong>：</p>
<p>1.请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对redis的高强度操作从而导致问题</p>
<p>2.主从之间数据吞吐量较大，数据同步操作频度较高</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>前置准备工作：</li>
</ul>
<p>1.日常例行统计数据访问记录，统计访问频度较高的热点数据</p>
<p>2.利用LRU数据删除策略，构建数据留存队列例如：storm与kafka配合</p>
<ul>
<li>准备工作：</li>
</ul>
<p>1.将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</p>
<p>2.利用分布式多服务器同时进行数据读取，提速数据加载过程</p>
<p>3.热点数据主从同时预热</p>
<ul>
<li>实施：</li>
</ul>
<p>4.使用脚本程序固定触发数据预热过程</p>
<p>5.如果条件允许，使用了CDN（内容分发网络），效果会更好</p>
<p><strong>总的来说</strong>：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="5-2-缓存雪崩"><a href="#5-2-缓存雪崩" class="headerlink" title="5.2 缓存雪崩"></a>5.2 缓存雪崩</h3><p><strong>场景</strong>：数据库服务器崩溃，一连串的场景会随之儿来</p>
<p>1.系统平稳运行过程中，忽然数据库连接量激增</p>
<p>2.应用服务器无法及时处理请求</p>
<p>3.大量408，500错误页面出现</p>
<p>4.客户反复刷新页面获取数据</p>
<p>5.数据库崩溃</p>
<p>6.应用服务器崩溃</p>
<p>7.重启应用服务器无效</p>
<p>8.Redis服务器崩溃</p>
<p>9.Redis集群崩溃</p>
<p>10.重启数据库后再次被瞬间流量放倒</p>
<p><strong>问题排查</strong>：</p>
<p>1.在一个较短的时间内，缓存中较多的key集中过期</p>
<p>2.此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</p>
<p>3.数据库同时接收到大量的请求无法及时处理</p>
<p>4.Redis大量请求被积压，开始出现超时现象</p>
<p>5.数据库流量激增，数据库崩溃</p>
<p>6.重启后仍然面对缓存中无数据可用</p>
<p>7.Redis服务器资源被严重占用，Redis服务器崩溃</p>
<p>8.Redis集群呈现崩塌，集群瓦解</p>
<p>9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</p>
<p>10.应用服务器，redis，数据库全部重启，效果不理想</p>
<p>总而言之就两点：短时间范围内，大量key集中过期</p>
<p><strong>解决方案</strong></p>
<ul>
<li>思路：</li>
</ul>
<p>1.更多的页面静态化处理</p>
<p>2.构建多级缓存架构</p>
<p>​    Nginx缓存+redis缓存+ehcache缓存</p>
<p>3.检测Mysql严重耗时业务进行优化</p>
<p>​    对数据库的瓶颈排查：例如超时查询、耗时较高事务等</p>
<p>4.灾难预警机制</p>
<p>​    监控redis服务器性能指标</p>
<p>​        CPU占用、CPU使用率</p>
<p>​        内存容量</p>
<p>​        查询平均响应时间</p>
<p>​        线程数</p>
<p>5.限流、降级</p>
<p>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</p>
<ul>
<li>落地实践：</li>
</ul>
<p>1.LRU与LFU切换</p>
<p>2.数据有效期策略调整</p>
<p>​    根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</p>
<p>​    过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</p>
<p>3.超热数据使用永久key</p>
<p>4.定期维护（自动+人工）</p>
<p>​    对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</p>
<p>5.加锁：慎用！</p>
<p><strong>总的来说</strong>：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的 出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<h3 id="5-3-缓存击穿"><a href="#5-3-缓存击穿" class="headerlink" title="5.3 缓存击穿"></a>5.3 缓存击穿</h3><p><strong>场景</strong>：还是数据库服务器崩溃，但是跟之前的场景有点不太一样</p>
<p>1.系统平稳运行过程中</p>
<p>2.数据库连接量瞬间激增</p>
<p>3.Redis服务器无大量key过期</p>
<p>4.Redis内存平稳，无波动</p>
<p>5.Redis服务器CPU正常</p>
<p>6.数据库崩溃</p>
<p><strong>问题排查：</strong></p>
<p>1.Redis中某个key过期，该key访问量巨大</p>
<p>2.多个数据请求从服务器直接压到Redis后，均未命中</p>
<p>3.Redis在短时间内发起了大量对数据库中同一数据的访问</p>
<p>总而言之就两点：单个key高热数据，key过期</p>
<p><strong>解决方案</strong>：</p>
<p>1.预先设定</p>
<p>​    以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
<p>2.现场调整</p>
<p>​    监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</p>
<p>3.后台刷新数据</p>
<p>​    启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p>
<p>4.二级缓存</p>
<p>​    设置不同的失效时间，保障不会被同时淘汰就行</p>
<p>5.加锁</p>
<p>​    分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</p>
<p><strong>总的来说</strong>：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数 据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过 期监控难度较高，配合雪崩处理策略即可。</p>
<h3 id="5-4-缓存穿透"><a href="#5-4-缓存穿透" class="headerlink" title="5.4 缓存穿透"></a>5.4 缓存穿透</h3><p><strong>场景</strong>：数据库服务器又崩溃了，跟之前的一样吗？</p>
<p>1.系统平稳运行过程中</p>
<p>2.应用服务器流量随时间增量较大</p>
<p>3.Redis服务器命中率随时间逐步降低</p>
<p>4.Redis内存平稳，内存无压力</p>
<p>5.Redis服务器CPU占用激增</p>
<p>6.数据库服务器压力激增</p>
<p>7.数据库崩溃</p>
<p><strong>问题排查：</strong></p>
<p>1.Redis中大面积出现未命中</p>
<p>2.出现非正常URL访问</p>
<p><strong>问题分析</strong>：</p>
<ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li>
<li>Redis获取到null数据未进行持久化，直接返回</li>
<li>下次此类数据到达重复上述过程</li>
<li>出现黑客攻击服务器</li>
</ul>
<p><strong>解决方案</strong>：</p>
<p>1.缓存null</p>
<p>​    对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p>
<p>2.白名单策略</p>
<p>​    提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低）</p>
<p>​    使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p>
<p>2.实施监控</p>
<p>​    实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</p>
<p>​        非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</p>
<p>​        活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象</p>
<p>​    根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</p>
<p>4.key加密</p>
<p>​    问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</p>
<p>​    例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p>
<p><strong>总的来说</strong>：缓存击穿是指访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p>
<p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p>
<h3 id="5-5-性能指标监控"><a href="#5-5-性能指标监控" class="headerlink" title="5.5 性能指标监控"></a>5.5 性能指标监控</h3><p>redis中的监控指标如下：</p>
<ul>
<li>性能指标：Performance</li>
</ul>
<blockquote>
<p>响应请求的平均时间:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;latency</span></span><br></pre></td></tr></table></figure>

<p>平均每秒处理请求总数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;instantaneous_ops_per_sec</span></span><br></pre></td></tr></table></figure>

<p>缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;hit_rate(calculated)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>内存指标：Memory</p>
<blockquote>
<p>当前内存使用量</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;used_memory</span></span><br></pre></td></tr></table></figure>

<p>内存碎片率（关系到是否进行碎片整理）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;mem_fragmentation_ratio</span></span><br></pre></td></tr></table></figure>

<p>为避免内存溢出删除的key的总数量</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;evicted_keys</span></span><br></pre></td></tr></table></figure>

<p>基于阻塞操作（BLPOP等）影响的客户端数量</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;blocked_clients</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>基本活动指标：Basic_activity</p>
</li>
</ul>
<blockquote>
<p>当前客户端连接总数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;connected_clients</span></span><br></pre></td></tr></table></figure>

<p>当前连接slave总数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;connected_slaves</span></span><br></pre></td></tr></table></figure>

<p>最后一次主从信息交换距现在的秒</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;master_last_io_seconds_ago</span></span><br></pre></td></tr></table></figure>

<p>key的总数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;keyspace</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>持久性指标：Persistence</li>
</ul>
<blockquote>
<p>当前服务器最后一次RDB持久化的时间</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;rdb_last_save_time</span></span><br></pre></td></tr></table></figure>

<p>当前服务器最后一次RDB持久化后数据变化总量</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;rdb_changes_since_last_save</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>错误指标：Error</li>
</ul>
<blockquote>
<p>被拒绝连接的客户端总数（基于达到最大连接值的因素）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;rejected_connections</span></span><br></pre></td></tr></table></figure>

<p>key未命中的总次数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;keyspace_misses</span></span><br></pre></td></tr></table></figure>

<p>主从断开的秒数</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;master_link_down_since_seconds</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>要对redis的相关指标进行监控，我们可以采用一些用具：</p>
<ul>
<li>CloudInsight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
<p>也有一些命令工具：</p>
<ul>
<li>benchmark</li>
</ul>
<blockquote>
<p>测试当前服务器的并发性能</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span> <span class="string">[-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span></span><br></pre></td></tr></table></figure>

<p>范例1：50个连接，10000次请求对应的性能</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span></span><br></pre></td></tr></table></figure>

<p>范例2：100个连接，5000次请求对应的性能</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span> <span class="string">-c 100 -n 5000</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032342731.png"></p>
</blockquote>
<ul>
<li><p>redis-cli</p>
<p>​    monitor：启动服务器调试信息</p>
</li>
</ul>
<blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;monitor</span></span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>  slowlog：慢日志
</code></pre>
<blockquote>
<p>获取慢查询日志</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;slowlog</span> <span class="string">[operator]</span></span><br></pre></td></tr></table></figure>

<p>​    get ：获取慢查询日志信息</p>
<p>​    len ：获取慢查询日志条目数</p>
<p>​    reset ：重置慢查询日志</p>
<p>相关配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;slowlog-log-slower-than</span> <span class="string">1000 #设置慢查询的时间下线，单位：微妙</span></span><br><span class="line"><span class="attr">&gt;slowlog-max-len</span> <span class="string">100	#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>java并发编程学习笔记</title>
    <url>/2022/07/21/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="4-1-线程出现问题的根本原因分析"><a href="#4-1-线程出现问题的根本原因分析" class="headerlink" title="4.1 线程出现问题的根本原因分析"></a>4.1 线程出现问题的根本原因分析</h2><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了，下面举一个例子 Test13.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;count的值是&#123;&#125;&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我将从字节码的层面进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br><span class="line">    </span><br><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>count++</code> 和 <code>count--</code> 操作实际都是需要这个4个指令完成的，那么这里问题就来了！Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261903116-20230225212938744.png" alt="1583569253392"></p>
<p>如果代码是正常按顺序运行的，那么count的值不会计算错</p>
<h3 id="问题的进一步描述"><a href="#问题的进一步描述" class="headerlink" title="问题的进一步描述"></a>问题的进一步描述</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><ol>
<li><p>一个程序运行多线程本身是没有问题的</p>
</li>
<li><p>问题出现在多个线程共享资源的时候</p>
<ol>
<li>多个线程同时对共享资源进行读操作本身也没有问题</li>
<li>问题出现在对对共享资源同时进行读写操作时就有问题了</li>
</ol>
</li>
<li><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区</p>
<ol>
<li><p>如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 临界区</span></span><br><span class="line"> counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">// 临界区</span></span><br><span class="line"> counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h4><p>多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件</p>
<h2 id="4-2-synchronized-解决方案"><a href="#4-2-synchronized-解决方案" class="headerlink" title="4.2 synchronized 解决方案"></a>4.2 synchronized 解决方案</h2><p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p>
<ul>
<li>阻塞式解决方案：synchronized ，Lock</li>
<li>非阻塞式解决方案：原子变量</li>
</ul>
<p>现在讨论使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<blockquote>
<p>注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码</li>
<li>同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</li>
</ul>
</blockquote>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) <span class="comment">// 线程1获得锁， 那么线程2的状态是(blocked)</span></span><br><span class="line">&#123;</span><br><span class="line"> 临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例程序使用synchronized后如下，计算出的结果是正确！Test13.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">             counter++;</span><br><span class="line">        	&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">             counter--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h4><p><strong>synchronized实际上利用对象保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断</strong></p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261903104-20230225212938771.png" alt="1583571633729"></p>
<h4 id="锁面向对象的改进"><a href="#锁面向对象的改进" class="headerlink" title="锁面向对象的改进"></a>锁面向对象的改进</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test17&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test17</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                room.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                room.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, room.getCounter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        counter--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="synchronized-加在方法上"><a href="#synchronized-加在方法上" class="headerlink" title="synchronized 加在方法上"></a>synchronized 加在方法上</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 等价于</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>不加 synchronized的方法</strong><br>不加 synchronzied的方法就好比不遵守规则的人，不去老实排队(好比翻窗户进去的)</p>
<h2 id="4-3-变量的线程安全分析"><a href="#4-3-变量的线程安全分析" class="headerlink" title="4.3 变量的线程安全分析"></a>4.3 变量的线程安全分析</h2><h3 id="4-3-1-成员变量和静态变量的线程安全分析"><a href="#4-3-1-成员变量和静态变量的线程安全分析" class="headerlink" title="4.3.1 成员变量和静态变量的线程安全分析"></a>4.3.1 成员变量和静态变量的线程安全分析</h3><ul>
<li>如果没有变量没有在线程间共享，那么变量是安全的</li>
<li>如果变量在线程间共享<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-局部变量线程安全分析"><a href="#4-3-2-局部变量线程安全分析" class="headerlink" title="4.3.2 局部变量线程安全分析"></a>4.3.2 局部变量线程安全分析</h3><ul>
<li>局部变量【局部变量被初始化为基本数据类型】是安全的</li>
<li>局部变量引用的对象未必是安全的<ul>
<li>如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的</li>
<li>如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的</li>
</ul>
</li>
</ul>
<h4 id="线程安全的情况"><a href="#线程安全的情况" class="headerlink" title="线程安全的情况"></a>线程安全的情况</h4><p>局部变量【局部变量被初始化为基本数据类型】是安全的，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261903715-20230225212938780.png" alt="1583587166210"></p>
<h4 id="线程不安全的情况"><a href="#线程不安全的情况" class="headerlink" title="线程不安全的情况"></a>线程不安全的情况</h4><p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全的，代码示例如下 Test15.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UnsafeTest</span> <span class="variable">unsafeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeTest</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeTest</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不安全原因分析"><a href="#不安全原因分析" class="headerlink" title="不安全原因分析"></a>不安全原因分析</h5><p>无论哪个线程中的 method2 和method3 引用的都是同一个对象中的 list 成员变量：一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p>
<ol>
<li>第一步，在 arrayList[Size] 的位置存放此元素； 第二步增大 Size 的值。</li>
<li>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不 安全”了。</li>
</ol>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261903489-20230225212938786.png" alt="1583589268096"></p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261903870-20230225212938797.png" alt="1583587571334"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>可以将list修改成局部变量，那么就不会有上述问题了(<code>每个对象的局部变量引用的都是不同的list</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">safeTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        method2(arrayList);</span><br><span class="line">        method3(arrayList);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList arrayList)</span> &#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList arrayList)</span> &#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思考-private-或-final的重要性"><a href="#思考-private-或-final的重要性" class="headerlink" title="思考 private 或 final的重要性"></a>思考 private 或 final的重要性</h5><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会导致线程安全问题？情况1：有其它线程调用 method2 和 method3；情况2：在情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即如下所示： 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-常见线程安全类"><a href="#4-3-3-常见线程安全类" class="headerlink" title="4.3.3 常见线程安全类"></a>4.3.3 常见线程安全类</h3><ol>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类</li>
</ol>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为它们的每个方法是原子的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> 	table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> 	table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h4><p>但注意它们多个方法的组合不是原子的，见下面分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant t1 as 线程1</span><br><span class="line">participant t2 as 线程2</span><br><span class="line">participant table</span><br><span class="line">t1-&gt;&gt;table:get(&quot;key&quot;)==null</span><br><span class="line">t2-&gt;&gt;table:get(&quot;key&quot;)==null</span><br><span class="line">t2-&gt;&gt;table:put(&quot;key&quot;,v2)</span><br><span class="line">t1-&gt;&gt;table:put(&quot;key&quot;,v1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261903542-20230225212938800.png" alt="1583590979975"></p>
<h4 id="不可变类的线程安全"><a href="#不可变类的线程安全" class="headerlink" title="不可变类的线程安全"></a>不可变类的线程安全</h4><p><code>String</code>和<code>Integer</code>类都是不可变的类，因为其类内部状态是不可改变的，因此它们的方法都是线程安全的，有同学或许有疑问，<code>String</code> 有 <code>replace</code>，<code>substring</code> 等方法【可以】改变值啊，其实调用这些方法返回的已经是一个新创建的对象了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Immutable</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Immutable</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.value = value;</span><br><span class="line"> 	&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Immutable <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Immutable</span>(<span class="built_in">this</span>.value + v);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例分析-是否线程安全"><a href="#示例分析-是否线程安全" class="headerlink" title="示例分析-是否线程安全"></a>示例分析-是否线程安全</h4><h5 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h5><p>分析线程是否安全，先对类的成员变量，类变量，局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的的。下面对实例一进行分析：此类不是线程安全的，<code>MyAspect</code>切面类只有一个实例，成员变量<code>start</code> 会被多个线程同时进行读写操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">        <span class="comment">// 是否安全？</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">            start = System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h5><p>此例是典型的三层模型调用，<code>MyServlet</code> <code>UserServiceImpl</code> <code>UserDaoImpl</code>类都只有一个实例，<code>UserDaoImpl</code>类中没有成员变量，<code>update</code>方法里的变量引用的对象不是线程共享的，所以是线程安全的；<code>UserServiceImpl</code>类中只有一个线程安全的<code>UserDaoImpl</code>类的实例，那么<code>UserServiceImpl</code>类也是线程安全的，同理 <code>MyServlet</code>也是线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"> <span class="comment">// 是否安全</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line"> userService.update(...);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">// 是否安全</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line"> userDao.update();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line"> <span class="comment">// 是否安全</span></span><br><span class="line"> <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h5><p>跟示例二大体相似，<code>UserDaoImpl</code>类中有成员变量，那么多个线程可以对成员变量<code>conn</code> 同时进行操作，故是不安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h5><p>跟示例三大体相似，<code>UserServiceImpl</code>类的update方法中 UserDao是作为局部变量存在的，所以每个线程访问的时候都会新建有一个<code>UserDao</code>对象，新建的对象是线程独有的，所以是线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="type">private</span> <span class="variable">Connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 是否安全</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        foo(sdf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为<strong>外星方法</strong>，因为foo方法可以被重写，导致线程不安全。在String类中就考虑到了这一点，String类是<code>finally</code>的，子类不能重写它的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;1999-10-11 00:00:00&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sdf.parse(dateStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-卖票问题分析"><a href="#4-4-卖票问题分析" class="headerlink" title="4.4 卖票问题分析"></a>4.4 卖票问题分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.n4.exercise;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExerciseSell</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟多人买票</span></span><br><span class="line">        <span class="type">TicketWindow</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketWindow</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有线程的集合</span></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 卖出的票数统计</span></span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 买票</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> window.sell(random(<span class="number">5</span>));</span><br><span class="line">                <span class="comment">// 统计买票数</span></span><br><span class="line">                amountList.add(amount); <span class="comment">//window和amountList的组合因为是不同的变量,所以也没有线程不安全问题</span></span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(thread);<span class="comment">//只会被主线程使用,不需要保护</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计卖出的票数和剩余票数</span></span><br><span class="line">        log.debug(<span class="string">&quot;余票：&#123;&#125;&quot;</span>,window.getCount());</span><br><span class="line">        log.debug(<span class="string">&quot;卖出的票数：&#123;&#125;&quot;</span>, amountList.stream().mapToInt(i-&gt; i).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Random 为线程安全</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机 1~5</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">random</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(amount) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 售票窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TicketWindow</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取余票数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 售票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">sell</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count &gt;= amount) &#123;</span><br><span class="line">            <span class="built_in">this</span>.count -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-5-Monitor-概念"><a href="#4-5-Monitor-概念" class="headerlink" title="4.5 Monitor 概念"></a>4.5 Monitor 概念</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>以 32 位虚拟机为例,普通对象的对象头结构如下，其中的Klass Word为指针，指向对应的Class对象；</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904173-20230225212938813.png" alt="1583651065372"></p>
<p>数组对象</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904688-20230225212938816.png" alt="1583651088663"></p>
<p>其中 Mark Word 结构为</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904643-20230225212938867.png" alt="1583651590160"></p>
<blockquote>
<p>其中Heavyweight Licked 就是加了synchronized修饰的</p>
</blockquote>
<p>所以一个对象的结构如下：</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904168-20230225212938862.png" alt="1583678624634"></p>
<h3 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h3><p>Monitor被翻译为监视器或者说管程</p>
<p>每个java对象都可以关联一个Monitor，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904369-20230225212938854.png" alt="1583652360228"></p>
<ul>
<li>刚开始时Monitor中的Owner为null</li>
<li>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</li>
<li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList中变成BLOCKED状态</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<blockquote>
<p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则</p>
</blockquote>
<h3 id="synchronized原理-1"><a href="#synchronized原理-1" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><p>代码如下 Test17.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的部分字节码</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"> <span class="attr">0</span> <span class="string">getstatic #2 &lt;com/concurrent/test/Test17.lock&gt;</span></span><br><span class="line"><span class="comment"> # 取得lock的引用（synchronized开始了）</span></span><br><span class="line"> <span class="attr">3</span> <span class="string">dup    </span></span><br><span class="line"><span class="comment"> # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用</span></span><br><span class="line"> <span class="attr">4</span> <span class="string">astore_1</span></span><br><span class="line"><span class="comment"> # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中</span></span><br><span class="line"> <span class="attr">5</span> <span class="string">monitorenter</span></span><br><span class="line"><span class="comment"> # 将lock对象的Mark Word置为指向Monitor指针</span></span><br><span class="line"> <span class="attr">6</span> <span class="string">getstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span></span><br><span class="line"> <span class="attr">9</span> <span class="string">iconst_1</span></span><br><span class="line"><span class="attr">10</span> <span class="string">iadd</span></span><br><span class="line"><span class="attr">11</span> <span class="string">putstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span></span><br><span class="line"><span class="attr">14</span> <span class="string">aload_1</span></span><br><span class="line"><span class="comment"># 从局部变量表中取得lock的引用，放入操作数栈栈顶</span></span><br><span class="line"><span class="attr">15</span> <span class="string">monitorexit</span></span><br><span class="line"><span class="comment"># 将lock对象的Mark Word重置，唤醒EntryList</span></span><br><span class="line"><span class="attr">16</span> <span class="string">goto 24 (+8)</span></span><br><span class="line"><span class="comment"># 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁</span></span><br><span class="line"><span class="attr">19</span> <span class="string">astore_2</span></span><br><span class="line"><span class="attr">20</span> <span class="string">aload_1</span></span><br><span class="line"><span class="attr">21</span> <span class="string">monitorexit</span></span><br><span class="line"><span class="attr">22</span> <span class="string">aload_2</span></span><br><span class="line"><span class="attr">23</span> <span class="string">athrow</span></span><br><span class="line"><span class="attr">24</span> <span class="string">return</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：方法级别的 synchronized 不会在字节码指令中有所体现</p>
</blockquote>
<h3 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h3><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference</p>
<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904048-20230225212938829.png" alt="1583755737580"></li>
</ol>
</li>
<li><p>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中</p>
<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904627-20230225212938875.png" alt="1583755888236"></li>
</ol>
</li>
<li><p>如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态00，如下所示</p>
<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904394-20230225212938905.png" alt="1583755964276"></li>
</ol>
</li>
<li><p>如果cas失败，有两种情况</p>
<ol>
<li>如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</li>
<li>如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904108-20230225212938946.png" alt="1583756190177"></li>
</ol>
</li>
</ol>
</li>
<li><p>当线程退出synchronized代码块的时候，</p>
<p>如果获取的是取值为 null 的锁记录 </p>
<p>，表示有重入，这时重置锁记录，表示重入计数减一</p>
<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904255-20230225212938878.png" alt="1583756357835"></li>
</ol>
</li>
<li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象</p>
<ol>
<li>成功则解锁成功</li>
<li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ol>
</li>
</ol>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，cas操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p>
<ol>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904499-20230225212938862.png" alt="1583757433691"></li>
</ol>
</li>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ol>
<li>即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态</li>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904936-20230225212938913.png" alt="1583757586447"></li>
</ol>
</li>
<li>当Thread-0 推出synchronized同步块时，使用cas将Mark Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程</li>
</ol>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁</p>
<ol>
<li>自旋重试成功的情况<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261904963-20230225212938922.png" alt="1583758113724"></li>
</ol>
</li>
<li>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁<ol>
<li><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905380-20230225212938975.png" alt="1583758136650"></li>
</ol>
</li>
</ol>
<p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在轻量级的锁中，我们可以发现，如果同一个线程对同一个2对象进行重入锁时，也需要执行CAS操作，这是有点耗时滴，那么java6开始引入了偏向锁的东东，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，<strong>之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了</strong></p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905552-20230225212938942.png" alt="1583760728806"></p>
<h5 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h5><p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905389-20230225212938951.png" alt="1583762169169"></p>
<p>一个对象的创建过程</p>
<ol>
<li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值.</p>
</li>
<li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</p>
</li>
<li><p>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p>
</li>
<li><p>实验Test18.java，加上虚拟机参数-XX:BiasedLockingStartupDelay=0进行测试</p>
<ol>
<li>```java<br>public static void main(String[] args) throws InterruptedException {<pre><code>    Test1 t = new Test1();
    test.parseObjectHeader(getObjectHeader(t))；
    synchronized (t)&#123;
        test.parseObjectHeader(getObjectHeader(t));
    &#125;
    test.parseObjectHeader(getObjectHeader(t));
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 输出结果如下，三次输出的状态码都为101</span><br><span class="line"></span><br><span class="line">```properties</span><br><span class="line">biasedLockFlag (1bit): 1</span><br><span class="line">	LockFlag (2bit): 01</span><br><span class="line">biasedLockFlag (1bit): 1</span><br><span class="line">	LockFlag (2bit): 01</span><br><span class="line">biasedLockFlag (1bit): 1</span><br><span class="line">	LockFlag (2bit): 01</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>测试禁用：如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode，age都为0，hashcode是第一次用到<code>hashcode</code>时才赋值的。在上面测试代码运行时在添加 VM 参数<code>-XX:-UseBiasedLocking</code>禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出<code>synchronized</code>状态变回001</p>
<ol>
<li><p>测试代码Test18.java 虚拟机参数<code>-XX:-UseBiasedLocking</code></p>
</li>
<li><p>输出结果如下，最开始状态为001，然后加轻量级锁变成00，最后恢复成001</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="撤销偏向锁-hashcode方法"><a href="#撤销偏向锁-hashcode方法" class="headerlink" title="撤销偏向锁-hashcode方法"></a>撤销偏向锁-hashcode方法</h5><p>测试 <code>hashCode</code>：当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了</p>
<ol>
<li><p>测试代码如下，使用虚拟机参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>

<p> ，确保我们的程序最开始使用了偏向锁！但是结果显示程序还是使用了轻量级锁。 Test20.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Test1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    t.hashCode();</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="撤销偏向锁-其它线程使用对象"><a href="#撤销偏向锁-其它线程使用对象" class="headerlink" title="撤销偏向锁-其它线程使用对象"></a>撤销偏向锁-其它线程使用对象</h5><p>这里我们演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，我们使用<code>wait</code> 和 <code>notify</code> 来辅助实现</p>
<ol>
<li><p>代码 Test19.java，虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>确保我们的程序最开始使用了偏向锁！</p>
</li>
<li><p>输出结果，最开始使用的是偏向锁，但是第二个线程尝试获取对象锁时，发现本来对象偏向的是线程一，那么偏向锁就会失效，加的就是轻量级锁</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">	<span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait/notify"></a>撤销 - 调用 wait/notify</h5><p>会使对象的锁变成重量级锁，因为wait/notify方法之后重量级锁才支持</p>
<h5 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h5><p>如果对象被多个线程访问，但是没有竞争，这时候偏向了线程一的对象又有机会重新偏向线程二，即可以不用升级为轻量级锁，可这和我们之前做的实验矛盾了呀，其实要实现重新偏向是要有条件的：就是超过20对象对同一个线程如线程一撤销偏向时，那么第20个及以后的对象才可以将撤销对线程一的偏向这个动作变为将第20个及以后的对象偏向线程二。Test21.java</p>
<h2 id="4-6-wait和notify"><a href="#4-6-wait和notify" class="headerlink" title="4.6 wait和notify"></a>4.6 wait和notify</h2><p>建议先看看wait和notify方法的javadoc文档</p>
<h4 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a>sleep(long n) 和 wait(long n) 的区别</h4><ol>
<li>sleep是Thread方法，而wait是Object的方法</li>
<li>sleep不需要强制和synchronize配合使用，但wait需要和synchronize一起用</li>
<li>sleep在睡眠的同时，不会释放对象锁的，但wait在等待的时候会释放对象锁</li>
<li>他们的状态都是<code>TIMED_WAITING</code></li>
</ol>
<h3 id="4-6-1同步模式之保护性暂停"><a href="#4-6-1同步模式之保护性暂停" class="headerlink" title="4.6.1同步模式之保护性暂停"></a>4.6.1同步模式之保护性暂停</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果，要点：</p>
<ol>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ol>
<p>代码：Test22.java Test23.java这是带超时时间的</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905409-20230225212938971.png" alt="1594473284105"></p>
<p>Test23.java中jiang’dao’de关于超时的增强，在join(long millis) 的源码中得到了体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// join一个指定的时间</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多任务版 GuardedObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。和生产者消费者模式的区别就是：这个生产者和消费者之间是一一对应的关系，但是生产者消费者模式并不是。rpc框架的调用中就使用到了这种模式。 Test24.java</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905745-20230225212938971.png" alt="1594518049426"></p>
<h3 id="4-6-2异步模式之生产者-消费者"><a href="#4-6-2异步模式之生产者-消费者" class="headerlink" title="4.6.2异步模式之生产者/消费者"></a>4.6.2异步模式之生产者/消费者</h3><p>要点</p>
<ol>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK 中各种<a href="https://blog.csdn.net/yanpenglei/article/details/79556591">阻塞队列</a>，采用的就是这种模式</li>
</ol>
<p>“异步”的意思就是生产者产生消息之后消息没有被立刻消费，而“同步模式”中，消息在产生之后被立刻消费了。</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905594-20230225212938982.png" alt="1594524622020"></p>
<p>我们写一个线程间通信的消息队列，要注意区别，像rabbit mq等消息框架是进程间通信的。</p>
<h2 id="4-7-park-amp-unpack"><a href="#4-7-park-amp-unpack" class="headerlink" title="4.7 park &amp; unpack"></a>4.7 park &amp; unpack</h2><h3 id="4-7-1-基本使用"><a href="#4-7-1-基本使用" class="headerlink" title="4.7.1 基本使用"></a>4.7.1 基本使用</h3><p>它们是 LockSupport 类中的方法 Test26.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-2-park-unpark-原理"><a href="#4-7-2-park-unpark-原理" class="headerlink" title="4.7.2 park unpark 原理"></a>4.7.2 park unpark 原理</h3><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter， _cond和 _mutex</p>
<ol>
<li>打个比喻线程就像一个旅人，Parker 就像他随身携带的背包，条件变量 _ cond就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li>
<li>调用 park 就是要看需不需要停下来歇息<ol>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ol>
</li>
<li>调用 unpark，就好比令干粮充足<ol>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ol>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>可以不看例子，直接看实现过程</p>
<h4 id="先调用park再调用upark的过程"><a href="#先调用park再调用upark的过程" class="headerlink" title="先调用park再调用upark的过程"></a>先调用park再调用upark的过程</h4><p>1.先调用park</p>
<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁(mutex对象有个等待队列 _cond)</li>
<li>线程进入 _cond 条件变量阻塞</li>
<li>设置 _counter = 0</li>
</ol>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905478-20230225212938996.png" alt="1594531894163"></p>
<p>2.调用upark</p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>唤醒 _cond 条件变量中的 Thread_0</li>
<li>Thread_0 恢复运行</li>
<li>设置 _counter 为 0</li>
</ol>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905330-20230225212938995.png" alt="1594532057205"></p>
<h4 id="先调用upark再调用park的过程"><a href="#先调用upark再调用park的过程" class="headerlink" title="先调用upark再调用park的过程"></a>先调用upark再调用park的过程</h4><ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li>
<li>设置 _counter 为 0</li>
</ol>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905515-20230225212939014.png" alt="1594532135616"></p>
<h2 id="4-8-线程状态转换"><a href="#4-8-线程状态转换" class="headerlink" title="4.8 线程状态转换"></a>4.8 线程状态转换</h2><p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905440-20230225212939058.png" alt="img"></p>
<ol>
<li><p>RUNNABLE &lt;–&gt; WAITING</p>
<ol>
<li>线程用synchronized(obj)获取了对象锁后<ol>
<li>调用obj.wait()方法时，t 线程从RUNNABLE –&gt; WAITING</li>
<li>调用obj.notify()，obj.notifyAll()，t.interrupt()时<ol>
<li>竞争锁成功，t 线程从WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从WAITING –&gt; BLOCKED</li>
</ol>
</li>
</ol>
</li>
<li>Test27.java</li>
</ol>
</li>
<li><p>RUNNABLE &lt;–&gt; WAITING</p>
<ol>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ol>
</li>
<li><p>RUNNABLE &lt;–&gt; WAITING</p>
<ol>
<li>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING 注意是当前线程在t 线程对象的监视器上等待</li>
<li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li>
</ol>
</li>
<li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p>
<p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ol>
<li>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ol>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ol>
</li>
</ol>
</li>
<li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p>
<ol>
<li>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING 注意是当前线程在t 线程对象的监视器上等待</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ol>
</li>
<li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p>
<ol>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒或调用了线程 的 interrupt() ，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ol>
</li>
<li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p>
<ol>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ol>
</li>
</ol>
<h2 id="4-9-活跃性"><a href="#4-9-活跃性" class="headerlink" title="4.9 活跃性"></a>4.9 活跃性</h2><p>活跃性相关的一系列问题都可以用ReentrantLock进行解决。</p>
<h3 id="4-9-1-死锁"><a href="#4-9-1-死锁" class="headerlink" title="4.9.1 死锁"></a>4.9.1 死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁t1 线程获得A对象锁，接下来想获取B对象的锁；t2 线程获得B对象锁，接下来想获取A对象的锁例。Test28.java</p>
<h3 id="4-9-2-检测死锁"><a href="#4-9-2-检测死锁" class="headerlink" title="4.9.2 检测死锁"></a>4.9.2 检测死锁</h3><p>检测死锁可以使用 jconsole工具；或者使用 jps 定位进程 id，再用 jstack 定位死锁：Test28.java</p>
<p>下面使用jstack工具进行演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\我的项目\JavaLearing\java并发编程\jdk8&gt;jps</span><br><span class="line">1156 RemoteMavenServer36</span><br><span class="line">20452 Test25</span><br><span class="line">9156 Launcher</span><br><span class="line">23544 Jps</span><br><span class="line">23848</span><br><span class="line">22748 Test28</span><br><span class="line"> </span><br><span class="line">D:\我的项目\JavaLearing\java并发编程\jdk8&gt;jstack 22748</span><br><span class="line">2020-07-12 18:54:44</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):</span><br><span class="line"> </span><br><span class="line">&quot;DestroyJavaVM&quot; #14 prio=5 os_prio=0 tid=0x0000000002a03800 nid=0x5944 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"> </span><br><span class="line">//................省略了大部分内容.............//</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;线程二&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000000002afc0e8 (object 0x00000000db9f76d0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程1&quot;</span><br><span class="line">&quot;线程1&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000000002afe1e8 (object 0x00000000db9f76e0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程二&quot;</span><br><span class="line"> </span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;线程二&quot;:</span><br><span class="line">        at com.concurrent.test.Test28.lambda$main$1(Test28.java:39)</span><br><span class="line">        - waiting to lock &lt;0x00000000db9f76d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000db9f76e0&gt; (a java.lang.Object)</span><br><span class="line">        at com.concurrent.test.Test28$$Lambda$2/326549596.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;线程1&quot;:</span><br><span class="line">        at com.concurrent.test.Test28.lambda$main$0(Test28.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000db9f76e0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000db9f76d0&gt; (a java.lang.Object)</span><br><span class="line">        at com.concurrent.test.Test28$$Lambda$1/1343441044.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="4-9-3-哲学家就餐问题"><a href="#4-9-3-哲学家就餐问题" class="headerlink" title="4.9.3 哲学家就餐问题"></a>4.9.3 哲学家就餐问题</h3><p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261905865-20230225212939012.png" alt="1594553609905"></p>
<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 Test29.java</p>
<p>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情 况</p>
<h3 id="4-9-4-饥饿"><a href="#4-9-4-饥饿" class="headerlink" title="4.9.4 饥饿"></a>4.9.4 饥饿</h3><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题下面我讲一下一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题，就是两个线程对两个不同的对象加锁的时候都使用相同的顺序进行加锁。 但是会产生饥饿问题Test29</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261907693-20230225212939040.png" alt="202201021516316"></p>
<p>顺序加锁的解决方案</p>
<p><img src="/Users/k/Documents/Order_Config/typora%E6%9C%AC%E5%9C%B0%E5%9B%BE%E5%BA%8A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/202206261906175-20230225212939043.png" alt="1594558499871"></p>
<h2 id="4-10-ReentrantLock"><a href="#4-10-ReentrantLock" class="headerlink" title="4.10 ReentrantLock"></a>4.10 ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p>
<ol>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量，即对与不满足条件的线程可以放到不同的集合中等待</li>
</ol>
<p>与 synchronized 一样，都支持可重入</p>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// 释放锁</span></span><br><span class="line"> reentrantLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>直接看例子：Test31.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试使用lock.lock加锁时线程被打断时的效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test31</span> &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                utils.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                utils.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程一&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                utils.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程一&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//                utils.sleep(20);</span></span><br><span class="line">                System.out.println(<span class="number">1111</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        t1.interrupt(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>直接看例子：Test32.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test32</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;获取等待指定时间后失败，返回&quot;</span>);</span><br><span class="line">                    <span class="comment">// 这里如果出了错不要再往下执行了</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.info(<span class="string">&quot;被打断啦&quot;</span>);</span><br><span class="line">                <span class="comment">// 这里如果出了错不要再往下执行了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;执行完啦，获取到了锁，没被打断&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;主线程获取&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;主线程释放锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line"> </span><br><span class="line">        log.info(<span class="string">&quot;主线程执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用锁超时解决哲学家就餐死锁问题：Test33.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用reentrantlock中的tryLock来获取锁来解决哲学家就餐问题，这样就不会造成死锁！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test33</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopstick2</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick2</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick2</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick2</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick2</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick2</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick2</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick2</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Chopstick2</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick2</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher2</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher2</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher2</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher2</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher2</span>(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;Philosopher&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Chopstick2 left;</span><br><span class="line">    Chopstick2 right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher2</span><span class="params">(String name, Chopstick2 left, Chopstick2 right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (right.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                eat();    </span><br><span class="line">                            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                                right.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        left.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick2</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick2</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chopstick&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>synchronized锁中，在entrylist等待的锁在竞争时不是按照先到先得来获取锁的，所以说synchronized锁时不公平的；ReentranLock锁默认是不公平的，但是可以通过设置实现公平锁。本意是为了解决之前提到的饥饿问题，但是公平锁一般没有必要，会降低并发度，使用trylock也可以实现。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p>
<ol>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li>
</ol>
<p>使用要点： Test34.java</p>
<ol>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁，执行唤醒的线程爷必须先获得锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ol>
<h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><ol>
<li>固定运行顺序，比如，必须先 2 后 1 打印<ol>
<li>wait notify 版 Test35.java</li>
<li>Park Unpark 版 Test36.java</li>
</ol>
</li>
<li>交替输出，线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现<ol>
<li>wait notify 版 Test37.java</li>
<li>Lock 条件变量版 Test38.java</li>
<li>Park Unpark 版 Test39.java</li>
</ol>
</li>
</ol>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>本章我们需要重点掌握的是</p>
<ol>
<li>分析多线程访问共享资源时，哪些代码片段属于临界区</li>
<li>使用 synchronized 互斥解决临界区的线程安全问题<ol>
<li>掌握 synchronized 锁对象语法</li>
<li>掌握 synchronzied 加载成员方法和静态方法语法</li>
<li>掌握 wait/notify 同步方法</li>
</ol>
</li>
<li>使用 lock 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li>
<li>学会分析变量的线程安全性、掌握常见线程安全类的使用</li>
<li>了解线程活跃性问题：死锁、活锁、饥饿</li>
<li>应用方面<ol>
<li><strong>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果，实现原子性效果，保证线程安全。</strong></li>
<li><strong>同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果。</strong></li>
</ol>
</li>
<li>原理方面<ol>
<li>monitor、synchronized 、wait/notify 原理</li>
<li>synchronized 进阶原理</li>
<li>park &amp; unpark 原理</li>
</ol>
</li>
<li>模式方面<ol>
<li>同步模式之保护性暂停</li>
<li>异步模式之生产者消费者</li>
<li>同步模式之顺序控制</li>
</ol>
</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li><p>集合并发遇到的报错 Test24.java <a href="https://www.cnblogs.com/snowater/p/8024776.html">参考博客，未看</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/snowater/p/8024776.html">https://www.cnblogs.com/snowater/p/8024776.html</a>)</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>个人记事</title>
    <url>/2023/03/13/%E5%AF%86%E7%A0%81%E6%96%87%E7%AB%A0/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E4%BA%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="449696f1bd88c6427329ef24294ea5ae019ac4db2c1218d7d857a1a12bd2aa14">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f58459281863d2858fb53067ead32f801fff80eb1d38efdc560a4fe6ce5b8dabf5941107d45ae03f02dd92c2255375871de5ea4cf8ddf22acc2a6d47db026e699e1a2460ae3e96bf3f72ec086aac39764a34bba4f3b6dd7fe082431a216b4eab3ae792b3284b15ccc40245459940fd45646093ed11a8a56b3a3df88edd112ed0bf59acca95f492ec92a39971cf6e6f1fde755b456d2b8ebc8f0e92fa84311912db69580d854ea6f98961d3a101472e65f73fea755976ba165c6559e17c43d9400190f9500bcc4a39a5e5973ffbd9c11579ce5820d12e34b65ea08666d1116af1cfcd33d07057d498034bcf8739694372e013f0881b9d417cc1dc1003715adaafc720b18b0e6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/09/13/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h1><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a></h2><p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>
<p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p>
<p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i-1] + dp[i-2]</span><br></pre></td></tr></table></figure>
<p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别对应0   1      2层的方法数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>, q = <span class="number">1</span>, r = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/description/">打家劫舍</a></h2><p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。</p>
<blockquote>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。(临近的2和3不能同时偷窃)<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。<br>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[i-2] + nums[i]  ,  dp[i-1])</span><br></pre></td></tr></table></figure>
<p><strong>精简版答案</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , q = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = Math.max(p+nums[i],q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分别对应-1      0        1   下标的偷窃的最高金额，因此后面的for从下标2开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , q = nums[<span class="number">0</span>] , r = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = Math.max(p+nums[i],q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="环形区域打家劫舍"><a href="#环形区域打家劫舍" class="headerlink" title="环形区域打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber-ii/description/">环形区域打家劫舍</a></h2><blockquote>
<p>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抢劫如下闭区间的下标之间的最大金额</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p q r相当于-3   -2     -1   位置的最大金额</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) &#123;</span><br><span class="line">        p = q; <span class="comment">//类似于dp[i-2]</span></span><br><span class="line">        q = r; <span class="comment">//类似于求dp[i-1]</span></span><br><span class="line">        r = Math.max(p + nums[i], q); <span class="comment">//类似求dp[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="2-矩阵路径"><a href="#2-矩阵路径" class="headerlink" title="2.矩阵路径"></a>2.矩阵路径</h1><h2 id="从左上角到右下角的最小路径和"><a href="#从左上角到右下角的最小路径和" class="headerlink" title="从左上角到右下角的最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/description/">从左上角到右下角的最小路径和</a></h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p>
<blockquote>
<p>输入：grid =<br>[[1,3,1],<br>[1,5,1],<br>[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p>
</blockquote>
<ul>
<li>状态定义: 设dp为大小m乘以n的矩阵,dp[i][j]表示走到(i,j)的最小路径和,则题目求的是dp[m-1][n-1]</li>
<li>注意:这里可以不用真的定义dp数组,可以原地用grid数组修改,原因是每次被覆盖后不会再被使用</li>
<li>因此时间复杂度是O(m*n),空间复杂度是O(1),直接修改矩阵,不需要额外的空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="从矩阵左上角到右下角的路径总数"><a href="#从矩阵左上角到右下角的路径总数" class="headerlink" title="从矩阵左上角到右下角的路径总数"></a><a href="https://leetcode.cn/problems/unique-paths/description/">从矩阵左上角到右下角的路径总数</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p>
<blockquote>
<p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">S</span> <span class="operator">=</span> m + n - <span class="number">2</span>;  <span class="comment">// 总共的移动次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">D</span> <span class="operator">=</span> m - <span class="number">1</span>;      <span class="comment">// 向下的移动次数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= D; i++) &#123;</span><br><span class="line">        ret = ret * (S - D + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="3-数组区间"><a href="#3-数组区间" class="headerlink" title="3.数组区间"></a>3.数组区间</h1><h2 id="数组区间和"><a href="#数组区间和" class="headerlink" title="数组区间和"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">数组区间和</a></h2><p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用这个函数可以求出数组[i,j]闭区间的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组中等差递增子区间的个数"><a href="#数组中等差递增子区间的个数" class="headerlink" title="数组中等差递增子区间的个数"></a><a href="https://leetcode.cn/problems/arithmetic-slices/description/">数组中等差递增子区间的个数</a></h2><blockquote>
<p>A = [0, 1, 2, 3, 4]<br>答案是6,如下子区间:<br>[0, 1, 2],<br>[1, 2, 3],<br>[0, 1, 2, 3],<br>[0, 1, 2, 3, 4],<br>[ 1, 2, 3, 4],<br>[2, 3, 4]</p>
</blockquote>
<p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>
<p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。<br>解释上面的答案可以这样看:</p>
<blockquote>
<p>dp[2] = 1<br>    [0, 1, 2]<br>dp[3] = dp[2] + 1 = 2<br>    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3<br>    [1, 2, 3]     // 新的递增子区间<br>dp[4] = dp[3] + 1 = 3<br>    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4<br>    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4<br>    [2, 3, 4]        // 新的递增子区间</p>
</blockquote>
<p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p>
<p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt : dp) &#123;</span><br><span class="line">        total += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-分割整数"><a href="#4-分割整数" class="headerlink" title="4.分割整数"></a>4.分割整数</h1><h2 id="整数n拆分为k-个和并使乘积最大化"><a href="#整数n拆分为k-个和并使乘积最大化" class="headerlink" title="整数n拆分为k 个和并使乘积最大化"></a><a href="https://leetcode.cn/problems/integer-break/description/">整数n拆分为k 个和并使乘积最大化</a></h2><blockquote>
<p>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//1是不可再拆分，需特殊处理</span></span><br><span class="line">    <span class="comment">//dp[i]可以拆分两两个数j  和  i-j  或者 i -j进一步拆分成其他的，其乘积最大值就是dp[i-j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//dp[i]在内循环里一直在更新更大的值</span></span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按平方数来分割整数"><a href="#按平方数来分割整数" class="headerlink" title="按平方数来分割整数"></a><a href="https://leetcode.cn/problems/perfect-squares/description/">按平方数来分割整数</a></h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<blockquote>
<p>输入：n = 12<br>输出：3<br>解释：12 = 4 + 4 + 4</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = Math.min(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = minn + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>上面的更简洁</strong></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = generateSquareList(n);</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> square : squareList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (square &gt; i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(min, dp[i - square] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">generateSquareList</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">square</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (square &lt;= n) &#123;</span><br><span class="line">        squareList.add(square);</span><br><span class="line">        square += diff;</span><br><span class="line">        diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> squareList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意:四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。</strong></p>
<h2 id="分割字符串求映射的可能数"><a href="#分割字符串求映射的可能数" class="headerlink" title="分割字符串求映射的可能数"></a><a href="https://leetcode.cn/problems/decode-ways/description/">分割字符串求映射的可能数</a></h2><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：<br>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：<br>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。<br>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。<br>题目数据保证答案肯定是一个 32 位 的整数。</p>
<blockquote>
<p>输入：s = “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//字符串长度为0</span></span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">//字符串长度为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//最后一个字符</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>]; <span class="comment">//最后一个字符不是0  最后一个字符单独成为一个item</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;0&#x27;</span>) &#123; </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">//倒数第二个字符等于0    那么没办法最后两个字符成为一个item因此跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];  <span class="comment">//再加上最后两个字符成为一个item</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-最长递增子序列"><a href="#5-最长递增子序列" class="headerlink" title="5.最长递增子序列"></a>5.最长递增子序列</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a></h2><blockquote>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//dp[i]表示以i为结尾的最长子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                max = Math.max(max, dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长摆动子序列"><a href="#最长摆动子序列" class="headerlink" title="最长摆动子序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">最长摆动子序列</a></h2><blockquote>
<p>输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</p>
</blockquote>
<p><strong>思路:</strong><br>up[i]表示以i结尾最后是上升的摆动子序列的最大长度<br>down[i]表示以i结尾最后是下降的摆动子序列的最大长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up[i] = \begin&#123;cases&#125;</span><br><span class="line">up[i-1],\quad \text &#123;if nums[i]  ⩽ nums[i-1] &#125;  \\</span><br><span class="line"></span><br><span class="line">max(up[i-1],down[i-1]+1) \quad\text&#123;if nums[i]  &gt; nums[i-1]&#125;</span><br><span class="line">\end&#123;cases&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">down[i] = \begin&#123;cases&#125;</span><br><span class="line">down[i-1],\quad \text &#123;if nums[i-1]  ⩽ nums[i] &#125;  \\</span><br><span class="line"></span><br><span class="line">max(up[i-1]+1,down[i-1]) \quad\text&#123;if nums[i-1]  &gt; nums[i]&#125;</span><br><span class="line">\end&#123;cases&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] up = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] down = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//以nums[0]结尾的只有一个元素,上身和下降摆动序列最大长度都为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = Math.max(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = Math.max(up[i - <span class="number">1</span>] + <span class="number">1</span>, down[i - <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>可以对空间进行进一步优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h1><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>
<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p>
<ul>
<li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li>
<li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li>
</ul>
<p>综上，最长公共子序列的状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = \begin&#123;cases&#125;</span><br><span class="line">dp[i-1][j-1]+1,\quad \text &#123;if   SL[i] == SL[j] &#125;  \\</span><br><span class="line"></span><br><span class="line">max(dp[i-1][j],dp[i][j-1] ), \quad\text&#123;if   SL[i] != SL[j] &#125;</span><br><span class="line">\end&#123;cases&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p>
<h2 id="两个字符串的最长公共子序列"><a href="#两个字符串的最长公共子序列" class="headerlink" title="两个字符串的最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">两个字符串的最长公共子序列</a></h2><blockquote>
<p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length(), n2 = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  <span class="comment">//长度为i的text1和长度为j的text2的最长公共</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-0-1背包"><a href="#7-0-1背包" class="headerlink" title="7. 0-1背包"></a>7. 0-1背包</h1><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。<strong>设第 i 件物品体积为 w，价值为 v</strong>，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li>
<li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = </span><br><span class="line"></span><br><span class="line">max(dp[i-1][j],dp[i-1][j-w] + v ) \quad\text&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong><br>在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[j] = </span><br><span class="line"></span><br><span class="line">max(dp[j],dp[j-w] + v ) \quad\text&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型</strong></p>
<ul>
<li><p>01背包:每个物品只有一个,因次只有选和不选两种选择</p>
</li>
<li><p>完全背包：物品数量为无限个   <strong>完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</strong></p>
</li>
<li><p>多重背包：物品数量有限制</p>
</li>
<li><p>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</p>
</li>
<li><p>其它：物品之间相互约束或者依赖  <strong>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</strong></p>
</li>
</ul>
<h2 id="划分数组为和相等的两部分"><a href="#划分数组为和相等的两部分" class="headerlink" title="划分数组为和相等的两部分"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">划分数组为和相等的两部分</a></h2><blockquote>
<p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//01背包问题：重量w就是各个数值，价值v不明，要求背包里容量Weight为sum/2，dp[j]表示容量为j的背包能否刚好装下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span>(sums % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">Weight</span> <span class="operator">=</span> sums/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[Weight+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= N ; i++ )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Weight ; j &gt;= <span class="number">1</span>; j--)&#123; <span class="comment">// j&gt;=1 是因为题目说了重量w只可能是正整数</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w)&#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j-w]; <span class="comment">//dp[j]表示不选当前这个数，dp[j-w]表示选</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者简洁的下面的写法</span></span><br><span class="line">        <span class="comment">// for(int num : nums)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = Weight ; j &gt;= num ; j--)&#123;</span></span><br><span class="line">        <span class="comment">//         dp[j] = dp[j] || dp[j - num];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[Weight];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改变一组数的正负号使得它们的和为一给定数"><a href="#改变一组数的正负号使得它们的和为一给定数" class="headerlink" title="改变一组数的正负号使得它们的和为一给定数"></a><a href="https://leetcode.cn/problems/target-sum/description/">改变一组数的正负号使得它们的和为一给定数</a></h2><blockquote>
<p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p>
</blockquote>
<p><strong>题解:</strong><br>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。<br>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                  sum(P) - sum(N) = target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//01背包问题，重量w就是各个数值，价值v不明，要求背包</span></span><br><span class="line">    <span class="comment">//里容量Weight为(target + sums) / 2;dp[j]表示容量为j的背包装下的方法数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到一个集合 其和等于 (target + sum(nums))/2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sums &lt; target || (sums + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> (target + sums) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(W+<span class="number">1</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//共有1种选法可使最终目标和为target，即全选负号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W ; j &gt;= num ; j --)&#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-num]; <span class="comment">//dp[j]表示不选这个数时的方法数,dp[j-num]表示选这个数时的方法数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="m个0n个1构成最大长度的字符串子集-多维01背包"><a href="#m个0n个1构成最大长度的字符串子集-多维01背包" class="headerlink" title="m个0n个1构成最大长度的字符串子集(多维01背包)"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">m个0n个1构成最大长度的字符串子集(多维01背包)</a></h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。<br>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<blockquote>
<p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</span></span><br><span class="line"><span class="comment">//dp[i][j]表示i个0和j个1的最大子集长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;    <span class="comment">// 求出每个元素的重量w部分，这里有两个维度的w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> <span class="number">0</span>, zeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                zeros++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ones++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= zeros; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= ones; j--) &#123;</span><br><span class="line">                <span class="comment">//dp[i][j]表示不选这个字符串 ，dp[i-zeros][j-ones]表示选这个字符串</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找零钱的最少硬币数"><a href="#找零钱的最少硬币数" class="headerlink" title="找零钱的最少硬币数"></a><a href="https://leetcode.cn/problems/coin-change/description/">找零钱的最少硬币数</a></h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>你可以认为每种硬币的数量是无限的。</p>
<blockquote>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p>
</blockquote>
<hr>
<p><strong>因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//完全背包问题，W是amount，w是每个数的值，v不明，dp[j]表示容量为j的情况下所需的最小硬币个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span> || coins == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> amount;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Arrays.fill(dp,amount+<span class="number">33</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt;= W; j++) &#123; <span class="comment">//完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</span></span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount+<span class="number">33</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找零钱的硬币数组合"><a href="#找零钱的硬币数组合" class="headerlink" title=" 找零钱的硬币数组合"></a><a href="https://leetcode.cn/problems/coin-change-ii/"> 找零钱的硬币数组合</a></h2><blockquote>
<p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
</blockquote>
<hr>
<p><strong>注意这道题和下面的377. 组合总和 Ⅳ的区别是这里是不计较顺序的,所以先遍历每个物品,再遍历每个重量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//完全背包问题，注意要正序遍历才行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (coins == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//凑出金额为0的方式是一种：全不选</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="377-组合总和-有顺序的完全背包问题"><a href="#377-组合总和-有顺序的完全背包问题" class="headerlink" title="377. 组合总和(有顺序的完全背包问题)"></a><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和(有顺序的完全背包问题)</a></h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。<br>题目数据保证答案符合 32 位整数范围。</p>
<blockquote>
<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>
</blockquote>
<hr>
<p><strong>注意和上一题的硬币数的组合数的区别.求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-num &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串按单词列表分割"><a href="#字符串按单词列表分割" class="headerlink" title="字符串按单词列表分割"></a><a href="https://leetcode.cn/problems/word-break/description/">字符串按单词列表分割</a></h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<blockquote>
<p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p>
</blockquote>
<hr>
<p>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。</p>
<p>该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，<strong>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断s的前n个字符能否被拼接</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict) &#123;   <span class="comment">// 对物品的迭代应该放在最里层</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">                <span class="comment">//s.substring(i - len, i)刚好就是长度等于len的那个末尾的子串</span></span><br><span class="line">                <span class="keyword">if</span> (i-len &gt;= <span class="number">0</span> &amp;&amp; word.equals(s.substring(i - len, i))) &#123;</span><br><span class="line">                    <span class="comment">//不选的话那就取决于前面的单词能否拼接处</span></span><br><span class="line">                    <span class="comment">//选的话那就看s的前i-len个字符能否被拼接</span></span><br><span class="line">                    dp[i] = dp[i] || dp[i - len];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-股票交易"><a href="#8-股票交易" class="headerlink" title="8.股票交易"></a>8.股票交易</h1><h2 id="股票问题之一次交易"><a href="#股票问题之一次交易" class="headerlink" title="股票问题之一次交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">股票问题之一次交易</a></h2><blockquote>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">soFarMin</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (soFarMin &gt; prices[i]) soFarMin = prices[i];</span><br><span class="line">        <span class="keyword">else</span> max = Math.max(max, prices[i] - soFarMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="股票问题之多次交易"><a href="#股票问题之多次交易" class="headerlink" title="股票问题之多次交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">股票问题之多次交易</a></h2><p><strong>题解:</strong><br>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。<br>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。<br><code>简而言之,只要比前一天有赚就卖</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            profit += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="多次买卖-但卖需要冷却期1天的股票交易"><a href="#多次买卖-但卖需要冷却期1天的股票交易" class="headerlink" title="多次买卖,但卖需要冷却期1天的股票交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">多次买卖,但卖需要冷却期1天的股票交易</a></h2><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<blockquote>
<p>输入: prices = [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
</blockquote>
<hr>
<p>下面以上面prices = [1,2,3,0,2]为例子,看下四个状态数组的变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buy[0] = -1   -prices[0]</span><br><span class="line">s1[0] = -1    -prices[0]</span><br><span class="line">sell[0] = 0</span><br><span class="line">s2[0] = 0</span><br><span class="line">---------</span><br><span class="line">buy[1] = -2</span><br><span class="line">s1[1] = -1</span><br><span class="line">sell[1] = 1</span><br><span class="line">s2[1] = 0</span><br><span class="line">---------</span><br><span class="line">buy[2] = -3</span><br><span class="line">s1[2] = -1</span><br><span class="line">sell[2] = 2</span><br><span class="line">s2[2] = 1</span><br><span class="line">---------</span><br><span class="line">buy[3] = 1</span><br><span class="line">s1[3] = -1</span><br><span class="line">sell[3] = -1</span><br><span class="line">s2[3] = 2</span><br><span class="line">---------</span><br><span class="line">buy[4] = 0</span><br><span class="line">s1[4] = 1</span><br><span class="line">sell[4] = 3</span><br><span class="line">s2[4] = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://tuchuangmweb.oss-cn-shenzhen.aliyuncs.com/mweb/16946155778775..jpg"><br><img src="media/16946155778775.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//buy[i]表示购买了第i天这个股票后的最大总存款</span></span><br><span class="line">    <span class="type">int</span>[] s1 = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//持有小于等于i天的股票后的最大总存款</span></span><br><span class="line">    <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[N];<span class="comment">//卖掉小于等于i天的股票后的最大总存款</span></span><br><span class="line">    <span class="type">int</span>[] s2 = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//在小于i的时候已经卖出了股票，现在第i天处于冷却期或者不持有观望状态的最大总存款</span></span><br><span class="line">    s1[<span class="number">0</span>]=buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buy[i] = s2[i - <span class="number">1</span>] - prices[i];</span><br><span class="line">        s1[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">        sell[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) + prices[i];</span><br><span class="line">        s2[i] = Math.max(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[N - <span class="number">1</span>], s2[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多次买卖-但卖需要交易费用的股票交易"><a href="#多次买卖-但卖需要交易费用的股票交易" class="headerlink" title="多次买卖,但卖需要交易费用的股票交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">多次买卖,但卖需要交易费用的股票交易</a></h2><p><img src="https://tuchuangmweb.oss-cn-shenzhen.aliyuncs.com/mweb/16946155980671..jpg"></p>
<p><img src="media/16946155980671.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] s1 = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] s2 = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buy[i] = Math.max(sell[i - <span class="number">1</span>], s2[i - <span class="number">1</span>]) - prices[i];</span><br><span class="line">        s1[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">        sell[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) - fee + prices[i];</span><br><span class="line">        s2[i] = Math.max(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[N - <span class="number">1</span>], s2[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只能进行两次的股票交易"><a href="#只能进行两次的股票交易" class="headerlink" title="只能进行两次的股票交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">只能进行两次的股票交易</a></h2><blockquote>
<p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<hr>
<p><strong>解题思路</strong><br>该方法基于以下思路：每次操作可以转换当前的状态，我们可以将其看做一个状态机。在每一天，我们有四种可能的状态：</p>
<p>第一次买入股票。 第一次卖出股票。 第二次买入股票。 第二次卖出股票。 因此，我们需要维护四个变量： buy1、sell1、buy2、sell2，分别表示以上四种状态下的最大利润。并且每次操作时，都会改变当前状态和相应的变量值。</p>
<p>具体地，对于每一天 i，我们按照以下顺序更新这些变量：</p>
<p>buy1：表示第一次买入股票时的最大利润。由于初始资金为 0，因此购买股票时需扣钱，这里用负数表示。因此，我们需要取 buy1 和 -prices[i] 中的最大值。 sell1：表示第一次卖出股票时的最大利润。如果在第 i 天卖出股票，那么前一天肯定持有股票。因此，我们需要取 sell1 和 buy1 + prices[i] 中的最大值。 buy2：表示第二次买入股票时的最大利润。如果在第 i 天买入股票，那么前一天必须已经卖出了股票。因此，我们需要取 buy2 和 sell1 - prices[i] 中的最大值。 sell2：表示第二次卖出股票时的最大利润。如果在第 i 天卖出股票，那么前一天必须已经买入了股票。因此，我们需要取 sell2 和 buy2 + prices[i] 中的最大值。 最终的答案即为 sell2，表示最多进行两次交易的最大利润。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -price); <span class="comment">// 第一次买股票</span></span><br><span class="line">            sell1 = Math.max(sell1, buy1 + price); <span class="comment">// 第一次卖股票</span></span><br><span class="line">            buy2 = Math.max(buy2, sell1 - price); <span class="comment">// 第二次买股票</span></span><br><span class="line">            sell2 = Math.max(sell2, buy2 + price); <span class="comment">// 第二次卖股票</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-字符串编辑"><a href="#9-字符串编辑" class="headerlink" title="9.字符串编辑"></a>9.字符串编辑</h1><h2 id="删除两个字符串的字符使它们相等"><a href="#删除两个字符串的字符使它们相等" class="headerlink" title="删除两个字符串的字符使它们相等"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">删除两个字符串的字符使它们相等</a></h2><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。<br>每步 可以删除任意一个字符串中的一个字符。</p>
<blockquote>
<p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p>
</blockquote>
<hr>
<p><strong>可以转换为求两个字符串的最长公共子序列问题。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length(), n = word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m + n - <span class="number">2</span> * dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/description/">编辑距离</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">    <span class="comment">// 定义：s1[0..i] 和 s2[0..j] 的最小编辑距离是 dp[i+1][j+1]</span></span><br><span class="line">    <span class="comment">//dp[i][j]表示长度为i的s1和长度为j的s2的最小编辑距离</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case 空串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 自底向上求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,   <span class="comment">// 删除</span></span><br><span class="line">                    dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,  <span class="comment">// 插入</span></span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>   <span class="comment">// 替换</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 储存着整个 s1 和 s2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制粘贴字符"><a href="#复制粘贴字符" class="headerlink" title="复制粘贴字符"></a><a href="https://leetcode.cn/problems/2-keys-keyboard/description/">复制粘贴字符</a></h2><p>最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：<br>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br>Paste（粘贴）：粘贴 上一次 复制的字符。<br>给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 ‘A’ 。返回能够打印出 n 个 ‘A’ 的最少操作次数。</p>
<blockquote>
<p>输入：3<br>输出：3<br>解释：<br>最初, 只有一个字符 ‘A’。<br>第 1 步, 使用 Copy All 操作。<br>第 2 步, 使用 Paste 操作来获得 ‘AA’。<br>第 3 步, 使用 Paste 操作来获得 ‘AAA’。</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j] + i / j);  <span class="comment">// i/j是表示最后一次的复制，和若干次粘贴的次数</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i / j] + j); <span class="comment">//降低时间复杂度而加的，不然按理说j应该遍历到i-1，这里遍历到根号i， 所以用i/j整体替代前面的dp[j]+i/j得到这个dp[i/j]+j</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="codetop"><a href="#codetop" class="headerlink" title="codetop"></a>codetop</h1><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a></h2><blockquote>
<p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p>
</blockquote>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1] 。<br>示例 2：</p>
<p>输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]<br>输出：5</p>
<hr>
<p>dp[i][j]表示A[i:]和B[j:]的最长公共子数组长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length, m = B.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = Math.max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
