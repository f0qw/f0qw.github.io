<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo使用指南</title>
      <link href="/2024/05/15/%E5%AF%86%E7%A0%81%E6%96%87%E7%AB%A0/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/05/15/%E5%AF%86%E7%A0%81%E6%96%87%E7%AB%A0/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d6d4d8f5661f57967a84f3c38294209e85dff0b4a4403f5e3371daa501b117d9">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186d92b8cfc5f65dbc065731b5deeb1122054b8a160c0f2d856c29b846f888615b2bb00611a19ce3d54d1f042a3155ef5997e23a32f6d4142dec65abfcbac26804af5cd2ea3d6daa94578f61e27c2a374e1d10bab90b70923df4a686115f970194ac1e2dc9ad08e9ba6312ec4b6bf373470e60e7197a8cffd87ad06d7e292727acc3bdbb9aaa57b91bb50efd38f5c9a6350062a2f071747fce68c5f00d3bc6e5103a63d92dab84ee792fff3c6740a31de497f906eea235c87a97cd5aa10eab85844b91fb5a08ef6475c951ff5a2c0d8591752cceb59109efede0f1cd15728e36b3ec2d459cff5cb42b5d7f91e908282519608ff05c2898cc6b96dad813baeca10322a77b332c568cbaeb3f5dde44fc2b47340cb3605418f472be8f70bf356643555d3038511bacdbbc512cb5e658e48885ce5c53c81f60286a16a047f8fa3af0e771550e45ab3830d839e17a9daec9d2cfe6c807d47bccd1cba6f23e61ea913b0dc24096606ea77ef838cea34f7eefd9fe9a2556f85a833d261d8ff4daf64da9691e05a62584cf7b4e713fb6fb8cc0c5ea4a833ff49fddaeaa6921f6ae07934d42f1c77ce040190dcd90485a7ef79012b30f7716cb4b8f27111dc04f590abd157ae70cf1d7e00e4bf3e55c087e895035e09ffd127a465f5003de88ac520ada42d4280ae4443bfcba6779bcbfc5643c52425a223efe99317b42c1279834a96080b942b0e7b8f9e38bf2a37d8e9720d82cc792b0bc99016382d14f9e4081b996184564dcd08479670240b615603883b215ce1bfd14e889271d84527b88ee64c5650a94c01007222bcf04ca80f0c8179ccee5f060f0de8523836c4848efe14bc6bcc05d776b688c18182babc4143740b0340453f44d6d3d1d806c5643c38ee66ab9e253b1395114a2116e5e2e09b045748b85e01b431454a16a4f7a6bd82ee03610c91287604217ac374e40e32e2cecf6c16835bd3aae348004188743ab54c593fe8820a82ddaefea41d31bde0f4933d5ab2e31fee6ccd7a824d38853d599d25c8d9f7f2afc1e93414d3d7050c018ea828efd95459d45720ab58a15bb5e17ab5a737dfa4318b9a802166c3d8902b22bc08166e8350941ab20fd7d1fb96bb9b2fb4cce7b58b5aaa70e4c4237eaffd0d19820fd0704ab3d0fa0d95e021a92f0355be56c41a2f40a61c2ea8e91b3d2c6d5c2e167229a21d95618c26dc6c20feba77570f50573df4c6240b983f334f1c8216eafabe409919d8bae9123611f7660481de91a821c58dec601f8be79cdfc7030fea2b3226149aa41e5c071388cc20ff537fa0e67b7298bb6b5d82100ffc4475698f7bb016c7ad68826371d468e46d915df33ee90cdd56347c950bd2403099559c30e51cf86fc15ee852479e6db36140d91760eb7a1e24c45fc1167a768af566769e2e6342f83869f7e856d8c412f4b431ce7d33b8e805461da483aab0f2649cc647be9472b7b7585d4e3292ceedbd03c31f05fae7e5574f80d6201cf64d6c924c848566497fd366b14ca91d3e727573ae1e0cfd1464685cb650f2bf5eaba8e8031fc285bfb60c9679c8802acc334b33a26e951ea8eb923266712c9ca1e0f6c9f6277c6191c4b2e4798ec66421c32bbc7e74999d787787576f71a32a73755043eb0a5ef9bdb9e032f06195ed5b210ed1d9ca10ee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2023/09/13/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/09/13/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h1><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a></h2><p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p><p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p><p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-1] + dp[i-2]</span><br></pre></td></tr></table></figure><p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别对应0   1      2层的方法数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>, q = <span class="number">1</span>, r = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/description/">打家劫舍</a></h2><p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。</p><blockquote><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。(临近的2和3不能同时偷窃)<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。<br>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i-2] + nums[i]  ,  dp[i-1])</span><br></pre></td></tr></table></figure><p><strong>精简版答案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , q = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = Math.max(p+nums[i],q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分别对应-1      0        1   下标的偷窃的最高金额，因此后面的for从下标2开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , q = nums[<span class="number">0</span>] , r = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = Math.max(p+nums[i],q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形区域打家劫舍"><a href="#环形区域打家劫舍" class="headerlink" title="环形区域打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber-ii/description/">环形区域打家劫舍</a></h2><blockquote><p>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抢劫如下闭区间的下标之间的最大金额</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p q r相当于-3   -2     -1   位置的最大金额</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) &#123;</span><br><span class="line">        p = q; <span class="comment">//类似于dp[i-2]</span></span><br><span class="line">        q = r; <span class="comment">//类似于求dp[i-1]</span></span><br><span class="line">        r = Math.max(p + nums[i], q); <span class="comment">//类似求dp[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-矩阵路径"><a href="#2-矩阵路径" class="headerlink" title="2.矩阵路径"></a>2.矩阵路径</h1><h2 id="从左上角到右下角的最小路径和"><a href="#从左上角到右下角的最小路径和" class="headerlink" title="从左上角到右下角的最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/description/">从左上角到右下角的最小路径和</a></h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p><blockquote><p>输入：grid =<br>[[1,3,1],<br>[1,5,1],<br>[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p></blockquote><ul><li>状态定义: 设dp为大小m乘以n的矩阵,dp[i][j]表示走到(i,j)的最小路径和,则题目求的是dp[m-1][n-1]</li><li>注意:这里可以不用真的定义dp数组,可以原地用grid数组修改,原因是每次被覆盖后不会再被使用</li><li>因此时间复杂度是O(m*n),空间复杂度是O(1),直接修改矩阵,不需要额外的空间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从矩阵左上角到右下角的路径总数"><a href="#从矩阵左上角到右下角的路径总数" class="headerlink" title="从矩阵左上角到右下角的路径总数"></a><a href="https://leetcode.cn/problems/unique-paths/description/">从矩阵左上角到右下角的路径总数</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p><blockquote><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向下</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">S</span> <span class="operator">=</span> m + n - <span class="number">2</span>;  <span class="comment">// 总共的移动次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">D</span> <span class="operator">=</span> m - <span class="number">1</span>;      <span class="comment">// 向下的移动次数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= D; i++) &#123;</span><br><span class="line">        ret = ret * (S - D + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-数组区间"><a href="#3-数组区间" class="headerlink" title="3.数组区间"></a>3.数组区间</h1><h2 id="数组区间和"><a href="#数组区间和" class="headerlink" title="数组区间和"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">数组区间和</a></h2><p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用这个函数可以求出数组[i,j]闭区间的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中等差递增子区间的个数"><a href="#数组中等差递增子区间的个数" class="headerlink" title="数组中等差递增子区间的个数"></a><a href="https://leetcode.cn/problems/arithmetic-slices/description/">数组中等差递增子区间的个数</a></h2><blockquote><p>A = [0, 1, 2, 3, 4]<br>答案是6,如下子区间:<br>[0, 1, 2],<br>[1, 2, 3],<br>[0, 1, 2, 3],<br>[0, 1, 2, 3, 4],<br>[ 1, 2, 3, 4],<br>[2, 3, 4]</p></blockquote><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p><p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。<br>解释上面的答案可以这样看:</p><blockquote><p>dp[2] = 1<br>    [0, 1, 2]<br>dp[3] = dp[2] + 1 = 2<br>    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3<br>    [1, 2, 3]     // 新的递增子区间<br>dp[4] = dp[3] + 1 = 3<br>    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4<br>    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4<br>    [2, 3, 4]        // 新的递增子区间</p></blockquote><p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p><p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt : dp) &#123;</span><br><span class="line">        total += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-分割整数"><a href="#4-分割整数" class="headerlink" title="4.分割整数"></a>4.分割整数</h1><h2 id="整数n拆分为k-个和并使乘积最大化"><a href="#整数n拆分为k-个和并使乘积最大化" class="headerlink" title="整数n拆分为k 个和并使乘积最大化"></a><a href="https://leetcode.cn/problems/integer-break/description/">整数n拆分为k 个和并使乘积最大化</a></h2><blockquote><p>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//1是不可再拆分，需特殊处理</span></span><br><span class="line">    <span class="comment">//dp[i]可以拆分两两个数j  和  i-j  或者 i -j进一步拆分成其他的，其乘积最大值就是dp[i-j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//dp[i]在内循环里一直在更新更大的值</span></span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按平方数来分割整数"><a href="#按平方数来分割整数" class="headerlink" title="按平方数来分割整数"></a><a href="https://leetcode.cn/problems/perfect-squares/description/">按平方数来分割整数</a></h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><blockquote><p>输入：n = 12<br>输出：3<br>解释：12 = 4 + 4 + 4</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = Math.min(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = minn + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>上面的更简洁</strong></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = generateSquareList(n);</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> square : squareList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (square &gt; i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(min, dp[i - square] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">generateSquareList</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">square</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (square &lt;= n) &#123;</span><br><span class="line">        squareList.add(square);</span><br><span class="line">        square += diff;</span><br><span class="line">        diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> squareList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意:四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。</strong></p><h2 id="分割字符串求映射的可能数"><a href="#分割字符串求映射的可能数" class="headerlink" title="分割字符串求映射的可能数"></a><a href="https://leetcode.cn/problems/decode-ways/description/">分割字符串求映射的可能数</a></h2><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：<br>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：<br>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。<br>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。<br>题目数据保证答案肯定是一个 32 位 的整数。</p><blockquote><p>输入：s = “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//字符串长度为0</span></span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">//字符串长度为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//最后一个字符</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>]; <span class="comment">//最后一个字符不是0  最后一个字符单独成为一个item</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;0&#x27;</span>) &#123; </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">//倒数第二个字符等于0    那么没办法最后两个字符成为一个item因此跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];  <span class="comment">//再加上最后两个字符成为一个item</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-最长递增子序列"><a href="#5-最长递增子序列" class="headerlink" title="5.最长递增子序列"></a>5.最长递增子序列</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a></h2><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//dp[i]表示以i为结尾的最长子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                max = Math.max(max, dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长摆动子序列"><a href="#最长摆动子序列" class="headerlink" title="最长摆动子序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">最长摆动子序列</a></h2><blockquote><p>输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</p></blockquote><p><strong>思路:</strong><br>up[i]表示以i结尾最后是上升的摆动子序列的最大长度<br>down[i]表示以i结尾最后是下降的摆动子序列的最大长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">up[i] = \begin&#123;cases&#125;</span><br><span class="line">up[i-1],\quad \text &#123;if nums[i]  ⩽ nums[i-1] &#125;  \\</span><br><span class="line"></span><br><span class="line">max(up[i-1],down[i-1]+1) \quad\text&#123;if nums[i]  &gt; nums[i-1]&#125;</span><br><span class="line">\end&#123;cases&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">down[i] = \begin&#123;cases&#125;</span><br><span class="line">down[i-1],\quad \text &#123;if nums[i-1]  ⩽ nums[i] &#125;  \\</span><br><span class="line"></span><br><span class="line">max(up[i-1]+1,down[i-1]) \quad\text&#123;if nums[i-1]  &gt; nums[i]&#125;</span><br><span class="line">\end&#123;cases&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] up = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] down = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//以nums[0]结尾的只有一个元素,上身和下降摆动序列最大长度都为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = Math.max(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = Math.max(up[i - <span class="number">1</span>] + <span class="number">1</span>, down[i - <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>可以对空间进行进一步优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h1><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p><p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p><ul><li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li><li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li></ul><p>综上，最长公共子序列的状态转移方程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = \begin&#123;cases&#125;</span><br><span class="line">dp[i-1][j-1]+1,\quad \text &#123;if   SL[i] == SL[j] &#125;  \\</span><br><span class="line"></span><br><span class="line">max(dp[i-1][j],dp[i][j-1] ), \quad\text&#123;if   SL[i] != SL[j] &#125;</span><br><span class="line">\end&#123;cases&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p><h2 id="两个字符串的最长公共子序列"><a href="#两个字符串的最长公共子序列" class="headerlink" title="两个字符串的最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">两个字符串的最长公共子序列</a></h2><blockquote><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length(), n2 = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  <span class="comment">//长度为i的text1和长度为j的text2的最长公共</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-0-1背包"><a href="#7-0-1背包" class="headerlink" title="7. 0-1背包"></a>7. 0-1背包</h1><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。<strong>设第 i 件物品体积为 w，价值为 v</strong>，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p><ul><li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li><li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li></ul><p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = </span><br><span class="line"></span><br><span class="line">max(dp[i-1][j],dp[i-1][j-w] + v ) \quad\text&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间优化</strong><br>在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = </span><br><span class="line"></span><br><span class="line">max(dp[j],dp[j-w] + v ) \quad\text&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型</strong></p><ul><li><p>01背包:每个物品只有一个,因次只有选和不选两种选择</p></li><li><p>完全背包：物品数量为无限个   <strong>完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</strong></p></li><li><p>多重背包：物品数量有限制</p></li><li><p>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</p></li><li><p>其它：物品之间相互约束或者依赖  <strong>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</strong></p></li></ul><h2 id="划分数组为和相等的两部分"><a href="#划分数组为和相等的两部分" class="headerlink" title="划分数组为和相等的两部分"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">划分数组为和相等的两部分</a></h2><blockquote><p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//01背包问题：重量w就是各个数值，价值v不明，要求背包里容量Weight为sum/2，dp[j]表示容量为j的背包能否刚好装下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span>(sums % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">Weight</span> <span class="operator">=</span> sums/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[Weight+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= N ; i++ )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Weight ; j &gt;= <span class="number">1</span>; j--)&#123; <span class="comment">// j&gt;=1 是因为题目说了重量w只可能是正整数</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w)&#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j-w]; <span class="comment">//dp[j]表示不选当前这个数，dp[j-w]表示选</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者简洁的下面的写法</span></span><br><span class="line">        <span class="comment">// for(int num : nums)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = Weight ; j &gt;= num ; j--)&#123;</span></span><br><span class="line">        <span class="comment">//         dp[j] = dp[j] || dp[j - num];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[Weight];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改变一组数的正负号使得它们的和为一给定数"><a href="#改变一组数的正负号使得它们的和为一给定数" class="headerlink" title="改变一组数的正负号使得它们的和为一给定数"></a><a href="https://leetcode.cn/problems/target-sum/description/">改变一组数的正负号使得它们的和为一给定数</a></h2><blockquote><p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p></blockquote><p><strong>题解:</strong><br>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。<br>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                  sum(P) - sum(N) = target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) = target + sum(nums)</span><br></pre></td></tr></table></figure><p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//01背包问题，重量w就是各个数值，价值v不明，要求背包</span></span><br><span class="line">    <span class="comment">//里容量Weight为(target + sums) / 2;dp[j]表示容量为j的背包装下的方法数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到一个集合 其和等于 (target + sum(nums))/2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sums &lt; target || (sums + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> (target + sums) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(W+<span class="number">1</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//共有1种选法可使最终目标和为target，即全选负号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W ; j &gt;= num ; j --)&#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-num]; <span class="comment">//dp[j]表示不选这个数时的方法数,dp[j-num]表示选这个数时的方法数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="m个0n个1构成最大长度的字符串子集-多维01背包"><a href="#m个0n个1构成最大长度的字符串子集-多维01背包" class="headerlink" title="m个0n个1构成最大长度的字符串子集(多维01背包)"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">m个0n个1构成最大长度的字符串子集(多维01背包)</a></h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。<br>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p><blockquote><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</span></span><br><span class="line"><span class="comment">//dp[i][j]表示i个0和j个1的最大子集长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;    <span class="comment">// 求出每个元素的重量w部分，这里有两个维度的w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> <span class="number">0</span>, zeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                zeros++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ones++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= zeros; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= ones; j--) &#123;</span><br><span class="line">                <span class="comment">//dp[i][j]表示不选这个字符串 ，dp[i-zeros][j-ones]表示选这个字符串</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找零钱的最少硬币数"><a href="#找零钱的最少硬币数" class="headerlink" title="找零钱的最少硬币数"></a><a href="https://leetcode.cn/problems/coin-change/description/">找零钱的最少硬币数</a></h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>你可以认为每种硬币的数量是无限的。</p><blockquote><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p></blockquote><hr><p><strong>因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//完全背包问题，W是amount，w是每个数的值，v不明，dp[j]表示容量为j的情况下所需的最小硬币个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span> || coins == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> amount;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Arrays.fill(dp,amount+<span class="number">33</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt;= W; j++) &#123; <span class="comment">//完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</span></span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount+<span class="number">33</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找零钱的硬币数组合"><a href="#找零钱的硬币数组合" class="headerlink" title=" 找零钱的硬币数组合"></a><a href="https://leetcode.cn/problems/coin-change-ii/"> 找零钱的硬币数组合</a></h2><blockquote><p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><hr><p><strong>注意这道题和下面的377. 组合总和 Ⅳ的区别是这里是不计较顺序的,所以先遍历每个物品,再遍历每个重量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//完全背包问题，注意要正序遍历才行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (coins == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//凑出金额为0的方式是一种：全不选</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="377-组合总和-有顺序的完全背包问题"><a href="#377-组合总和-有顺序的完全背包问题" class="headerlink" title="377. 组合总和(有顺序的完全背包问题)"></a><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和(有顺序的完全背包问题)</a></h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。<br>题目数据保证答案符合 32 位整数范围。</p><blockquote><p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p></blockquote><hr><p><strong>注意和上一题的硬币数的组合数的区别.求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-num &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串按单词列表分割"><a href="#字符串按单词列表分割" class="headerlink" title="字符串按单词列表分割"></a><a href="https://leetcode.cn/problems/word-break/description/">字符串按单词列表分割</a></h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><blockquote><p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p></blockquote><hr><p>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。</p><p>该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，<strong>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断s的前n个字符能否被拼接</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict) &#123;   <span class="comment">// 对物品的迭代应该放在最里层</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">                <span class="comment">//s.substring(i - len, i)刚好就是长度等于len的那个末尾的子串</span></span><br><span class="line">                <span class="keyword">if</span> (i-len &gt;= <span class="number">0</span> &amp;&amp; word.equals(s.substring(i - len, i))) &#123;</span><br><span class="line">                    <span class="comment">//不选的话那就取决于前面的单词能否拼接处</span></span><br><span class="line">                    <span class="comment">//选的话那就看s的前i-len个字符能否被拼接</span></span><br><span class="line">                    dp[i] = dp[i] || dp[i - len];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-股票交易"><a href="#8-股票交易" class="headerlink" title="8.股票交易"></a>8.股票交易</h1><h2 id="股票问题之一次交易"><a href="#股票问题之一次交易" class="headerlink" title="股票问题之一次交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">股票问题之一次交易</a></h2><blockquote><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">soFarMin</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (soFarMin &gt; prices[i]) soFarMin = prices[i];</span><br><span class="line">        <span class="keyword">else</span> max = Math.max(max, prices[i] - soFarMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="股票问题之多次交易"><a href="#股票问题之多次交易" class="headerlink" title="股票问题之多次交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">股票问题之多次交易</a></h2><p><strong>题解:</strong><br>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。<br>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。<br><code>简而言之,只要比前一天有赚就卖</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            profit += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多次买卖-但卖需要冷却期1天的股票交易"><a href="#多次买卖-但卖需要冷却期1天的股票交易" class="headerlink" title="多次买卖,但卖需要冷却期1天的股票交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">多次买卖,但卖需要冷却期1天的股票交易</a></h2><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><blockquote><p>输入: prices = [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p></blockquote><hr><p>下面以上面prices = [1,2,3,0,2]为例子,看下四个状态数组的变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">buy[0] = -1   -prices[0]</span><br><span class="line">s1[0] = -1    -prices[0]</span><br><span class="line">sell[0] = 0</span><br><span class="line">s2[0] = 0</span><br><span class="line">---------</span><br><span class="line">buy[1] = -2</span><br><span class="line">s1[1] = -1</span><br><span class="line">sell[1] = 1</span><br><span class="line">s2[1] = 0</span><br><span class="line">---------</span><br><span class="line">buy[2] = -3</span><br><span class="line">s1[2] = -1</span><br><span class="line">sell[2] = 2</span><br><span class="line">s2[2] = 1</span><br><span class="line">---------</span><br><span class="line">buy[3] = 1</span><br><span class="line">s1[3] = -1</span><br><span class="line">sell[3] = -1</span><br><span class="line">s2[3] = 2</span><br><span class="line">---------</span><br><span class="line">buy[4] = 0</span><br><span class="line">s1[4] = 1</span><br><span class="line">sell[4] = 3</span><br><span class="line">s2[4] = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tuchuangmweb.oss-cn-shenzhen.aliyuncs.com/mweb/16946155778775..jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//buy[i]表示购买了第i天这个股票后的最大总存款</span></span><br><span class="line">    <span class="type">int</span>[] s1 = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//持有小于等于i天的股票后的最大总存款</span></span><br><span class="line">    <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[N];<span class="comment">//卖掉小于等于i天的股票后的最大总存款</span></span><br><span class="line">    <span class="type">int</span>[] s2 = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//在小于i的时候已经卖出了股票，现在第i天处于冷却期或者不持有观望状态的最大总存款</span></span><br><span class="line">    s1[<span class="number">0</span>]=buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buy[i] = s2[i - <span class="number">1</span>] - prices[i];</span><br><span class="line">        s1[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">        sell[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) + prices[i];</span><br><span class="line">        s2[i] = Math.max(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[N - <span class="number">1</span>], s2[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多次买卖-但卖需要交易费用的股票交易"><a href="#多次买卖-但卖需要交易费用的股票交易" class="headerlink" title="多次买卖,但卖需要交易费用的股票交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">多次买卖,但卖需要交易费用的股票交易</a></h2><p><img src="https://tuchuangmweb.oss-cn-shenzhen.aliyuncs.com/mweb/16946155980671..jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] s1 = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] s2 = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buy[i] = Math.max(sell[i - <span class="number">1</span>], s2[i - <span class="number">1</span>]) - prices[i];</span><br><span class="line">        s1[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">        sell[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) - fee + prices[i];</span><br><span class="line">        s2[i] = Math.max(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[N - <span class="number">1</span>], s2[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只能进行两次的股票交易"><a href="#只能进行两次的股票交易" class="headerlink" title="只能进行两次的股票交易"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">只能进行两次的股票交易</a></h2><blockquote><p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p></blockquote><hr><p><strong>解题思路</strong><br>该方法基于以下思路：每次操作可以转换当前的状态，我们可以将其看做一个状态机。在每一天，我们有四种可能的状态：</p><p>第一次买入股票。 第一次卖出股票。 第二次买入股票。 第二次卖出股票。 因此，我们需要维护四个变量： buy1、sell1、buy2、sell2，分别表示以上四种状态下的最大利润。并且每次操作时，都会改变当前状态和相应的变量值。</p><p>具体地，对于每一天 i，我们按照以下顺序更新这些变量：</p><p>buy1：表示第一次买入股票时的最大利润。由于初始资金为 0，因此购买股票时需扣钱，这里用负数表示。因此，我们需要取 buy1 和 -prices[i] 中的最大值。 sell1：表示第一次卖出股票时的最大利润。如果在第 i 天卖出股票，那么前一天肯定持有股票。因此，我们需要取 sell1 和 buy1 + prices[i] 中的最大值。 buy2：表示第二次买入股票时的最大利润。如果在第 i 天买入股票，那么前一天必须已经卖出了股票。因此，我们需要取 buy2 和 sell1 - prices[i] 中的最大值。 sell2：表示第二次卖出股票时的最大利润。如果在第 i 天卖出股票，那么前一天必须已经买入了股票。因此，我们需要取 sell2 和 buy2 + prices[i] 中的最大值。 最终的答案即为 sell2，表示最多进行两次交易的最大利润。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -price); <span class="comment">// 第一次买股票</span></span><br><span class="line">            sell1 = Math.max(sell1, buy1 + price); <span class="comment">// 第一次卖股票</span></span><br><span class="line">            buy2 = Math.max(buy2, sell1 - price); <span class="comment">// 第二次买股票</span></span><br><span class="line">            sell2 = Math.max(sell2, buy2 + price); <span class="comment">// 第二次卖股票</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-字符串编辑"><a href="#9-字符串编辑" class="headerlink" title="9.字符串编辑"></a>9.字符串编辑</h1><h2 id="删除两个字符串的字符使它们相等"><a href="#删除两个字符串的字符使它们相等" class="headerlink" title="删除两个字符串的字符使它们相等"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">删除两个字符串的字符使它们相等</a></h2><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。<br>每步 可以删除任意一个字符串中的一个字符。</p><blockquote><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p></blockquote><hr><p><strong>可以转换为求两个字符串的最长公共子序列问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length(), n = word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m + n - <span class="number">2</span> * dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/description/">编辑距离</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">    <span class="comment">// 定义：s1[0..i] 和 s2[0..j] 的最小编辑距离是 dp[i+1][j+1]</span></span><br><span class="line">    <span class="comment">//dp[i][j]表示长度为i的s1和长度为j的s2的最小编辑距离</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case 空串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 自底向上求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,   <span class="comment">// 删除</span></span><br><span class="line">                    dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,  <span class="comment">// 插入</span></span><br><span class="line">                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>   <span class="comment">// 替换</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 储存着整个 s1 和 s2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制粘贴字符"><a href="#复制粘贴字符" class="headerlink" title="复制粘贴字符"></a><a href="https://leetcode.cn/problems/2-keys-keyboard/description/">复制粘贴字符</a></h2><p>最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：<br>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br>Paste（粘贴）：粘贴 上一次 复制的字符。<br>给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 ‘A’ 。返回能够打印出 n 个 ‘A’ 的最少操作次数。</p><blockquote><p>输入：3<br>输出：3<br>解释：<br>最初, 只有一个字符 ‘A’。<br>第 1 步, 使用 Copy All 操作。<br>第 2 步, 使用 Paste 操作来获得 ‘AA’。<br>第 3 步, 使用 Paste 操作来获得 ‘AAA’。</p></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j] + i / j);  <span class="comment">// i/j是表示最后一次的复制，和若干次粘贴的次数</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i / j] + j); <span class="comment">//降低时间复杂度而加的，不然按理说j应该遍历到i-1，这里遍历到根号i， 所以用i/j整体替代前面的dp[j]+i/j得到这个dp[i/j]+j</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="codetop"><a href="#codetop" class="headerlink" title="codetop"></a>codetop</h1><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a></h2><blockquote><p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p></blockquote><p>示例 1：</p><p>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1] 。<br>示例 2：</p><p>输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]<br>输出：5</p><hr><p>dp[i][j]表示A[i:]和B[j:]的最长公共子数组长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length, m = B.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = Math.max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人记事</title>
      <link href="/2023/03/13/%E5%AF%86%E7%A0%81%E6%96%87%E7%AB%A0/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E4%BA%8B/"/>
      <url>/2023/03/13/%E5%AF%86%E7%A0%81%E6%96%87%E7%AB%A0/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="449696f1bd88c6427329ef24294ea5ae019ac4db2c1218d7d857a1a12bd2aa14">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f58459281863d2858fb53067ead32f801fff80eb1d38efdc560a4fe6ce5b8dabf5941107d45ae03f02dd92c2255375871de5ea4cf8ddf22acc2a6d47db026e699e1a2460ae3e96bf3f72ec086aac39764a34bba4f3b6dd7fe082431a216b4eab3ae792b3284b15ccc40245459940fd45646093ed11a8a56b3a3df88edd112ed0bf59acca95f492ec92a39971cf6e6f1fde755b456d2b8ebc8f0e92fa84311912db69580d854ea6f98961d3a101472e65f73fea755976ba165c6559e17c43d9400190f9500bcc4a39a5e5973ffbd9c11579ce5820d12e34b65ea08666d1116af1cfcd33d07057d498034bcf8739694372e013f0881b9d417cc1dc1003715adaafc720b18b0e6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring和SpringMVC学习笔记</title>
      <link href="/2022/08/22/Java/Spring%E5%92%8CSpringMVC/"/>
      <url>/2022/08/22/Java/Spring%E5%92%8CSpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="一、IOC"><a href="#一、IOC" class="headerlink" title="一、IOC"></a>一、IOC</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul><li>IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源；</li><li>Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器；</li><li>spring容器中存储的对象称为bean对象；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IOC(inversion of control): 控制反转,反转的是对象的创建权,用于削减程序之间的耦合关系,底层使用反射技术实现</span><br><span class="line">传统方式创建对象:  <span class="keyword">new</span> 对象(); (主动创建)</span><br><span class="line">IOC方式创建对象: 找容器(被动接收),本质上就是一个Map集合</span><br><span class="line"></span><br><span class="line">作用：解耦</span><br><span class="line">通过标记(标记就是配置文件中的key)找工厂,工厂帮我们创建对应的类对象,并返回给我们使用</span><br><span class="line">当前类可以选择主动出击（<span class="keyword">new</span>的方式）创建对象，但是此时耦合度高。</span><br><span class="line">把主动式改成被动接收，由工厂对象为当前类生产所必须的关联对象，此时降低了两个类的依赖关系。</span><br><span class="line">控制反转：资源创建的权限（比如dao）由应用方（service）转移到工厂去创建（factory,spring容器去创建）   </span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208211649128.png" alt="image-20220821164921028"></p><div style="background-color:orange">1.导入Spring的核心jar包的坐标:</div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="background-color:orange">2.创建applicationContext.xml,并导入约束:</div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- id: 容器中的唯一标识  class:被创建的类的全限定名(包名+类名) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="background-color:orange">3.获取IOC容器:</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.从类路径下解析xml配置文件,获取容器</span><br><span class="line"><span class="comment">// 将配置文件中放在resources</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">b.从磁盘路径下解析xml配置文件</span><br><span class="line"><span class="comment">// 将配置文件方法磁盘目录下</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;C:\Users\Administrator.DESKTOP-NG3ICNP\Desktop\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>ApplicationContex</code>t: 当解析完applicationContext.xml文件后,立即创建类对象(饿汉加载模式)<br>    它是一个接口。是spring中的IOC容器接口,可以通过该接口的方法来获取想要的bean对象。需要提供bean的id。<br>    它有3个常用的实现类<br>         ClassPathXmlApplicationContext★:<br>                    它是用于读取类路径(resources)下的xml配置文件，不在类路径下读取不到<br>         FileSystemXmlApplicationContext:<br>                    它是读取文件系统中的配置文件，只要有访问权限，在文件系统中都能读取的到<br>         AnnotationConfigApplicationContext:<br>                    它是用于根据注解配置 创建容器的。</p><p>(★★)ApplicationContext它是在一读取完配置文件，就马上创建配置文件中所配置的所有对象。(得到IOC容器)</p><p><code>BeanFactory</code>:<br>     它是spring中ioc容器的顶层接口，ApplicationContext只是它的子接口。<br>     它提供创建容器中对象的时机，使用延迟加载(懒加载)的思想。而ApplicationContext不仅继承了它的加载方式，而且还扩展出来了立即加载思想的创建容器的方式。<br>     它是每次在使用时才真正的创建对象。</p></blockquote><h3 id="2、创建Bean对象的三种方式"><a href="#2、创建Bean对象的三种方式" class="headerlink" title="2、创建Bean对象的三种方式"></a>2、创建Bean对象的三种方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方式1: 无参构造创建对象,存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;AccountService1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式2: 调用工厂的静态方法创建类对象,存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        调用工厂的静态方法,将方法的返回值存放到IOC容器中</span></span><br><span class="line"><span class="comment">           id: 存放到IOC容器时,对象的唯一标识</span></span><br><span class="line"><span class="comment">           class: 工厂的全限定名</span></span><br><span class="line"><span class="comment">           factory-method: 指定静态方法名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;AccountService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.factory.MethodFactory&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-method</span>=<span class="string">&quot;createObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式3: 调用工厂的非静态方法创建类对象,存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.1: 创建工厂类对象,并存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.MethodFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.2: 调用工厂实例的非静态方法创建类对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        调用工厂的非静态方法,将非静态方法的返回值存放到IOC容器中</span></span><br><span class="line"><span class="comment">            id:存放到IOC容器时,对象的唯一标识</span></span><br><span class="line"><span class="comment">            factory-bean:工厂对象实例的引用</span></span><br><span class="line"><span class="comment">            factory-method:调用实例工厂的非静态方法</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;AccountService3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;methodFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createObject1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、Bean对象的作用范围"><a href="#3、Bean对象的作用范围" class="headerlink" title="3、Bean对象的作用范围"></a>3、Bean对象的作用范围</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">class</span>=<span class="string">&quot; &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bean的作用范围调整：</span><br><span class="line">    调整bean的作用范围，使用的是bean标签的scope属性。</span><br><span class="line">    它的属性取值有以下5个</span><br><span class="line">      singleton           : 单例对象      用的最多的           它是默认值(最常用)</span><br><span class="line">      prototype           ：多例对象       用的最多的</span><br><span class="line">      ------------------------------------</span><br><span class="line">      request             ：请求范围      (存入了请求域)</span><br><span class="line">      session             ：会话范围      (存入了会话域)</span><br><span class="line">      global-session      ：全局会话范围   当非集群环境下，它就是session</span><br><span class="line">-------------</span><br><span class="line">如果是有状态的bean选择多例；</span><br><span class="line">如估无无状态的bean选择单例；</span><br></pre></td></tr></table></figure><h3 id="4、Bean对象的生命周期"><a href="#4、Bean对象的生命周期" class="headerlink" title="4、Bean对象的生命周期"></a>4、Bean对象的生命周期</h3><p>bean对象的生命周期: 从加载到内存哪一刻起对象就出生了,当对象从内存中移除时,对象的生命就完结了</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bean的生命周期:</span><br><span class="line">    单例对象: 将创建的bean放入容器</span><br><span class="line">    出生:容器创建，对象出生</span><br><span class="line">    活着:只要容器在，对象就一直活着</span><br><span class="line">    死亡:容器销毁，对象消亡</span><br><span class="line">    特点: 生命周期与容器相同</span><br><span class="line">&lt;!--</span><br><span class="line">        单例对象:</span><br><span class="line">            init-method: 初始化方法（构造器初始化对象之后被调用）</span><br><span class="line">            destroy-method: 销毁时调用的方法（对象被销毁之前被调用）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=&quot;AccountService&quot; class=&quot;com.study.service.impl.AccountServiceImpl&quot;</span><br><span class="line">          init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">多例对象：</span><br><span class="line">    出生：每次使用时创建</span><br><span class="line">    活着：在使用过程中</span><br><span class="line">    死亡：使用完成之后，等待垃圾回收器回收。gc，也就是说多例模式下spring不负责对象的销毁，不会执行destroy方法；</span><br><span class="line">    多实例bean对象的生命周期</span><br><span class="line">            scope的值必须为: prototype</span><br></pre></td></tr></table></figure><h2 id="二、依赖注入DI"><a href="#二、依赖注入DI" class="headerlink" title="二、依赖注入DI"></a>二、依赖注入DI</h2><h3 id="1、依赖注入概述"><a href="#1、依赖注入概述" class="headerlink" title="1、依赖注入概述"></a>1、依赖注入概述</h3><ul><li><p>IoC与DI是同一件事站在不同角度看待问题</p><p>​    在<font color='red'>应用程序的角度</font>看程序需要被动等待Spring提供资源（注入资源）是DI;</p><p>​    但是在<font color='red'>Spring容器的角度</font>看是，是将资源的创建权利做了翻转，且由容器提供数据，是IOC;</p></li></ul><h3 id="2、注入数据的方式和类型"><a href="#2、注入数据的方式和类型" class="headerlink" title="2、注入数据的方式和类型"></a>2、注入数据的方式和类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Spring中的依赖注入：</span><br><span class="line">    注入的方式有三种：</span><br><span class="line">        第一种：使用构造方法注入</span><br><span class="line">            要求：必须有对应参数列表的构造函数</span><br><span class="line">        第二种：使用setter方法注入（XML开发主流）</span><br><span class="line">            要求：提供被注入对象的set方法（不需要get方法）</span><br><span class="line">        第三种：使用注解注入</span><br><span class="line"></span><br><span class="line">    注入的数据类型有三类：</span><br><span class="line">        第一类：基本类型和String</span><br><span class="line">        第二类：其他bean类型</span><br><span class="line">            要求：其他bean指的是在spring的配置文件中定义过的bean，或者是用注解注释过的类。</span><br><span class="line">        第三类：复杂类型（集合类型）</span><br><span class="line">            Array: 数组</span><br><span class="line">            List:</span><br><span class="line">            Map:</span><br><span class="line">            Properties:</span><br></pre></td></tr></table></figure><div style="background-color:orange">示例代码:</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 依赖注入:</span><br><span class="line">            在创建对象时,给对象中的属性赋值</span><br><span class="line">         依赖注入方式:</span><br><span class="line">            方式<span class="number">1</span>: 有参构造</span><br><span class="line">            方式<span class="number">2</span>: setter方法</span><br><span class="line">            方式<span class="number">3</span>: 注解</span><br><span class="line">         依赖注入的数据类型:</span><br><span class="line">            基本类型和String</span><br><span class="line">            其他bean对象</span><br><span class="line">            数组</span><br><span class="line">            List</span><br><span class="line">            Map</span><br><span class="line">            Properties</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- 方式<span class="number">1</span>: 有参构造 --&gt;</span><br><span class="line">    &lt;!--&lt;bean id=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;com.study&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;port&quot;</span> value=<span class="string">&quot;3306&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;--&gt;</span><br><span class="line">    &lt;!-- 方式<span class="number">2</span>: 通过setter方法注入 ****--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;com.study&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;port&quot;</span> value=<span class="string">&quot;3306&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入其他bean类型 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;user&quot;</span> ref=<span class="string">&quot;user&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入数组 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;strArr&quot;</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;宝强&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;乃亮&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;羽凡&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;大郎&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入list --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;蓉蓉&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;璐璐&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;合合&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;莲莲&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--  注入map--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;map&quot;</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;波波&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;18&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;妖&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入properties --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;prop&quot;</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=<span class="string">&quot;name&quot;</span>&gt;昌老师&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">&quot;age&quot;</span>&gt;<span class="number">40</span>&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 创建user对象存放到IOC容器中 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.study.User&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;xxx&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="3、解析property配置文件"><a href="#3、解析property配置文件" class="headerlink" title="3、解析property配置文件"></a>3、解析property配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解析Properties配置文件,将配置文件中的数据存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> <span class="attr">file-encoding</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、注解方式"><a href="#三、注解方式" class="headerlink" title="三、注解方式"></a>三、注解方式</h2><h3 id="1、启动注解功能"><a href="#1、启动注解功能" class="headerlink" title="1、启动注解功能"></a>1、启动注解功能</h3><ul><li><p>在spring XML配置文件中启动注解扫描，加载类中配置的注解项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;packageName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>在进行包所扫描时，会<font color='red'>对配置的包及其子包中所有文件</font>进行扫描;</p></li><li><p>扫描过程是以文件夹递归迭代的形式进行的;</p></li><li><p>扫描过程仅读取合法的java文件</p></li><li><p>扫描时仅读取spring可识别的注解</p></li><li><p>扫描结束后会将可识别的有效注解<font color='red'>转化为spring对应的资源加入IoC容器</font></p></li></ul></li><li><p>注意：</p><ul><li><strong>无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中</strong>，差别仅仅是数据读取方式不同</li><li>从加载效率上来说注解优于XML配置文件</li></ul></li></ul><h3 id="2、定义bean的常用注解"><a href="#2、定义bean的常用注解" class="headerlink" title="2、定义bean的常用注解"></a>2、定义bean的常用注解</h3><ul><li><p>名称：@Component    @Controller    @Service    @Repository</p></li><li><p>类型：<strong>类注解</strong></p></li><li><p>位置：<strong>类的定义上方</strong></p></li><li><p>作用：设置该类为spring管理的bean</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>以上注解相当于xml 中的bean标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@Controller、@Service 、@Repository是@Component的衍生注解，功能同@Component</p></li><li><p>@Controller(控制层注解)、@Service（服务层注解） 、@Repository（持久层注解）只是提供了更加明确的语义化(见名知意)，精确指出是哪一层的对象,但不是强制要求的；</p></li></ul></li><li><p>相关属性</p><ul><li>value（默认）：定义bean的访问id</li></ul></li></ul><h3 id="3、bean的属性数据注入常用注解"><a href="#3、bean的属性数据注入常用注解" class="headerlink" title="3、bean的属性数据注入常用注解"></a>3、bean的属性数据注入常用注解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下注解它们就相当于：</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">或</span> <span class="attr">value</span>=<span class="string">&quot;基本类型数据或String&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">------------------------</span><br><span class="line">这些注解使用在属性上,用于给对象中的属性进行赋值</span><br><span class="line">引用类型：</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier</span><br><span class="line">    @Resource</span><br><span class="line">基本类型+String：</span><br><span class="line">    @Value   可以支持Spring的EL表达式(SPEL)，写法就是$&#123;表达式&#125;</span><br></pre></td></tr></table></figure><h3 id="4、作用范围和生命周期相关注解"><a href="#4、作用范围和生命周期相关注解" class="headerlink" title="4、作用范围和生命周期相关注解"></a>4、作用范围和生命周期相关注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>: 相当于bean标签的scope属性</span><br><span class="line">作用：用于调整bean的作用范围</span><br><span class="line">使用位置: 被创建的类上</span><br><span class="line">属性：</span><br><span class="line">value：指定作用范围的取值。取值是固定的<span class="number">5</span>个，和XML的配置取值是一样的。</span><br><span class="line">singleton: 单实例 默认值</span><br><span class="line">prototype: 多实例</span><br><span class="line"><span class="meta">@PostConstruct</span> : 使用在方法上</span><br><span class="line">使用位置: 初始化的方法上</span><br><span class="line">​作用：指定初始化方法，相当于init-method</span><br><span class="line"><span class="meta">@PreDestroy</span> : 使用在方法上</span><br><span class="line">​作用：指定销毁方法，相当于destroy-method</span><br></pre></td></tr></table></figure><h3 id="5、纯注解格式★"><a href="#5、纯注解格式★" class="headerlink" title="5、纯注解格式★"></a>5、纯注解格式★</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我们需要使用配置类代替配置文件,将以下注解写在配置类上</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>: 声明该类为Spring的配置文件类</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.itheima&quot;)</span> : 指定要扫描的包</span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span> : 将配置文件交给Spring容器管理</span><br><span class="line"><span class="meta">@Bean()</span> : 将方法返回的对象存放到IOC容器中</span><br><span class="line">将返回值存放到IOC容器中</span><br><span class="line">一般将【第三方提供的类】对加载到IOC容器</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Spring的核心配置类</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 声明配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span> <span class="comment">// 开启包扫描</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="comment">// 解析properties配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;template&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSource&quot;)</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        template.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6、Spring整合junit"><a href="#6、Spring整合junit" class="headerlink" title="6、Spring整合junit"></a>6、Spring整合junit</h3><p>使用步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导入jar包坐标</span><br><span class="line">&lt;!-- 引入单元测试的jar包 <span class="number">4.12</span>以上 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 导入Spring整合junit的jar包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.0</span><span class="number">.2</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"><span class="number">2.</span>使用</span><br><span class="line">在测试类上添加以下两个注解:</span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span> (配置xml文件的路径)</span><br><span class="line">或者：</span><br><span class="line"><span class="meta">@ContextConfiguration(classes=SpringConfig.class)</span> (配置类)</span><br></pre></td></tr></table></figure><h2 id="四、Spring-AOP"><a href="#四、Spring-AOP" class="headerlink" title="四、Spring-AOP"></a>四、Spring-AOP</h2><h3 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h3><ul><li><p>Target（目标对象）:   要增强的对象(被代理的类对象)</p></li><li><p>Proxy（代理对象） :  对目标对象的增强的对象 (生成的代理类对象)</p></li><li><p>Joinpoint（连接点）:  目标对象中的所有方法(被代理类中的所有方法)–》可以被增强的方法</p></li><li><p>Pointcut（切入点）:   要被增强的方法(被代理类中要增强的方法)</p></li><li><p>Advice（通知/增强）:  增强的那段【代码方法】以及代码切入的位置</p><p>​                通知包含了2个维度内容：<strong>在增强方法的什么位置，切入什么代码；</strong></p><pre><code>前置通知：在方法之前进行增强后置通知 ：在方法之后进行增强异常通知：在方法异常进行增强最终通知 ：最终执行的方法进行增强环绕通知:  单独使用（以上所有通知）</code></pre></li><li><p><strong>Aspect(切面):</strong> 切入点+通知=切面</p></li></ul><p>​                目标方法和增强方法合到在一起 叫做切面</p><p>​                说白了切面描述了在什么样的目标方法下(切入点)的什么位置（通知类型）切入了什么样的(增强代码）</p><ul><li><p>Weaving（织入）：</p><p>​          将增强的代码（方法）合并到目标方法的过程 叫织入过程;    </p></li></ul><p>Spring AOP底层实现技术就是动态代理</p><p>spring底层会自动抉择使用Jdk Proxy或Enhancer(cglib)</p><h3 id="2、AOP开发方式"><a href="#2、AOP开发方式" class="headerlink" title="2、AOP开发方式"></a>2、AOP开发方式</h3><ul><li><p>XML方式</p></li><li><p>XML+注解方式</p></li><li><p>注解方式</p></li></ul><h3 id="3、全xml方式实现AOP【最繁琐的】"><a href="#3、全xml方式实现AOP【最繁琐的】" class="headerlink" title="3、全xml方式实现AOP【最繁琐的】"></a>3、全xml方式实现AOP【最繁琐的】</h3><blockquote><p>例子：</p><p>对AccountServiceImpl下的方法进行增强;<br>步骤如下：<br>1.导入相关jar坐标;<br>2.自己封装要增强方法，并保存在某个专用类中【切面类/通知类/增强类】<br>3.将所有进行AOP操作的资源【切面类+目标对象】加载到IOC容器中；<br>4.编写配置文件<br>    告诉spring【切面类中的增强方法】在哪个对象的哪个方法上增强使用（配置切面）；</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将目标类(被增强的类)存放到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将切面类加载到IOC容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.aspect.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 面向切面编程====织入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点表达式 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定切面类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- method: 调用的通知方法  pointcut: 切入点是什么 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.study.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.itheima.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.itheima.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.study.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * com.study.service.impl.AccountServiceImpl.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">切入点表达式:</span><br><span class="line">作用: 找到那些被增强的方法,类似正则表达式</span><br><span class="line">格式:</span><br><span class="line">    修饰符 返回值 方法的全限定名(参数列表)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> com.study.service.impl.AccountServiceImpl.delete()</span><br><span class="line">    说明：修饰符可省略不写，默认<span class="keyword">public</span>    </span><br><span class="line">支持通配符的写法：</span><br><span class="line">    *   ： 表示任意字符串</span><br><span class="line">    ..  ： 任意重复次数</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">execution(* *(..)) <span class="comment">//说明：第一个*表示任意返回值类型，第二个*匹配任意类，..匹配任意参数，该表达式表示匹配任意类的任意方法（简化书写方式，很少用到）</span></span><br><span class="line">execution(* *..*(..))<span class="comment">//同上</span></span><br><span class="line">execution(* *..*.*(..))<span class="comment">//同上，更符合书写习惯，第一个*表示匹配任意返回值类型，*..表示匹配任意包名称及其任意子包，第三个*匹配任意类，第四个匹配任意方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *..*.*(..))<span class="comment">//表示匹配任意public修饰符的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> *..*.*(..))<span class="comment">//表示陪陪任意返回值是int类型且修饰符是public的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> *..*.*(..))<span class="comment">//匹配任意返回值是void且修饰符是public的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..*.*(..))<span class="comment">//匹配com包及其任意子包下的被pulic修饰的返回值是void的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..service.*.*(..))<span class="comment">//匹配com包下任意子包下存在service包下的任意类的任意方法，且方法为void 被public修饰</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.User*.*(..))<span class="comment">//侧重点：任意一User开头的类下的任意void且被public修饰的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.*Service.*(..))<span class="comment">//侧重点：任意一Service结尾的类下的任意方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.study.service.UserService.*(..))<span class="comment">//匹配UserService类下的任意方法...</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.find*(..))<span class="comment">//侧重点：匹配UserService类下的任意以find开头的任意方法...</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.*Id(..))<span class="comment">//侧点：匹配UserService类下的任意以id结尾的任意方法...</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(..))<span class="comment">//侧重点：匹配UserService类下方法名为findById的任意参数的方法....</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(<span class="type">int</span>))<span class="comment">//精准匹配，方法入参只有一个int类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(<span class="type">int</span>,<span class="type">int</span>))<span class="comment">//精准匹配，方法入参包含2个int类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(<span class="type">int</span>,*))<span class="comment">//2个入参，第一个必须int，第二个任意类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById(*,<span class="type">int</span>))<span class="comment">//2个入参，第一个任意类型，第二个必须int类型</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.study.service.UserService.findById())<span class="comment">//精准匹配无参</span></span><br><span class="line">execution(List com.study.service.*Service+.findAll(..))<span class="comment">//匹配任意以Service结尾的接口或者实现类下方法名为findAll的任意入参方法</span></span><br></pre></td></tr></table></figure><h3 id="4、半xml半注解实现AOP"><a href="#4、半xml半注解实现AOP" class="headerlink" title="4、半xml半注解实现AOP"></a>4、半xml半注解实现AOP</h3><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><div style='background-color:orange;'>1.开启包扫描</div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启需要扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明当前项目可以使用AOP的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><div style='background-color:orange;'>2.在切面类中添加相关注解</div>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">注解：</span><br><span class="line"><span class="meta">@Aspect</span> ： 声明切面类</span><br><span class="line"><span class="meta">@PonitCut</span>：定义公共的切入点</span><br><span class="line">配置到空方法上，value：切入点表达式</span><br><span class="line">引用：方法名()</span><br><span class="line">配置通知类型：</span><br><span class="line">    <span class="meta">@Before()</span> : 前置通知</span><br><span class="line">    <span class="meta">@AfterReturning()</span> ： 后置通知</span><br><span class="line">    <span class="meta">@AfterThrowing()</span>  ：异常通知</span><br><span class="line">    <span class="meta">@After()</span>：最终通知</span><br><span class="line">    <span class="meta">@Around()</span>：环绕通知</span><br></pre></td></tr></table></figure><h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码:"></a>相关代码:</h4><p><strong>1.导入jar包坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring核心jar包,已经依赖的AOP的jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.切面类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此类我们称之为切面类,在切面类中存放有各种通知</span></span><br><span class="line"><span class="comment"> * 切面 = 切入点 + 通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> : 声明此类为切面类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置切入点表达式</span></span><br><span class="line"><span class="comment">     * 调用切入点表单时,直接使用 方法名称()</span></span><br><span class="line"><span class="comment">     *      pt()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*.AccountServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知:11111111111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知:22222222222222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知:33333333333333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知:44444444444444&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 连接点 ---&gt; 切入点</span></span><br><span class="line"><span class="comment">     *        ProceedingJoinPoint: method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强--111111111111&quot;</span>);</span><br><span class="line">            <span class="comment">// 让原方法执行  method.invoke()</span></span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强--222222222222&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">//throwable.printStackTrace();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异常增强--333333333333&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;最终增强--444444444444&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.applicationContext.xml配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启对Spring-AOP注解的支持 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、全注解实现AOP"><a href="#5、全注解实现AOP" class="headerlink" title="5、全注解实现AOP"></a>5、全注解实现AOP</h3><p>@EnableAspectJAutoProxy ： 开启对AOP注解的支持</p><h5 id="aop全注解代码"><a href="#aop全注解代码" class="headerlink" title="aop全注解代码"></a>aop全注解代码</h5><p><strong>配置类代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 声明此类为Spring的配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.study&quot;)</span> <span class="comment">// 设置需要扫描的包(开启对Spring注解的支持)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 开启对AOP注解的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切面类代码同上</strong></p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="一、回顾Servlet"><a href="#一、回顾Servlet" class="headerlink" title="一、回顾Servlet"></a>一、回顾Servlet</h2><p>Servlet:<br>    运行在服务器上的java小程序.<br>    本质上就是java代码,这个java代码可以被web服务器调用</p><p>【1】生命周期:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实例化,创建一个对象放内存</span><br><span class="line">    默认第一次请求Servlet时,会创建Servlet对象,并调用init方法进行初始化操作</span><br><span class="line">    load-on-startup: 设置servlet的初始化时机</span><br><span class="line">    取值: 正整数,值越小优先级越高</span><br><span class="line">    初始化,创建完对象后,调用对象的方法进行初始化 </span><br><span class="line">    init(): 初始化方法</span><br><span class="line">    当对象实例化完毕后,立即调用init方法完成初始化工作, <span class="number">1</span>次</span><br><span class="line">    service(): 提供服务</span><br><span class="line">    每次请求来的时候,tomcat都会调用service方法提供服务, 请求一次执行一次</span><br><span class="line">    destory(): 销毁方法</span><br><span class="line">    当对象从内存中移除前调用destory方法进行销毁工作, <span class="number">1</span>次</span><br></pre></td></tr></table></figure><p>【2】Servletconfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>web.xml配置：</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">            &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;</span><br><span class="line">            &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo&lt;/servlet-class&gt;</span><br><span class="line">            &lt;!--配置初始化参数--&gt;</span><br><span class="line">            &lt;init-param&gt;</span><br><span class="line">                   &lt;!--用于获取初始化参数的key--&gt;</span><br><span class="line">                &lt;param-name&gt;key&lt;/param-name&gt;</span><br><span class="line">                    &lt;!--初始化参数的值--&gt;</span><br><span class="line">                &lt;param-value&gt;value&lt;/param-value&gt;</span><br><span class="line">            &lt;/init-param&gt;</span><br><span class="line">         &lt;/servlet&gt;</span><br><span class="line">          <span class="number">2.</span>java代码</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">                <span class="comment">//get config and do something</span></span><br><span class="line">                 config.getInitParameter(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure><p>【3】ServletContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServletContext对象，它是应用上下文对象；</span><br><span class="line">           每一个应用有且【只有一个】ServletContext对象；</span><br><span class="line">           它可以实现让应用中所有Servlet间的数据共享；</span><br><span class="line">          eg: <span class="number">1.</span>web.xml配置：</span><br><span class="line">                &lt;!--配置应用初始化参数--&gt;</span><br><span class="line">                &lt;context-param&gt;</span><br><span class="line">                    &lt;!--用于获取初始化参数的key--&gt;</span><br><span class="line">                    &lt;param-name&gt;servletContextInfo&lt;/param-name&gt;</span><br><span class="line">                    &lt;!--初始化参数的值--&gt;</span><br><span class="line">                    &lt;param-value&gt;This is application scope&lt;/param-value&gt;</span><br><span class="line">                &lt;/context-param&gt;</span><br><span class="line">             <span class="number">2.</span>java代码示例：</span><br><span class="line">                getServletContext();</span><br><span class="line">                getInitParameter(<span class="string">&quot;servletContextInfo&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="二、SpringMVC概述"><a href="#二、SpringMVC概述" class="headerlink" title="二、SpringMVC概述"></a>二、SpringMVC概述</h2><p><strong>SpringMVC</strong> 顾名思义就是Spring对MVC架构的一种实现，属于轻量级的WEB框架。 </p><p>​    它通过一个简单的<strong>注解</strong>就可以让一个普通的Java类成为控制器，这种<strong>低侵入性的设计</strong>使得他备受业界欢迎 </p><p>​    同时他还支持RestFul风格的编程风格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC是spring对web层进行的封装,提供的MVC架构</span><br><span class="line">    M（模型）: </span><br><span class="line">Model可以叫做数据模型层，说白了就是用来封装数据的</span><br><span class="line">        例如：用户发送注册请求，那么请求的信息会被SpingMMVC封装到User实体类中，这个实体类就属于Model层；</span><br><span class="line">             用户发送查询个人信息的请求，那么后台也会将个人信息封装到一个User类型，数据同样也是Model层；</span><br><span class="line">            </span><br><span class="line">V（视图）: </span><br><span class="line">View说白了就是SpringMVC响应请求的一种数据展示（最终的执行结果）：</span><br><span class="line">例如：SpringMVC响应的数据方式：JSP、json、xml、html等</span><br><span class="line"></span><br><span class="line">    C（控制）: </span><br><span class="line">控制层就用来处理交互的部分，接收用户请求，然后执行业务等流程，最终反馈结果；</span><br><span class="line">    控制器,本质上就是一个Servlet,一切请求都访问这个Servlet,在这个Servlet中进行调度</span><br><span class="line">            SpringMVC可以通过一个简单的注解,就能让浏览器访问到对应的方法.</span><br><span class="line">            <span class="meta">@RequestMapping(&quot;/请求路径&quot;)</span></span><br><span class="line">    总之，这个唯一的Servlet核心控制器会【根据请求的url匹配基于注解的url】，完成请求处理；</span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212240313.png" alt="image-20220821224047251"></p><h3 id="1、核心Servlet配置文件"><a href="#1、核心Servlet配置文件" class="headerlink" title="1、核心Servlet配置文件"></a>1、核心Servlet配置文件</h3><p>编写web.xml文件</p><p>在web.xml文件中配置核心控制器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        服务器启动时只会加载web项目的核心配置文件 web.xml</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SpringMVC的核心Servlet: 前端控制器 (由SpringMVC框架提供)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置SpringMVC的核心配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 我们给前端控制器配置的路径为 / (缺省匹配)可以匹配浏览器发送的所以请求</span></span><br><span class="line"><span class="comment">             注意: jsp除外</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、SpringMVC配置文件"><a href="#2、SpringMVC配置文件" class="headerlink" title="2、SpringMVC配置文件"></a>2、SpringMVC配置文件</h3><p>spring-mvc.xml约束头</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启包扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器: 生成前缀和后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将可能使用到的处理器适配器,处理器映射器,视图解析器统统的加载到内存中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><h4 id="【1】启动初始化顺序"><a href="#【1】启动初始化顺序" class="headerlink" title="【1】启动初始化顺序"></a>【1】启动初始化顺序</h4><p>​        资源准备阶段：</p><p>​        （1）打包好war包，部署到Tomcat中==》mavne的自动发布插件完成</p><p>​        （2）Tomcat启动，加载web.xml文件</p><p>​        （3）初始化前端控制器：dispatcherServlet配置</p><p>​        （4）根据<strong>contextConfigLocation</strong>加载springmvc.xml配置</p><p>​        （5）根据spring-mvc.xml配置完成spring容器的初始化；</p><p>​            时序图：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212247249.png" alt="image-20191203171050122"></p><h4 id="【2】请求处理顺序"><a href="#【2】请求处理顺序" class="headerlink" title="【2】请求处理顺序"></a>【2】请求处理顺序</h4><p>（1）浏览器发起 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 请求</p><p>（2）Tomcat调用dispatcherServlet拦截/hello</p><p>（3）dispatcherServlet调用一个处理器，根据请求路径[/hello]找对对应的处理方法（这里被@RequestMapping注释的方法）【处理器映射器】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">处理器映射器：处理浏览器请求，根据路径映射到指定发方法；</span></span><br><span class="line"><span class="attr">eg</span>:<span class="string"></span></span><br><span class="line"><span class="attr">/hello-----&gt;com.heima.controller.HelloController#hello()</span></span><br></pre></td></tr></table></figure><p>（4）dispatcherServlet找到方法后，调用另外一种处理器，执行HelloController中的hello()方法【处理器适配器】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">处理器适配器：</span></span><br><span class="line"><span class="attr">1.适配处理器handler类型（在这里对应的处理器是hello()方法）；</span></span><br><span class="line"><span class="attr">2.处理入参，把对应的参数直接封装为一个实体；</span></span><br></pre></td></tr></table></figure><p>（5）HelloController中的hello()方法有返回值，创建ModelAndVIew（包含响应数据，页面）</p><p>（6）dispatcherServlet调用视图解析器，组装响应对象，然后把页面返回给浏览器【视图解析器】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">视图解析器：把方法返回的ModelAndVIew，进行页面和数据的整合，标签根据传入的view进行页面跳转</span></span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212248714.png" alt="image-20220821224827632"></p><ul><li><p>前端控制器：DispatcherServlet 是整体流程控制的中心，由其调用其它组件处理用户的请求， 有<br>效的降低了组件间的耦合性；</p></li><li><p>处理器：handler,业务处理的核心类，通常由我们自己编写,比如：HelloController类等；</p></li><li><p><strong>处理器映射器</strong>：负责根据URL请求找到对应的Handler处理器(就是根据请求URL与Controller方法的关系)</p></li><li><p><strong>处理器适配器</strong>：将请求参数解析转换成处理器的入参，并调用处理器执行的组件； </p></li><li><p><strong>视图解析器</strong>：将处理器执行的结果生成View视图（将逻辑视图转换成物理视图）</p></li><li><p>视图：View，最终产出结果， 常用视图如：jsp、 html  </p></li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212249484.png" alt="image-20200426183313406"></p><h2 id="四、常用注解"><a href="#四、常用注解" class="headerlink" title="四、常用注解"></a>四、常用注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line">类上:</span><br><span class="line">窄化类,访问此类中的方法时,必须加上类上的路径</span><br><span class="line">方法:</span><br><span class="line">建立绑定路径与方法的对应关系</span><br><span class="line">           常用属性 :</span><br><span class="line">value或者path: 用来指定路径,默认选项 </span><br><span class="line">method: 用来限定请求的方式 </span><br><span class="line">               例如：RequestMapping(value = <span class="string">&quot;/test03&quot;</span>,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br><span class="line">params: 用来限定请求参数 </span><br><span class="line">               例如：<span class="meta">@RequestMapping(value = &quot;/test04&quot;,params = &#123;&quot;username&quot;,&quot;password&quot;&#125;)</span></span><br><span class="line">headers: 用来限定请求必须携带指定的请求头</span><br><span class="line">以上的属性可以单独使用，也可以组合使用，组合使用时，必须同时满足才行。</span><br><span class="line"><span class="meta">@GetMapping()</span>  : 只能处理get请求</span><br><span class="line"><span class="meta">@PostMapping()</span> : 只能处理post请求</span><br><span class="line"><span class="meta">@PutMapping()</span> : 只能处理put请求</span><br><span class="line"><span class="meta">@DeleteMapping()</span> :只能处理delete请求</span><br></pre></td></tr></table></figure><h2 id="五、获取请求参数"><a href="#五、获取请求参数" class="headerlink" title="五、获取请求参数"></a>五、获取请求参数</h2><p>SpringMVC支持的参数类型有 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>基本数据类型和string</span><br><span class="line"><span class="number">2.</span>vo类型(View object,浏览器携带的所有数据封装成的对象叫做vo)  </span><br><span class="line">     要求：请求参数的名称必须和对象中的属性名保持一致</span><br><span class="line"><span class="number">3.</span>复杂类型：    </span><br><span class="line"><span class="number">3.</span>数组类型 </span><br><span class="line">     要求：保证前端传递的参数名称跟方法中的数组形参名称一致就好。 </span><br><span class="line"><span class="number">4.</span>集合类型 </span><br><span class="line">     获取集合参数时，要将集合参数包装到一个Vo中才可以。</span><br><span class="line">说明：</span><br><span class="line">如果请求中携带这些类型的数据,SpringMVC会自动帮我们接收,并传递给方法进行使用,【方法上的形参名称必须要和请求参数名称保持一致】；</span><br></pre></td></tr></table></figure><h2 id="六、特殊情况"><a href="#六、特殊情况" class="headerlink" title="六、特殊情况"></a>六、特殊情况</h2><h4 id="1、日期处理"><a href="#1、日期处理" class="headerlink" title="1、日期处理"></a>1、日期处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果请求携带的参数为日期类型,SpringMVC没有提供相关的转换器,哪该如何处理呢?</span><br><span class="line">我们可以使用SpringMVC提供的注解进行日期格式化操作.</span><br><span class="line"><span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">说明：</span><br><span class="line">    此时springmvc.xml中必须要开启注解驱动： &lt;mvc:annotation-driven/&gt;    </span><br></pre></td></tr></table></figure><h4 id="2、编码过滤器"><a href="#2、编码过滤器" class="headerlink" title="2、编码过滤器"></a>2、编码过滤器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">若请求携带了中文有乱码的情况</span><br><span class="line">   在SpringMVC中已经提供好了编码过滤器,可以直接使用即可</span><br><span class="line">    <span class="comment">&lt;!-- 在web.xml中配置springMVC编码过滤器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 设置过滤器中的属性值 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 过滤所有请求 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、请求参数名称不一致"><a href="#3、请求参数名称不一致" class="headerlink" title="3、请求参数名称不一致"></a>3、请求参数名称不一致</h4><p>@RequestParam : 主要用于在SpringMVC后台控制层获取参数时，前端传入的参数和方法形参不一致时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它支持三个属性: </span><br><span class="line">value：默认属性，用于指定前端传入的参数名称 </span><br><span class="line">required：用于指定此参数是否必传 </span><br><span class="line">defaultValue：当参数为非必传参数且前端没有传入参数时，指定一个默认值。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/params/demo8?username=张三&quot;</span>&gt;请求参数-基本类型&lt;/a&gt; &lt;br&gt;</span><br><span class="line">------------------------------</span><br><span class="line"><span class="meta">@RequestMapping(&quot;demo8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo1</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;tom&quot;,required = false,value = &quot;name&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、获取请求头信息"><a href="#4、获取请求头信息" class="headerlink" title="4、获取请求头信息"></a>4、获取请求头信息</h4><p>@RequestHeader</p><p><strong>作用:</strong> 主要用于从请求头中获取参数。它支持的属性跟@RequestParam一样。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo2</span><span class="params">(<span class="meta">@RequestHeader(&quot;cookie&quot;)</span> String cookie, HttpServletResponse response)</span>&#123;</span><br><span class="line">    System.out.println(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、获取cookie信息"><a href="#5、获取cookie信息" class="headerlink" title="5、获取cookie信息"></a>5、获取cookie信息</h4><p>@CookieValue</p><p><strong>作用:</strong> 用于从cookie中取值。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意: cookie的key值区分大小写</span><br><span class="line"><span class="meta">@RequestMapping(&quot;demo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo3</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line">    System.out.println(jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、同步请求的响应"><a href="#七、同步请求的响应" class="headerlink" title="七、同步请求的响应"></a>七、同步请求的响应</h2><p>**SpringMVC返回值的方式可以分为两大类: **</p><p>​     <strong>1.同步请求的响应:</strong></p><p>​            请求<strong>转发 或 重定向</strong></p><p>​     <strong>2.异步请求的响应</strong></p><p>​            异步指的是前端的请求的方式：ajax</p><p>​            ajax请求直接返回响应结果字符串</p><h3 id="1、原生API和SpringMVC实现转发"><a href="#1、原生API和SpringMVC实现转发" class="headerlink" title="1、原生API和SpringMVC实现转发"></a>1、原生API和SpringMVC实现转发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *      原生API实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler01&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler01</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler01方法执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求转发到 /pages/success.jsp</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/pages/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *      SpringMVC方式:</span></span><br><span class="line"><span class="comment">     *          forward:物理视图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler02&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler02方法执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// forward:物理视图路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *      SpringMVC方式:</span></span><br><span class="line"><span class="comment">     *          逻辑视图 + 视图解析器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler03&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler03方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、原生API和SpringMVC实现重定向"><a href="#2、原生API和SpringMVC实现重定向" class="headerlink" title="2、原生API和SpringMVC实现重定向"></a>2、原生API和SpringMVC实现重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向-原生API</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler04&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler04</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler04方法执行了...&quot;</span>);</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/pages/success.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringMVC方式:</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler05&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler05</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler05方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:https://www.baidu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、原生API和SpringMVC以流的形式写回字符串"><a href="#3、原生API和SpringMVC以流的形式写回字符串" class="headerlink" title="3、原生API和SpringMVC以流的形式写回字符串"></a>3、原生API和SpringMVC以流的形式写回字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以流的形式写回字符串</span></span><br><span class="line"><span class="comment">     *      原生API: HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handler06&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler06</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;handler06方法执行了...&quot;</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;原生API响应的数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mime常用类型:</span></span><br><span class="line"><span class="comment">     *          *.html  text/html</span></span><br><span class="line"><span class="comment">     *          *.js    text/JavaScript</span></span><br><span class="line"><span class="comment">     *          *.png   image/png</span></span><br><span class="line"><span class="comment">     *          *.json  application/json</span></span><br><span class="line"><span class="comment">     * 以流的形式写回字符串</span></span><br><span class="line"><span class="comment">     *      SpringMVC方式:</span></span><br><span class="line"><span class="comment">     *          <span class="doctag">@ResponseBody</span> + String</span></span><br><span class="line"><span class="comment">     *  RequestMapping参数:</span></span><br><span class="line"><span class="comment">     *      produces: 设置响应参数的mime类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/handler07&quot;,produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handler07</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handler07方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SpringMVC写回的字符串&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、响应时数据共享问题"><a href="#4、响应时数据共享问题" class="headerlink" title="4、响应时数据共享问题"></a>4、响应时数据共享问题</h3><blockquote><p>请求转发: 数据都会存放到Request域中<br>重定向: 将共享的数据拼接在请求路径的后面</p></blockquote><h4 id="【1】转发响应时"><a href="#【1】转发响应时" class="headerlink" title="【1】转发响应时"></a>【1】转发响应时</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用request域对象封装响应结果</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo1</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Model封装结果</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo2</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用ModelAndView封装结果 </span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">demo3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="【2】重定向时"><a href="#【2】重定向时" class="headerlink" title="【2】重定向时"></a>【2】重定向时</h4><p>数据存放到session域下，会占用服务器内存空间；【不可取】</p><p>重定向时，request域下的数据不能共享，但是使用Model或者ModelAndView可以自动将数据以参数的方式拼接到请求路径中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test04&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test04</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test04方法执行了...&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;你若安好,便是晴天&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/pages/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test05&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test05</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test05方法执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// 封装转发携带的数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg1&quot;</span>,<span class="string">&quot;情绪是智慧不够的产物!&quot;</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg2&quot;</span>,<span class="string">&quot;哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">// 封装视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;redirect:/pages/success.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="八、异步请求的响应"><a href="#八、异步请求的响应" class="headerlink" title="八、异步请求的响应"></a>八、异步请求的响应</h2><p>测试环境：vue+springmvc</p><h3 id="1-使用Response-原生API响应结果"><a href="#1-使用Response-原生API响应结果" class="headerlink" title="1. 使用Response 原生API响应结果"></a>1. 使用Response 原生API响应结果</h3><div style='background-color:orange;'>示例1:</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原生API生成响应信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">(String name, Integer age, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;demo1方法执行了..&quot;</span>+name+<span class="string">&quot; : &quot;</span>+age);</span><br><span class="line">    response.getWriter().print(<span class="string">&quot;hello...&quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-ResponseBody注解"><a href="#2-使用-ResponseBody注解" class="headerlink" title="2. 使用@ResponseBody注解"></a>2. 使用@ResponseBody注解</h3><h4 id="返回普通字符串"><a href="#返回普通字符串" class="headerlink" title="返回普通字符串"></a>返回普通字符串</h4><div style='background-color:orange;'>示例2:</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求携带的json字符串,将字符串存放到一个变量中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestBody</span>:</span></span><br><span class="line"><span class="comment"> *      获取请求体中的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test03&quot;,produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test03</span><span class="params">(<span class="meta">@RequestBody</span> String str)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test03方法执行了&quot;</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求携带的json字符串,将字符串存放到一个变量中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestBody</span>:</span></span><br><span class="line"><span class="comment"> *      注意: 需要导入jackson的jar包</span></span><br><span class="line"><span class="comment"> *      解析请求体中的json字符串,并将数据封装到vo对象中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test04&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test04</span><span class="params">(<span class="meta">@RequestBody</span> UserVo userVo)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test04方法执行了&quot;</span>);</span><br><span class="line">    System.out.println(userVo);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回json字符串"><a href="#返回json字符串" class="headerlink" title="返回json字符串"></a>返回json字符串</h4><div style='background-color:orange;'>示例3:</div><p>先要导入JSON转换需要的包 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">将返回结果转成json字符串返回给浏览器</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据:</span></span><br><span class="line"><span class="comment">     *      响应json格式的数据给浏览器</span></span><br><span class="line"><span class="comment">     *      <span class="doctag">@ResponseBody</span> + 对象</span></span><br><span class="line"><span class="comment">     *          可以直接将对象转成json字符串写回给浏览器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test05&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">test05</span><span class="params">(<span class="meta">@RequestBody</span> UserVo userVo)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test04方法执行了&quot;</span>);</span><br><span class="line">        System.out.println(userVo);</span><br><span class="line">        userVo.setAge(<span class="number">21</span>);</span><br><span class="line">        userVo.setUsername(<span class="string">&quot;笑雯&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-RequestBody和-ResponseBody的区别"><a href="#3-RequestBody和-ResponseBody的区别" class="headerlink" title="3. @RequestBody和@ResponseBody的区别"></a>3. @RequestBody和@ResponseBody的区别</h3><p>@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">@RequestBody</span>核心是接收客户端发送的json格式字符串，并封装到某个vo下(反序列化过程)；</span><br><span class="line"><span class="number">2.</span>get请求是没有请求体,而请求携带的json格式数据必须存放在请求体中携带给服务器</span><br><span class="line"><span class="number">3.</span>编写位置: 参数列表中参数的前面</span><br><span class="line">作用:</span><br><span class="line">  在post请求时,获取请求携带的json字符串,自动解析json字符串,并将解析到的内容封装到对应的java对象中(导入Jackson的jar包)</span><br></pre></td></tr></table></figure><p>@ResponseBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>:</span><br><span class="line">  作用<span class="number">1</span>: 以流的形式写回字符串给浏览器</span><br><span class="line">  作用<span class="number">2</span>: 将对象转成json字符串,将转完后的字符串以流的形式写回给浏览器</span><br><span class="line">    需要设置返回数据的mime类型: produces = <span class="string">&quot;application/json;charset=utf-8&quot;</span></span><br></pre></td></tr></table></figure><p><strong>@RequestBody和@ResponseBody都是用来干什么的？</strong> </p><p>​        @RequestBody : 使用在post请求中</p><p>​                1.获取请求体的参数(获取的是一个字符串)</p><p>​                2.获取请求携带的json格式字符串,并解析json格式的字符串,封装到对象中</p><p>​                3.使用在参数的前面</p><p>​        @ResponseBody: 生成响应字符串的</p><p>​                1.直接返回一个普通字符串</p><p>​                2.如果返回的是对象,则将对象转出json字符串并返回</p><p>​                3.使用在方法上或方法的返回值前面</p><h2 id="九、RESTFul风格的路径"><a href="#九、RESTFul风格的路径" class="headerlink" title="九、RESTFul风格的路径"></a>九、RESTFul风格的路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求路径中 &#123;占位符&#125; 接收请求路径中当前位置的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PathVariable</span>: 解析请求路径中的值,并将值赋给形参变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/&#123;username&#125;/&#123;age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span>String username ,</span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;age&quot;)</span>Integer age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户信息 &quot;</span>+username+<span class="string">&quot; : &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户信息 &quot;</span> +id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户信息 &quot;</span> +id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findByPage</span><span class="params">(<span class="meta">@PathVariable(&quot;currentPage&quot;)</span>Integer currentPage,</span></span><br><span class="line"><span class="params">                             <span class="meta">@PathVariable(&quot;pageSize&quot;)</span>Integer pageSize)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询用户信息 &quot;</span>+currentPage+<span class="string">&quot; : &quot;</span>+pageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><h3 id="1、静态资源映射"><a href="#1、静态资源映射" class="headerlink" title="1、静态资源映射"></a>1、静态资源映射</h3><h4 id="解决方式1："><a href="#解决方式1：" class="headerlink" title="解决方式1："></a>解决方式1：</h4><p>  在springmvc.xml文件中配置：</p><p>&lt; mvc:resources mapping=”匹配请求路径” location=”真实路径”&gt;  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置静态资源不过滤 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- javascript --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- html资源 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="解决方式2："><a href="#解决方式2：" class="headerlink" title="解决方式2："></a>解决方式2：</h4><p>  在springmvc.xml文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 统一配置 ★ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代替以上所有的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、异常处理"><a href="#2、异常处理" class="headerlink" title="2、异常处理"></a>2、异常处理</h3><h4 id="方式1：基于HandlerExceptionResolver接口实现"><a href="#方式1：基于HandlerExceptionResolver接口实现" class="headerlink" title="方式1：基于HandlerExceptionResolver接口实现"></a>方式1：基于HandlerExceptionResolver接口实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">自定义异常处理器</span><br><span class="line"> a）.编写一个类,实现 HandlerExceptionResolver 接口</span><br><span class="line"> b）.重写 resolveException方法：完成异常处理</span><br><span class="line">        <span class="number">1.</span>跳转到公共的错误页面</span><br><span class="line">        <span class="number">2.</span>携带错误信息</span><br><span class="line">        返回：ModelAndView</span><br><span class="line">           addObject：  携带参数</span><br><span class="line">           setViewName：指定页面跳转</span><br><span class="line"> c.配置异常处理器（交给spring容器管理）</span><br><span class="line">&lt;bean id=<span class="string">&quot;exceptionResolver&quot;</span> class=<span class="string">&quot;com.study.exception.MyHandlerExceptionResolver&quot;</span> /&gt; 或者使用注解加入spring的ioc容器中；</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><h5 id="自定义异常处理类"><a href="#自定义异常处理类" class="headerlink" title="自定义异常处理类"></a>自定义异常处理类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request : 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response : 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler : 处理器对象(哪个处理器方法抛出的异常)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex : 抛出的异常是什么</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,ex.getMessage());</span><br><span class="line">        <span class="comment">// 设置视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;forward:/pages/error.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方式2：注解开发异常处理器（推荐）"><a href="#方式2：注解开发异常处理器（推荐）" class="headerlink" title="方式2：注解开发异常处理器（推荐）"></a>方式2：注解开发异常处理器（推荐）</h4><ul><li>使用注解实现异常分类管理<br> 名称： @ControllerAdvice<br> 类型： 类注解<br> 位置：异常处理器类上方<br> 作用：设置当前类为异常处理器类<br> 范例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>使用注解实现异常分类管理<br> 名称： @ExceptionHandler<br> 类型： 方法注解<br> 位置：<font color='red'>异常处理器类中针对指定异常进行处理的方法上方</font><br> 作用：设置指定异常的处理方式<br> 范例：<br> 说明：处理器方法可以设定多个</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doOtherException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;出错啦，请联系管理员！ &quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>流程如下：</li></ul><p>1.以业务异常为例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常继承RuntimeException，覆盖父类所有的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义分类异常管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handlerException</span><span class="params">(BusinessException exception)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.setViewName(<span class="string">&quot;forward:/pages/error.jsp&quot;</span>);</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(otherDefinerException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handlerException</span><span class="params">(BusinessException exception)</span>&#123;</span><br><span class="line">       <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.setViewName(<span class="string">&quot;forward:/pages/error.jsp&quot;</span>);</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.触发业务异常代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExceptionController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">//举例业务异常说明</span></span><br><span class="line">        <span class="keyword">if</span>(name.trim().length()&lt;<span class="number">4</span> )&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;用户名长度必须在2-4位之间，请重新输入！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总之，通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息</strong>  </p><h3 id="3、拦截器"><a href="#3、拦截器" class="headerlink" title="3、拦截器"></a>3、拦截器</h3><h4 id="【1】拦截器介绍"><a href="#【1】拦截器介绍" class="headerlink" title="【1】拦截器介绍"></a>【1】拦截器介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">拦截器（interceptor）是springmvc提供的一种机制，可以对请求进行拦截或直接放行，可以在进入控制器方法前后对请求做出相应的处理.</span><br><span class="line">作用:</span><br><span class="line">在处理器方法执行前后,进行拦截过滤</span><br><span class="line">主要执行的拦截有:</span><br><span class="line">在处理器方法执行前执行拦截: preHandle</span><br><span class="line">          在处理方法执行后执行拦截: postHandle</span><br><span class="line">            在视图解析器解析完毕后执行拦截: afterCompletion</span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212356074.png" alt="1577627711990"></p><h4 id="【2】拦截器VS过滤器"><a href="#【2】拦截器VS过滤器" class="headerlink" title="【2】拦截器VS过滤器"></a>【2】拦截器VS过滤器</h4><p>拦截器与过滤器区别？</p><ul><li> 归属不同： Filter属于Servlet技术， Interceptor属于SpringMVC技术</li><li> 拦截内容不同： Filter可以对所有访问进行增强， Interceptor仅针对SpringMVC的访问进行增强  </li><li> 过滤器在Servlet执行前和执行后进行过滤，而 拦截器在servlet执行后,处理器执行前或后进行执行.</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212356069.png" alt="image-20200427164512745"></p><h4 id="【3】自定义拦截器"><a href="#【3】自定义拦截器" class="headerlink" title="【3】自定义拦截器"></a>【3】自定义拦截器</h4><p>​    <strong>1.编写一个类实现HandlerInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编写一个拦截器</span></span><br><span class="line"><span class="comment"> * 1.编写一个类,实现 HandlerInterceptor 接口</span></span><br><span class="line"><span class="comment"> * 2.重写后抽象方法</span></span><br><span class="line"><span class="comment"> * 3.配置拦截器 springmvc.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntercept</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器指定前执行拦截</span></span><br><span class="line"><span class="comment">     * 返回值为boolean</span></span><br><span class="line"><span class="comment">     *      如果返回ture则放行,执行处理器方法</span></span><br><span class="line"><span class="comment">     *      如果返回false则不放行,处理器方法不会执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle在处理器执行前拦截了..&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器执行后拦截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle在处理器执行后拦截了..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 视图解析器执行后拦截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion在视图解析器执行后拦截了..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <strong>2. 配置拦截器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 在springmvc.xml文件中配置拦截器需要拦截的路径</span><br><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置拦截器的拦截路径，支持*通配--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/**         表示拦截所有映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*          表示拦截所有/开头的映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/user/*     表示拦截所有/user/开头的映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/user/add*  表示拦截所有/user/开头，且具体映射名称以add开头的映射--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/user/*All  表示拦截所有/user/开头，且具体映射名称以All结尾的映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 排除指定路径不需要拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:exclude-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:exclude-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用指定的拦截器类处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.intercept.MyIntercept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><strong>3、多拦截器配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置拦截器 --&gt;</span><br><span class="line">    &lt;!-- 配置拦截器组 --&gt;</span><br><span class="line">    &lt;mvc:interceptors&gt;</span><br><span class="line">        &lt;!-- 配置一个拦截器 --&gt;</span><br><span class="line">        &lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;!-- 配置拦截器拦截的路径 第一*: 表示所有的包 第二*:表示所有的资源 --&gt;</span><br><span class="line">            &lt;mvc:mapping path=<span class="string">&quot;/**&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 排除指定路径不需要拦截 --&gt;</span><br><span class="line">            &lt;mvc:exclude-mapping path=<span class="string">&quot;/demo&quot;</span>&gt;&lt;/mvc:exclude-mapping&gt;</span><br><span class="line">            &lt;mvc:exclude-mapping path=<span class="string">&quot;/hello&quot;</span>&gt;&lt;/mvc:exclude-mapping&gt;</span><br><span class="line">            &lt;!-- 使用指定的拦截器类处理 --&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;com.itheima.intercept.MyIntercept&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br><span class="line"></span><br><span class="line">        &lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;!-- 配置拦截器拦截的路径 第一*: 表示所有的包 第二*:表示所有的资源 --&gt;</span><br><span class="line">            &lt;mvc:mapping path=<span class="string">&quot;/hello&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 使用指定的拦截器类处理 --&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;com.itheima.intercept.MyIntercept2&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br><span class="line">    &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208212356075.png" alt="image-20200427171422781"></p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级</title>
      <link href="/2022/08/01/redis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Redis%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/08/01/redis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Redis%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：Redis高级"><a href="#第二章：Redis高级" class="headerlink" title="第二章：Redis高级"></a>第二章：Redis高级</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>目标1：能够说出redis中的数据删除策与略淘汰策略</p><p>目标2：能够说出主从复制的概念，工作流程以及场景问题及解决方案</p><p>目标3：能够说出哨兵的作用以及工作原理，以及如何启用哨兵</p><p>目标4：能够说出集群的架构设计，完成集群的搭建</p><p>目标5：能够说出缓存预热，雪崩，击穿，穿透的概念，能说出redis的相关监控指标</p><h2 id="1-数据删除与淘汰策略"><a href="#1-数据删除与淘汰策略" class="headerlink" title="1.数据删除与淘汰策略"></a>1.数据删除与淘汰策略</h2><h3 id="1-1-过期数据"><a href="#1-1-过期数据" class="headerlink" title="1.1 过期数据"></a>1.1 过期数据</h3><h4 id="1-1-1-Redis中的数据特征"><a href="#1-1-1-Redis中的数据特征" class="headerlink" title="1.1.1 Redis中的数据特征"></a><strong>1.1.1 Redis中的数据特征</strong></h4><p>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态</p><p>TTL返回的值有三种情况：正数，-1，-2</p><ul><li><strong>正数</strong>：代表该数据在内存中还能存活的时间</li><li><strong>-1</strong>：永久有效的数据</li><li><strong>2</strong> ：已经过期的数据 或被删除的数据 或 未定义的数据</li></ul><p><strong>删除策略就是针对已过期数据的处理策略</strong>，已过期的数据是真的就立即删除了吗？其实也不是，我们会有多种删除策略，是分情况的，在不同的场景下使用不同的删除方式会有不同效果，这也正是我们要将的数据的删除策略的问题</p><h4 id="1-1-2-时效性数据的存储结构"><a href="#1-1-2-时效性数据的存储结构" class="headerlink" title="1.1.2 时效性数据的存储结构"></a>1.1.2 时效性数据的存储结构</h4><p>在Redis中，如何给数据设置它的失效周期呢？数据的时效在redis中如何存储呢？看下图：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032338242.png"></p><p>过期数据是一块独立的存储空间，Hash结构，field是内存地址，value是过期时间，保存了所有key的过期描述，在最终进行过期处理的时候，对该空间的数据进行检测， 当时间到期之后通过field找到内存该地址处的数据，然后进行相关操作。</p><h3 id="1-2-数据删除策略"><a href="#1-2-数据删除策略" class="headerlink" title="1.2 数据删除策略"></a>1.2 数据删除策略</h3><h4 id="1-2-1-数据删除策略的目标"><a href="#1-2-1-数据删除策略的目标" class="headerlink" title="1.2.1 数据删除策略的目标"></a>1.2.1 数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或 内存泄露</p><p>针对过期数据要进行删除的时候都有哪些删除策略呢？</p><ul><li>1.定时删除</li><li>2.惰性删除</li><li>3.定期删除</li></ul><h4 id="1-2-2-定时删除"><a href="#1-2-2-定时删除" class="headerlink" title="1.2.2 定时删除"></a>1.2.2 定时删除</h4><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p><ul><li><strong>优点</strong>：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li><strong>缺点</strong>：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li><strong>总结</strong>：用处理器性能换取存储空间（拿时间换空间）</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339557.png"></p><h4 id="1-2-3-惰性删除"><a href="#1-2-3-惰性删除" class="headerlink" title="1.2.3 惰性删除"></a>1.2.3 惰性删除</h4><p>数据到达过期时间，不做处理。等下次访问该数据时，我们需要判断</p><ol><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ol><ul><li><strong>优点</strong>：节约CPU性能，发现必须删除的时候才删除</li><li><strong>缺点</strong>：内存压力很大，出现长期占用内存的数据</li><li><strong>总结</strong>：用存储空间换取处理器性能（拿时间换空间）</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339637.png"></p><h4 id="1-2-4-定期删除"><a href="#1-2-4-定期删除" class="headerlink" title="1.2.4 定期删除"></a>1.2.4 定期删除</h4><p>定时删除和惰性删除这两种方案都是走的极端，那有没有折中方案？</p><p>我们来讲redis的定期删除方案：</p><ul><li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p></li><li><p>每秒钟执行server.hz次<strong>serverCron()</strong>——–&gt;<strong>databasesCron()</strong>———&gt;<strong>activeExpireCycle()</strong></p></li><li><p>**activeExpireCycle()*<em>对每个expires[</em>]逐一进行检测，每次执行耗时：250ms/server.hz</p></li><li><p>对某个expires[*]检测时，随机挑选W个key检测</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果key超时，删除key</span><br><span class="line"></span><br><span class="line">如果一轮中删除的key的数量&gt;W<span class="emphasis">*25%，循环该过程</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果一轮中删除的key的数量≤W*</span>25%，检查下一个expires[<span class="emphasis">*]，0-15循环</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</span></span><br></pre></td></tr></table></figure><ul><li><p>参数current_db用于记录<strong>activeExpireCycle()</strong> 进入哪个expires[*] 执行</p></li><li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行</p></li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339400.png"></p><p>总的来说：定期删除就是周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p><ul><li><strong>特点1</strong>：CPU性能占用设置有峰值，检测频度可自定义设置</li><li><strong>特点2</strong>：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li><strong>总结</strong>：周期性抽查存储空间（随机抽查，重点抽查）</li></ul><h4 id="1-2-5-删除策略对比"><a href="#1-2-5-删除策略对比" class="headerlink" title="1.2.5 删除策略对比"></a>1.2.5 删除策略对比</h4><p>1：定时删除：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节约内存，无占用,</span><br><span class="line">不分时段占用CPU资源，频度高,</span><br><span class="line">拿时间换空间</span><br></pre></td></tr></table></figure><p>2：惰性删除：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存占用严重</span><br><span class="line">延时执行，CPU利用率高</span><br><span class="line">拿空间换时间</span><br></pre></td></tr></table></figure><p>3：定期删除：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存定期随机清理</span><br><span class="line">每秒花费固定的CPU资源维护内存</span><br><span class="line">随机抽查，重点抽查</span><br></pre></td></tr></table></figure><h3 id="1-3-数据淘汰策略（逐出算法）"><a href="#1-3-数据淘汰策略（逐出算法）" class="headerlink" title="1.3 数据淘汰策略（逐出算法）"></a>1.3 数据淘汰策略（逐出算法）</h3><h4 id="1-3-1-淘汰策略概述"><a href="#1-3-1-淘汰策略概述" class="headerlink" title="1.3.1 淘汰策略概述"></a>1.3.1 淘汰策略概述</h4><p>什么叫数据淘汰策略？什么样的应用场景需要用到数据淘汰策略？</p><p>当新数据进入redis时，如果内存不足怎么办？在执行每一个命令前，会调用**freeMemoryIfNeeded()**检测内存是否充足。如果内存不满足新 加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</p><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕，  如不能达到内存清理的要求，将出现错误信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM command not allowed when used memory &gt;&#x27;maxmemory&#x27;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-策略配置"><a href="#1-3-2-策略配置" class="headerlink" title="1.3.2 策略配置"></a>1.3.2 策略配置</h4><p>影响数据淘汰的相关配置如下：</p><p>1：最大可使用内存，即占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure><p>2：每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-samples</span> <span class="string">count</span></span><br></pre></td></tr></table></figure><p>3：对数据进行删除的选择策略</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">policy</span></span><br></pre></td></tr></table></figure><p>那数据删除的策略policy到底有几种呢？一共是<strong>3类8种</strong></p><p><strong>第一类</strong>：检测易失数据（可能会过期的数据集server.db[i].expires ）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volatile-lru：挑选最近最少使用的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-lfu：挑选最近使用次数最少的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-ttl：挑选将要过期的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-random：任意选择数据淘汰</span></span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339450.png"></p><p><strong>第二类</strong>：检测全库数据（所有数据集server.db[i].dict ）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">allkeys-lru：挑选最近最少使用的数据淘汰</span></span><br><span class="line"><span class="attr">allkeLyRs-lfu：：挑选最近使用次数最少的数据淘汰</span></span><br><span class="line"><span class="attr">allkeys-random：任意选择数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure><p><strong>第三类</strong>：放弃数据驱逐</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">no-enviction（驱逐）：禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out</span> <span class="string">Of Memory)</span></span><br></pre></td></tr></table></figure><p>注意：这些策略是配置到哪个属性上？怎么配置？如下所示</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">volatile-lru</span></span><br></pre></td></tr></table></figure><p><strong>数据淘汰策略配置依据</strong></p><p> 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p><h2 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h2><h3 id="2-1-主从复制简介"><a href="#2-1-主从复制简介" class="headerlink" title="2.1 主从复制简介"></a>2.1 主从复制简介</h3><h4 id="2-1-1-高可用"><a href="#2-1-1-高可用" class="headerlink" title="2.1.1 高可用"></a>2.1.1 高可用</h4><p>首先我们要理解互联网应用因为其独有的特性我们演化出的<strong>三高</strong>架构</p><ul><li><p>高并发</p><blockquote><p>应用要提供某一业务要能支持很多客户端同时访问的能力，我们称为并发，高并发意思就很明确了</p></blockquote></li><li><p>高性能</p><blockquote><p>性能带给我们最直观的感受就是：速度快，时间短</p></blockquote></li><li><p>高可用</p></li></ul><p><strong>可用性</strong>：一年中应用服务正常运行的时间占全年时间的百分比，如下图：表示了应用服务在全年宕机的时间</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339749.png"></p><p>我们把这些时间加在一起就是全年应用服务不可用的时间，然后我们可以得到应用服务全年可用的时间</p><blockquote><p>4小时27分15秒+11分36秒+2分16秒=4小时41分7秒=16867秒</p><p>1年=365<em>24</em>60*60=31536000秒</p><p>可用性=（31536000-16867）/31536000*100%=99.9465151%</p></blockquote><p>业界可用性目标**5个9，即99.999%**，即服务器年宕机时长低于315秒，约5.25分钟</p><h4 id="2-1-2-主从复制概念"><a href="#2-1-2-主从复制概念" class="headerlink" title="2.1.2 主从复制概念"></a>2.1.2 主从复制概念</h4><p>知道了三高的概念之后，我们想：你的“Redis”是否高可用？那我们要来分析单机redis的风险与问题</p><p>问题1.机器故障</p><ul><li>现象：硬盘故障、系统崩溃</li><li>本质：数据丢失，很可能对业务造成灾难性打击</li><li>结论：基本上会放弃使用redis.</li></ul><p>问题2.容量瓶颈</p><ul><li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li><li>本质：穷，硬件条件跟不上</li><li>结论：放弃使用redis</li></ul><p>结论：</p><p>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</p><p>多台服务器连接方案：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339819.png"></p><ul><li>提供数据方：<strong>master</strong></li></ul><p>主服务器，主节点，主库主客户端</p><ul><li>接收数据方：<strong>slave</strong></li></ul><p>从服务器，从节点，从库</p><p>从客户端</p><ul><li>需要解决的问题：</li></ul><p>数据同步（master的数据复制到slave中）</p><p>这里我们可以来解释主从复制的概念：</p><p><strong>概念：主从复制即将master中的数据即时、有效的复制到slave中</strong></p><p><strong>特征</strong>：一个master可以拥有多个slave，一个slave只对应一个master</p><p><strong>职责</strong>：master和slave各自的职责不一样</p><p>master:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写数据</span><br><span class="line"></span><br><span class="line">执行写操作时，将出现变化的数据自动同步到slave</span><br><span class="line"></span><br><span class="line">读数据（可忽略）</span><br></pre></td></tr></table></figure><p>slave:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读数据</span><br><span class="line"></span><br><span class="line">写数据（禁止）</span><br></pre></td></tr></table></figure><h4 id="2-1-3-主从复制的作用"><a href="#2-1-3-主从复制的作用" class="headerlink" title="2.1.3 主从复制的作用"></a>2.1.3 主从复制的作用</h4><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul><h3 id="2-2-主从复制工作流程"><a href="#2-2-主从复制工作流程" class="headerlink" title="2.2 主从复制工作流程"></a>2.2 主从复制工作流程</h3><p>主从复制过程大体可以分为3个阶段</p><ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段（反复同步）</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339463.png"></p><p>而命令的传播其实有4种，分别如下：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032339043.png"></p><h4 id="2-2-1-主从复制的工作流程（三个阶段）"><a href="#2-2-1-主从复制的工作流程（三个阶段）" class="headerlink" title="2.2.1 主从复制的工作流程（三个阶段）"></a>2.2.1 主从复制的工作流程（三个阶段）</h4><h5 id="2-2-1-1-阶段一：建立连接"><a href="#2-2-1-1-阶段一：建立连接" class="headerlink" title="2.2.1.1 阶段一：建立连接"></a>2.2.1.1 阶段一：建立连接</h5><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p><p>流程如下：</p><ol><li>步骤1：设置master的地址和端口，保存master信息</li><li>步骤2：建立socket连接</li><li>步骤3：发送ping命令（定时器任务）</li><li>步骤4：身份验证</li><li>步骤5：发送slave端口信息</li></ol><p>至此，主从连接成功！</p><p>当前状态：</p><p>slave：保存master的地址与端口</p><p>master：保存slave的端口</p><p>总体：之间创建了连接的socket</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340745.png"></p><p><strong>master和slave互联</strong></p><p>接下来就要通过某种方式将master和slave连接到一起</p><p>方式一：客户端发送命令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">masterip masterport</span></span><br></pre></td></tr></table></figure><p>方式二：启动服务器参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-server</span> <span class="string">--slaveof masterip masterport</span></span><br></pre></td></tr></table></figure><p>方式三：服务器配置（<strong>主流方式</strong>）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">masterip masterport</span></span><br></pre></td></tr></table></figure><p>slave系统信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">master_link_down_since_seconds</span></span><br><span class="line"><span class="attr">masterhost</span> <span class="string">&amp; masterport</span></span><br></pre></td></tr></table></figure><p>master系统信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">uslave_listening_port(多个)</span></span><br></pre></td></tr></table></figure><p><strong>主从断开连接</strong></p><p>断开slave与master的连接，slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">no one</span></span><br></pre></td></tr></table></figure><p><strong>授权访问</strong></p><p>master客户端发送命令设置密码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">requirepass</span> <span class="string">password</span></span><br></pre></td></tr></table></figure><p>master配置文件设置密码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config</span> <span class="string">set requirepass password</span></span><br><span class="line"><span class="attr">config</span> <span class="string">get requirepass</span></span><br></pre></td></tr></table></figure><p>slave客户端发送命令设置密码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auth</span> <span class="string">password</span></span><br></pre></td></tr></table></figure><p>slave配置文件设置密码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">masterauth</span> <span class="string">password</span></span><br></pre></td></tr></table></figure><p>slave启动服务器设置密码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-server</span> <span class="string">–a password</span></span><br></pre></td></tr></table></figure><h5 id="2-2-1-2-阶段二：数据同步"><a href="#2-2-1-2-阶段二：数据同步" class="headerlink" title="2.2.1.2 阶段二：数据同步"></a>2.2.1.2 阶段二：数据同步</h5><ul><li>在slave初次连接master后，复制master中的所有数据到slave</li><li>将slave的数据库状态更新成master当前的数据库状态</li></ul><p>同步过程如下：</p><ol><li>步骤1：请求同步数据</li><li>步骤2：创建RDB同步数据</li><li>步骤3：恢复RDB同步数据</li><li>步骤4：请求部分同步数据</li><li>步骤5：恢复部分同步数据</li></ol><p>至此，数据同步工作完成！</p><p>当前状态：</p><p>slave：具有master端全部数据，包含RDB过程接收的数据</p><p>master：保存slave当前数据同步的位置</p><p>总体：之间完成了数据克隆</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340237.png"></p><p><strong>数据同步阶段master说明</strong></p><p>1：如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p><p>2：复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-backlog-size</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340078.png"></p><p><strong>数据同步阶段slave说明</strong></p><ol><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slave-serve-stale-data</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择</p></li></ol><h5 id="2-2-1-3-阶段三：命令传播"><a href="#2-2-1-3-阶段三：命令传播" class="headerlink" title="2.2.1.3 阶段三：命令传播"></a>2.2.1.3 阶段三：命令传播</h5><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li></ul><p><strong>命令传播阶段的部分复制</strong></p><p>命令传播阶段出现了断网现象：</p><p>网络闪断闪连：忽略</p><p>短时间网络中断：部分复制</p><p>长时间网络中断：全量复制</p><p>这里我们主要来看部分复制，部分复制的三个核心要素</p><ol><li>服务器的运行 id（run id）</li><li>主服务器的复制积压缓冲区</li><li>主从服务器的复制偏移量</li></ol><ul><li>服务器运行ID（runid）</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</span><br><span class="line"></span><br><span class="line">组成：运行id由40位字符组成，是一个随机的十六进制字符</span><br><span class="line">例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</span><br><span class="line"></span><br><span class="line">作用：运行id被用于在服务器间进行传输，识别身份</span><br><span class="line">如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</span><br><span class="line"></span><br><span class="line">实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，</span><br><span class="line">slave保存此ID，通过info Server命令，可以查看节点的runid</span><br></pre></td></tr></table></figure><ul><li>复制缓冲区</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</span><br><span class="line"><span class="code">复制缓冲区默认数据存储空间大小是1M</span></span><br><span class="line"><span class="code">当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</span></span><br><span class="line"><span class="code">作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340249.png"></p><p>复制缓冲区内部工作原理：</p><p>组成</p><ul><li><p>偏移量</p><blockquote><p>概念：一个数字，描述复制缓冲区中的指令字节位置</p><p>分类：</p><ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul><p>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p><p>数据来源：</p><ul><li>master端：发送一次记录一次</li><li>slave端：接收一次记录一次</li></ul></blockquote></li><li><p>字节值</p></li></ul><p>工作原理</p><ul><li>通过offset区分不同的slave当前数据传播的差异</li><li>master记录已发送的信息对应的offset</li><li>slave记录已接收的信息对应的offset</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340372.png"></p><h4 id="2-2-2-流程更新-全量复制-部分复制"><a href="#2-2-2-流程更新-全量复制-部分复制" class="headerlink" title="2.2.2 流程更新(全量复制/部分复制)"></a>2.2.2 流程更新(全量复制/部分复制)</h4><p>我们再次的总结一下主从复制的三个阶段的工作流程：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340838.png"></p><h4 id="2-2-3-心跳机制"><a href="#2-2-3-心跳机制" class="headerlink" title="2.2.3 心跳机制"></a>2.2.3 心跳机制</h4><p>什么是心跳机制？</p><p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p><p>master心跳：</p><ul><li>内部指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication  获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul><p>slave心跳任务</p><ul><li>内部指令：REPLCONF ACK {offset}</li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul><p>心跳阶段注意事项：</p><ul><li>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">min-slaves-to-write</span> <span class="string">2</span></span><br><span class="line"><span class="attr">min-slaves-max-lag</span> <span class="string">8</span></span><br></pre></td></tr></table></figure><p>slave数量少于2个，或者所有slave的延迟都大于等于8秒时，强制关闭master写功能，停止数据同步</p><ul><li>slave数量由slave发送REPLCONF ACK命令做确认</li></ul><ul><li>slave延迟由slave发送REPLCONF ACK命令做确认</li></ul><p>至此：我们可以总结出完整的主从复制流程：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340104.png"></p><h3 id="2-3-主从复制常见问题"><a href="#2-3-主从复制常见问题" class="headerlink" title="2.3 主从复制常见问题"></a>2.3 主从复制常见问题</h3><h4 id="2-3-1-频繁的全量复制"><a href="#2-3-1-频繁的全量复制" class="headerlink" title="2.3.1 频繁的全量复制"></a>2.3.1 频繁的全量复制</h4><ul><li>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</li></ul><p>内部优化调整方案：</p><p>1：master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</p><p>2：在master关闭时执行命令shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repl-id  repl-offset</span><br><span class="line"></span><br><span class="line">通过redis-check-rdb命令可以查看该信息</span><br></pre></td></tr></table></figure><p>3：master重启后加载RDB文件，恢复数据，重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master<span class="emphasis">_repl_</span>id=repl  master<span class="emphasis">_repl_</span>offset =repl-offset</span><br><span class="line"></span><br><span class="line">通过info命令可以查看该信息</span><br></pre></td></tr></table></figure><p>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p><ul><li>第二种出现频繁全量复制的问题现象：网络环境不佳，出现网络中断，slave不提供服务</li></ul><p>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</p><p>最终结果：slave反复进行全量复制</p><p>解决方案：修改复制缓冲区大小</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-backlog-size</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure><p>建议设置如下：</p><p>1.测算从master到slave的重连平均时长second</p><p>2.获取master平均每秒产生写命令数据总量write_size_per_second</p><p>3.最优复制缓冲区空间 = 2 * second * write_size_per_second</p><h4 id="2-3-2-频繁的网络中断"><a href="#2-3-2-频繁的网络中断" class="headerlink" title="2.3.2 频繁的网络中断"></a>2.3.2 频繁的网络中断</h4><ul><li>问题现象：master的CPU占用过高 或 slave频繁断开连接</li></ul><p>问题原因</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slave每1秒发送REPLCONFACK命令到master</span><br><span class="line"></span><br><span class="line">当slave接到了慢查询时（keys <span class="emphasis">* ，hgetall等），会大量占用CPU性能</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</span></span><br></pre></td></tr></table></figure><p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p><p>解决方案：通过设置合理的超时时间，确认是否释放slave</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-timeout</span> <span class="string">seconds</span></span><br></pre></td></tr></table></figure><p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p><ul><li>问题现象：slave与master连接断开</li></ul><p>问题原因</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">master发送ping指令频度较低</span><br><span class="line"></span><br><span class="line">master设定超时时间较短</span><br><span class="line"></span><br><span class="line">ping指令在网络中存在丢包</span><br></pre></td></tr></table></figure><p>解决方案：提高ping指令发送的频度</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-ping-slave-period</span> <span class="string">seconds</span></span><br></pre></td></tr></table></figure><p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p><h4 id="2-3-3-数据不一致"><a href="#2-3-3-数据不一致" class="headerlink" title="2.3.3 数据不一致"></a>2.3.3 数据不一致</h4><p>问题现象：多个slave获取相同数据不同步</p><p>问题原因：网络信息不同步，数据发送有延迟</p><p>解决方案</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</span><br><span class="line"></span><br><span class="line">监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slave-serve-stale-data</span><span class="string">yes|no</span></span><br></pre></td></tr></table></figure><p>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p><h2 id="3-哨兵模式"><a href="#3-哨兵模式" class="headerlink" title="3.哨兵模式"></a>3.哨兵模式</h2><h3 id="3-1-哨兵简介"><a href="#3-1-哨兵简介" class="headerlink" title="3.1 哨兵简介"></a>3.1 哨兵简介</h3><h4 id="3-1-1-哨兵概念"><a href="#3-1-1-哨兵概念" class="headerlink" title="3.1.1 哨兵概念"></a>3.1.1 哨兵概念</h4><p>首先我们来看一个业务场景：如果redis的master宕机了，此时应该怎么办？</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340435.png"></p><p>那此时我们可能需要从一堆的slave中重新选举出一个新的master，那这个操作过程是什么样的呢？这里面会有什么问题出现呢？</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032340460.png"></p><p>要实现这些功能，我们就需要redis的哨兵，那哨兵是什么呢？</p><p><strong>哨兵</strong></p><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过<strong>投票</strong>机制<strong>选择</strong>新的master并将所有slave连接到新的master。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341820.png"></p><h4 id="3-1-2-哨兵作用"><a href="#3-1-2-哨兵作用" class="headerlink" title="3.1.2 哨兵作用"></a>3.1.2 哨兵作用</h4><p>哨兵的作用：</p><ul><li><p>监控：监控master和slave</p><p>不断的检查master和slave是否正常运行</p><p>master存活检测、master与slave运行情况检测</p></li></ul><ul><li>通知（提醒）：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知</li></ul><ul><li>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接新的master，并告知客户端新的服务器地址</li></ul><p>注意：哨兵也是一台redis服务器，只是不提供数据相关服务，通常哨兵的数量配置为单数</p><h3 id="3-2-启用哨兵"><a href="#3-2-启用哨兵" class="headerlink" title="3.2 启用哨兵"></a>3.2 启用哨兵</h3><p>配置哨兵</p><ul><li><p>配置一拖二的主从结构（利用之前的方式启动即可）</p></li><li><p>配置三个哨兵（配置相同，端口不同），参看sentinel.conf</p></li></ul><p>1：设置哨兵监听的主服务器信息， sentinel_number表示参与投票的哨兵数量</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">monitor master_name  master_hostmaster_port sentinel_number</span></span><br></pre></td></tr></table></figure><p>2：设置判定服务器宕机时长，该设置控制是否进行主从切换</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">down-after-milliseconds master_namemillion_seconds</span></span><br></pre></td></tr></table></figure><p>3：设置故障切换的最大超时时</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">failover-timeout master_namemillion_seconds</span></span><br></pre></td></tr></table></figure><p>4：设置主从切换后，同时进行数据同步的slave数量，数值越大，要求网络资源越高，数值越小，同步时间越长</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">parallel-syncs master_name sync_slave_number</span></span><br></pre></td></tr></table></figure><ul><li>启动哨兵</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-sentinel</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure><h3 id="3-3-哨兵工作原理"><a href="#3-3-哨兵工作原理" class="headerlink" title="3.3 哨兵工作原理"></a>3.3 哨兵工作原理</h3><p>哨兵在进行主从切换过程中经历三个阶段</p><ul><li>监控</li><li>通知</li><li>故障转移</li></ul><h4 id="3-3-1-监控"><a href="#3-3-1-监控" class="headerlink" title="3.3.1 监控"></a>3.3.1 监控</h4><p>用于同步各个节点的状态信息</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341193.png"></p><ul><li>获取各个sentinel的状态（是否在线）</li></ul><ul><li>获取master的状态</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master属性</span><br><span class="line"><span class="code">prunid</span></span><br><span class="line"><span class="code">prole：master</span></span><br><span class="line"><span class="code">各个slave的详细信息</span></span><br></pre></td></tr></table></figure><ul><li>获取所有slave的状态（根据master中的slave信息）</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slave属性</span><br><span class="line"><span class="code">prunid</span></span><br><span class="line"><span class="code">prole：slave</span></span><br><span class="line"><span class="code">pmaster_host、master_port</span></span><br><span class="line"><span class="code">poffset</span></span><br></pre></td></tr></table></figure><p>其内部的工作原理具体如下：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341526.png"></p><h4 id="3-3-2-通知"><a href="#3-3-2-通知" class="headerlink" title="3.3.2 通知"></a>3.3.2 通知</h4><p>sentinel在通知阶段要不断的去获取master/slave的信息，然后在各个sentinel之间进行共享，具体的流程如下：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341521.png"></p><h4 id="3-3-3-故障转移"><a href="#3-3-3-故障转移" class="headerlink" title="3.3.3 故障转移"></a>3.3.3 故障转移</h4><p>当master宕机后sentinel是如何知晓并判断出master是真的宕机了呢？我们来看具体的操作流程</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341973.png"></p><p>当sentinel认定master下线之后，此时需要决定更换master，那这件事由哪个sentinel来做呢？这时候sentinel之间要进行选举，如下图所示：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341326.png"></p><p>在选举的时候每一个人手里都有一票，而每一个人的又都想当这个处理事故的人，那怎么办？大家就开始抢，于是每个人都会发出一个指令，在内网里边告诉大家我要当选举人，比如说现在的sentinel1和sentinel4发出这个选举指令了，那么sentinel2既能接到sentinel1的也能接到sentinel4的，接到了他们的申请以后呢，sentinel2他就会把他的一票投给其中一方，投给谁呢？谁先过来我投给谁，假设sentinel1先过来，所以这个票就给到了sentinel1。那么给过去以后呢，现在sentinel1就拿到了一票，按照这样的一种形式，最终会有一个选举结果。对应的选举最终得票多的，那自然就成为了处理事故的人。需要注意在这个过程中有可能会存在失败的现象，就是一轮选举完没有选取，那就会接着进行第二轮第三轮直到完成选举。</p><p>接下来就是由选举胜出的sentinel去从slave中选一个新的master出来的工作，这个流程是什么样的呢？</p><p>首先它有一个在服务器列表中挑选备选master的原则</p><ul><li>不在线的OUT</li></ul><ul><li>响应慢的OUT</li></ul><ul><li>与原master断开时间久的OUT</li></ul><ul><li><p>优先原则</p><p>​    优先级<br>​        offset<br>​        runid</p></li></ul><p>选出新的master之后，发送指令（ sentinel ）给其他的slave：</p><ul><li>向新的master发送slaveof no one</li></ul><ul><li>向其他slave发送slaveof 新masterIP端口</li></ul><p><strong>总结</strong>：故障转移阶段</p><ol><li>发现问题，主观下线与客观下线</li><li>竞选负责人</li><li>优选新master</li><li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li></ol><h2 id="4-集群cluster"><a href="#4-集群cluster" class="headerlink" title="4.集群cluster"></a>4.集群cluster</h2><p>现状问题：业务发展过程中遇到的峰值瓶颈</p><ul><li>redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到10万/秒</li><li>内存单机容量达到256G，当前业务需求内存容量1T</li><li>使用集群的方式可以快速解决上述问题</li></ul><h3 id="4-1-集群简介"><a href="#4-1-集群简介" class="headerlink" title="4.1 集群简介"></a>4.1 集群简介</h3><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341545.png"></p><p><strong>集群作用：</strong></p><ul><li>分散单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341078.png"></p><h3 id="4-2-Cluster集群结构设计"><a href="#4-2-Cluster集群结构设计" class="headerlink" title="4.2 Cluster集群结构设计"></a>4.2 Cluster集群结构设计</h3><p><strong>数据存储设计：</strong></p><ol><li><p>通过算法设计，计算出key应该保存的位置</p></li><li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分</p><p>注意：每份代表的是一个存储空间，不是一个key的保存空间</p></li><li><p>将key按照计算出的结果放到对应的存储空间</p></li></ol><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032341991.png"></p><p>那redis的集群是如何增强可扩展性的呢？譬如我们要增加一个集群节点</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032342016.png"></p><p>当我们查找数据时，集群是如何操作的呢？</p><ul><li>各个数据库相互通信，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体位置</li></ul><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032342930.png"></p><h3 id="4-3-Cluster集群结构搭建"><a href="#4-3-Cluster集群结构搭建" class="headerlink" title="4.3 Cluster集群结构搭建"></a>4.3 Cluster集群结构搭建</h3><p>首先要明确的几个要点：</p><ul><li>配置服务器（3主3从）</li><li>建立通信（Meet）</li><li>分槽（Slot）</li><li>搭建主从（master-slave）</li></ul><p><strong>Cluster配置</strong></p><ul><li>是否启用cluster，加入cluster节点</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure><ul><li>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-config-file</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure><ul><li>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">milliseconds</span></span><br></pre></td></tr></table></figure><ul><li>master连接的slave最小数量</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-migration-barrier</span> <span class="string">min_slave_number</span></span><br></pre></td></tr></table></figure><p><strong>Cluster节点操作命令</strong></p><ul><li> 查看集群节点信息</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">nodes</span></span><br></pre></td></tr></table></figure><ul><li>更改slave指向新的master</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">replicate master-id</span></span><br></pre></td></tr></table></figure><ul><li>发现一个新节点，新增master</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">meet ip:port</span></span><br></pre></td></tr></table></figure><ul><li>忽略一个没有solt的节点</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">forget server_id</span></span><br></pre></td></tr></table></figure><ul><li>手动故障转移</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">failover</span></span><br></pre></td></tr></table></figure><p><strong>集群操作命令：</strong></p><ul><li>创建集群</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">–-cluster create masterhost1:masterport1 masterhost2:masterport2  masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1  slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n</span></span><br></pre></td></tr></table></figure><p>注意：master与slave的数量要匹配，一个master对应n个slave，由最后的参数n决定</p><p>master与slave的匹配顺序为第一个master与前n个slave分为一组，形成主从结构</p><ul><li>添加master到当前集群中，连接时可以指定任意现有节点地址与端口</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster add-node new-master-host:new-master-port now-host:now-port</span></span><br></pre></td></tr></table></figure><ul><li>添加slave</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</span></span><br></pre></td></tr></table></figure><ul><li>删除节点，如果删除的节点是master，必须保障其中没有槽slot</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster del-node del-slave-host:del-slave-port del-slave-id</span></span><br></pre></td></tr></table></figure><ul><li>重新分槽，分槽是从具有槽的master中划分一部分给其他master，过程中不创建新的槽</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster reshard new-master-host:new-master:port --cluster-from src-  master-id1, src-master-id2, src-master-idn --cluster-to target-master-id --  cluster-slots slots</span></span><br></pre></td></tr></table></figure><p>注意：将需要参与分槽的所有masterid不分先后顺序添加到参数中，使用，分隔</p><p>指定目标得到的槽的数量，所有的槽将平均从每个来源的master处获取</p><ul><li>重新分配槽，从具有槽的master中分配指定数量的槽到另一个master中，常用于清空指定master中的槽</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster reshard src-master-host:src-master-port --cluster-from src-  master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes</span></span><br></pre></td></tr></table></figure><h2 id="5-企业级解决方案"><a href="#5-企业级解决方案" class="headerlink" title="5.企业级解决方案"></a>5.企业级解决方案</h2><h3 id="5-1-缓存预热"><a href="#5-1-缓存预热" class="headerlink" title="5.1 缓存预热"></a>5.1 缓存预热</h3><p><strong>场景</strong>：“宕机”</p><p>服务器启动后迅速宕机</p><p><strong>问题排查</strong>：</p><p>1.请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对redis的高强度操作从而导致问题</p><p>2.主从之间数据吞吐量较大，数据同步操作频度较高</p><p><strong>解决方案：</strong></p><ul><li>前置准备工作：</li></ul><p>1.日常例行统计数据访问记录，统计访问频度较高的热点数据</p><p>2.利用LRU数据删除策略，构建数据留存队列例如：storm与kafka配合</p><ul><li>准备工作：</li></ul><p>1.将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</p><p>2.利用分布式多服务器同时进行数据读取，提速数据加载过程</p><p>3.热点数据主从同时预热</p><ul><li>实施：</li></ul><p>4.使用脚本程序固定触发数据预热过程</p><p>5.如果条件允许，使用了CDN（内容分发网络），效果会更好</p><p><strong>总的来说</strong>：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h3 id="5-2-缓存雪崩"><a href="#5-2-缓存雪崩" class="headerlink" title="5.2 缓存雪崩"></a>5.2 缓存雪崩</h3><p><strong>场景</strong>：数据库服务器崩溃，一连串的场景会随之儿来</p><p>1.系统平稳运行过程中，忽然数据库连接量激增</p><p>2.应用服务器无法及时处理请求</p><p>3.大量408，500错误页面出现</p><p>4.客户反复刷新页面获取数据</p><p>5.数据库崩溃</p><p>6.应用服务器崩溃</p><p>7.重启应用服务器无效</p><p>8.Redis服务器崩溃</p><p>9.Redis集群崩溃</p><p>10.重启数据库后再次被瞬间流量放倒</p><p><strong>问题排查</strong>：</p><p>1.在一个较短的时间内，缓存中较多的key集中过期</p><p>2.此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</p><p>3.数据库同时接收到大量的请求无法及时处理</p><p>4.Redis大量请求被积压，开始出现超时现象</p><p>5.数据库流量激增，数据库崩溃</p><p>6.重启后仍然面对缓存中无数据可用</p><p>7.Redis服务器资源被严重占用，Redis服务器崩溃</p><p>8.Redis集群呈现崩塌，集群瓦解</p><p>9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</p><p>10.应用服务器，redis，数据库全部重启，效果不理想</p><p>总而言之就两点：短时间范围内，大量key集中过期</p><p><strong>解决方案</strong></p><ul><li>思路：</li></ul><p>1.更多的页面静态化处理</p><p>2.构建多级缓存架构</p><p>​    Nginx缓存+redis缓存+ehcache缓存</p><p>3.检测Mysql严重耗时业务进行优化</p><p>​    对数据库的瓶颈排查：例如超时查询、耗时较高事务等</p><p>4.灾难预警机制</p><p>​    监控redis服务器性能指标</p><p>​        CPU占用、CPU使用率</p><p>​        内存容量</p><p>​        查询平均响应时间</p><p>​        线程数</p><p>5.限流、降级</p><p>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</p><ul><li>落地实践：</li></ul><p>1.LRU与LFU切换</p><p>2.数据有效期策略调整</p><p>​    根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</p><p>​    过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</p><p>3.超热数据使用永久key</p><p>4.定期维护（自动+人工）</p><p>​    对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</p><p>5.加锁：慎用！</p><p><strong>总的来说</strong>：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的 出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><h3 id="5-3-缓存击穿"><a href="#5-3-缓存击穿" class="headerlink" title="5.3 缓存击穿"></a>5.3 缓存击穿</h3><p><strong>场景</strong>：还是数据库服务器崩溃，但是跟之前的场景有点不太一样</p><p>1.系统平稳运行过程中</p><p>2.数据库连接量瞬间激增</p><p>3.Redis服务器无大量key过期</p><p>4.Redis内存平稳，无波动</p><p>5.Redis服务器CPU正常</p><p>6.数据库崩溃</p><p><strong>问题排查：</strong></p><p>1.Redis中某个key过期，该key访问量巨大</p><p>2.多个数据请求从服务器直接压到Redis后，均未命中</p><p>3.Redis在短时间内发起了大量对数据库中同一数据的访问</p><p>总而言之就两点：单个key高热数据，key过期</p><p><strong>解决方案</strong>：</p><p>1.预先设定</p><p>​    以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p><p>2.现场调整</p><p>​    监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</p><p>3.后台刷新数据</p><p>​    启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p><p>4.二级缓存</p><p>​    设置不同的失效时间，保障不会被同时淘汰就行</p><p>5.加锁</p><p>​    分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</p><p><strong>总的来说</strong>：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数 据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过 期监控难度较高，配合雪崩处理策略即可。</p><h3 id="5-4-缓存穿透"><a href="#5-4-缓存穿透" class="headerlink" title="5.4 缓存穿透"></a>5.4 缓存穿透</h3><p><strong>场景</strong>：数据库服务器又崩溃了，跟之前的一样吗？</p><p>1.系统平稳运行过程中</p><p>2.应用服务器流量随时间增量较大</p><p>3.Redis服务器命中率随时间逐步降低</p><p>4.Redis内存平稳，内存无压力</p><p>5.Redis服务器CPU占用激增</p><p>6.数据库服务器压力激增</p><p>7.数据库崩溃</p><p><strong>问题排查：</strong></p><p>1.Redis中大面积出现未命中</p><p>2.出现非正常URL访问</p><p><strong>问题分析</strong>：</p><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>出现黑客攻击服务器</li></ul><p><strong>解决方案</strong>：</p><p>1.缓存null</p><p>​    对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p><p>2.白名单策略</p><p>​    提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低）</p><p>​    使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p><p>2.实施监控</p><p>​    实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</p><p>​        非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</p><p>​        活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象</p><p>​    根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</p><p>4.key加密</p><p>​    问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</p><p>​    例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p><p><strong>总的来说</strong>：缓存击穿是指访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p><p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p><h3 id="5-5-性能指标监控"><a href="#5-5-性能指标监控" class="headerlink" title="5.5 性能指标监控"></a>5.5 性能指标监控</h3><p>redis中的监控指标如下：</p><ul><li>性能指标：Performance</li></ul><blockquote><p>响应请求的平均时间:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;latency</span></span><br></pre></td></tr></table></figure><p>平均每秒处理请求总数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;instantaneous_ops_per_sec</span></span><br></pre></td></tr></table></figure><p>缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;hit_rate(calculated)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>内存指标：Memory</p><blockquote><p>当前内存使用量</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;used_memory</span></span><br></pre></td></tr></table></figure><p>内存碎片率（关系到是否进行碎片整理）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;mem_fragmentation_ratio</span></span><br></pre></td></tr></table></figure><p>为避免内存溢出删除的key的总数量</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;evicted_keys</span></span><br></pre></td></tr></table></figure><p>基于阻塞操作（BLPOP等）影响的客户端数量</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;blocked_clients</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>基本活动指标：Basic_activity</p></li></ul><blockquote><p>当前客户端连接总数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;connected_clients</span></span><br></pre></td></tr></table></figure><p>当前连接slave总数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;connected_slaves</span></span><br></pre></td></tr></table></figure><p>最后一次主从信息交换距现在的秒</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;master_last_io_seconds_ago</span></span><br></pre></td></tr></table></figure><p>key的总数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;keyspace</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>持久性指标：Persistence</li></ul><blockquote><p>当前服务器最后一次RDB持久化的时间</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;rdb_last_save_time</span></span><br></pre></td></tr></table></figure><p>当前服务器最后一次RDB持久化后数据变化总量</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;rdb_changes_since_last_save</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>错误指标：Error</li></ul><blockquote><p>被拒绝连接的客户端总数（基于达到最大连接值的因素）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;rejected_connections</span></span><br></pre></td></tr></table></figure><p>key未命中的总次数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;keyspace_misses</span></span><br></pre></td></tr></table></figure><p>主从断开的秒数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;master_link_down_since_seconds</span></span><br></pre></td></tr></table></figure></blockquote><p>要对redis的相关指标进行监控，我们可以采用一些用具：</p><ul><li>CloudInsight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul><p>也有一些命令工具：</p><ul><li>benchmark</li></ul><blockquote><p>测试当前服务器的并发性能</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span> <span class="string">[-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span></span><br></pre></td></tr></table></figure><p>范例1：50个连接，10000次请求对应的性能</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span></span><br></pre></td></tr></table></figure><p>范例2：100个连接，5000次请求对应的性能</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span> <span class="string">-c 100 -n 5000</span></span><br></pre></td></tr></table></figure><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032342731.png"></p></blockquote><ul><li><p>redis-cli</p><p>​    monitor：启动服务器调试信息</p></li></ul><blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;monitor</span></span><br></pre></td></tr></table></figure></blockquote><pre><code>  slowlog：慢日志</code></pre><blockquote><p>获取慢查询日志</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;slowlog</span> <span class="string">[operator]</span></span><br></pre></td></tr></table></figure><p>​    get ：获取慢查询日志信息</p><p>​    len ：获取慢查询日志条目数</p><p>​    reset ：重置慢查询日志</p><p>相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;slowlog-log-slower-than</span> <span class="string">1000 #设置慢查询的时间下线，单位：微妙</span></span><br><span class="line"><span class="attr">&gt;slowlog-max-len</span> <span class="string">100#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/2022/08/01/redis/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/01/redis/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Redis基础"><a href="#第一章-Redis基础" class="headerlink" title="第一章 Redis基础"></a>第一章 Redis基础</h1><p><strong>课程计划</strong></p><table><thead><tr><th>1. Redis 入 门</th><th><strong>（了解）</strong></th><th><strong>（操作）</strong></th><th></th></tr></thead><tbody><tr><td>2. 数据类型</td><td><strong>（重点）</strong></td><td><strong>（操作）</strong></td><td><strong>（理解）</strong></td></tr><tr><td>3. 常用指令</td><td></td><td><strong>（操作）</strong></td><td></td></tr><tr><td>4. Jedis</td><td><strong>（重点）</strong></td><td><strong>（操作）</strong></td><td></td></tr><tr><td>5. 持 久 化</td><td><strong>（重点）</strong></td><td></td><td><strong>（理解）</strong></td></tr><tr><td>6. 数据删除与淘汰策略</td><td></td><td></td><td><strong>（理解）</strong></td></tr><tr><td>7. 主从复制</td><td><strong>（重点）</strong></td><td><strong>（操作）</strong></td><td><strong>（理解）</strong></td></tr><tr><td>8. 哨 兵</td><td><strong>（重点）</strong></td><td><strong>（操作）</strong></td><td><strong>（理解）</strong></td></tr><tr><td>9. Cluster集群方案</td><td><strong>（重点）</strong></td><td><strong>（操作）</strong></td><td><strong>（理解）</strong></td></tr><tr><td>10. 企业级缓存解决方案</td><td><strong>（重点）</strong></td><td></td><td><strong>（理解）</strong></td></tr><tr><td>11. 性能指标监控</td><td><strong>（了解）</strong></td><td></td><td></td></tr></tbody></table><h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><p>目标1：能够说出NoSQL的概念，redis的应用场景，能够完成redis的下载安装与启动以及一些常用的配置</p><p>目标2：能够说出redis常用的5种数据类型，对应这些数据类型的基本操作，应用场景及对应的解决方案</p><p>目标3：能够说出redis中常用的一些基本指令</p><p>目标4：能够使用jedis完成客户端应用程序的开发</p><p>目标5：能够说出redis数据持久化的两种方式，各自相关的操作配置及指令，以及两种方式的优缺点比较</p><h2 id="1-Redis-简介"><a href="#1-Redis-简介" class="headerlink" title="1. Redis 简介"></a>1. Redis 简介</h2><p>在这个部分，我们将学习以下3个部分的内容，分别是：</p><p>◆ Redis 简介（NoSQL概念、Redis概念）</p><p>◆ Redis 的下载与安装</p><p>◆ Redis 的基本操作</p><h3 id="1-1-NoSQL概念"><a href="#1-1-NoSQL概念" class="headerlink" title="1.1 NoSQL概念"></a>1.1 NoSQL概念</h3><h4 id="1-1-1-问题现象"><a href="#1-1-1-问题现象" class="headerlink" title="1.1.1 问题现象"></a>1.1.1 问题现象</h4><p>在讲解NoSQL的概念之前呢，我们先来看一个现象：</p><p>（1）问题现象</p><p>每年到了过年期间，大家都会自觉自发的组织一场活动，叫做春运！以前我们买票都是到火车站排队，后来呢有了12306，有了他以后就更方便了，我们可以在网上买票，但是带来的问题，大家也很清楚，春节期间买票进不去，进去了刷不着票。什么原因呢，人太多了！</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032349717.png"></p><p>除了这种做铁路的，它系统做的不专业以外，还有马爸爸做的淘宝，它面临一样的问题。淘宝也崩，也是用户量太大！作为我们整个电商界的东哥来说，他第一次做图书促销的时候，也遇到了服务器崩掉的这样一个现象，原因同样是因为用户量太大！</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032350907.png"></p><p>（2）现象特征</p><p>再来看这几个现象，有两个非常相似的特征：</p><p>第一，用户比较多，海量用户</p><p>第二，高并发</p><p>这两个现象出现以后，对应的就会造成我们的服务器瘫痪。核心本质是什么呢？其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首！</p><p>（3）造成原因</p><p>什么样的原因导致的整个系统崩掉的呢：</p><p>1.性能瓶颈：磁盘IO性能低下</p><p>关系型数据库菜存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的。</p><p>2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群</p><p>我们说关系型数据库，它里面表与表之间的关系非常复杂，不知道大家能不能想象一点，就是一张表，通过它的外键关联了七八张表，这七八张表又通过她的外件，每张又关联了四五张表。你想想，查询一下，你要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难!</p><p>（4）解决思路</p><p>面对这样的现象，我们要想解决怎么版呢。两方面：</p><p>一，降低磁盘IO次数，越低越好。</p><p>二，去除数据间关系，越简单越好。</p><p>降低磁盘IO次数，越低越好，怎么搞？我不用你磁盘不就行了吗？于是，内存存储的思想就提出来了，我数据不放到你磁盘里边，放内存里，这样是不是效率就高了。</p><p>第二，你的数据关系很复杂，那怎么办呢？干脆简单点，我断开你的关系，我不存关系了，我只存数据，这样不就没这事了吗？</p><p>把这两个特征一合并一起，就出来了一个新的概念：NoSQL</p><h4 id="1-1-2-NoSQL的概念"><a href="#1-1-2-NoSQL的概念" class="headerlink" title="1.1.2 NoSQL的概念"></a>1.1.2 NoSQL的概念</h4><p>（1）概念</p><p>NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。</p><p>他说这句话说的非常客气，什么意思呢？就是我们数据存储要用SQL，但是呢可以不仅仅用SQL，还可以用别的东西，那别的东西叫什么呢？于是他定义了一句话叫做NoSQL。这个意思就是说我们存储数据，可以不光使用SQL，我们还可以使用非SQL的这种存储方案，这就是所谓的NoSQL。</p><p>（2）特征</p><p>可扩容，可伸缩。SQL数据关系过于复杂，你扩容一下难度很高，那我们Nosql 这种的，不存关系，所以它的扩容就简单一些。</p><p>大数据量下高性能。包数据非常多的时候，它的性能高，因为你不走磁盘IO，你走的是内存，性能肯定要比磁盘IO的性能快一些。</p><p>灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它！</p><p>（3）常见 Nosql 数据库</p><p>目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB</p><p>（4）应用场景-电商为例</p><p>我们以电商为例，来看一看他在这里边起到的作用。</p><p>第一类，在电商中我们的基础数据一定要存储起来，比如说商品名称，价格，生产厂商，这些都属于基础数据，这些数据放在MySQL数据库。</p><p>第二类，我们商品的附加信息，比如说，你买了一个商品评价了一下，这个评价它不属于商品本身。就像你买一个苹果，“这个苹果很好吃”就是评论，但是你能说很好吃是这个商品的属性嘛？不能这么说，那只是一个人对他的评论而已。这一类数据呢，我们放在另外一个地方，我们放到MongoDB。它也可以用来加快我们的访问，他属于NoSQL的一种。</p><p>第三，图片内的信息。注意这种信息相对来说比较固定，他有专用的存储区，我们一般用文件系统来存储。至于是不是分布式，要看你的系统的一个整个   瓶颈   了？如果说你发现你需要做分布式，那就做，不需要的话，一台主机就搞定了。</p><p>第四，搜索关键字。为了加快搜索，我们会用到一些技术，有些人可能了解过，像分ES、Lucene、solr都属于搜索技术。那说的这么热闹，我们的电商解决方案中还没出现我们的redis啊！注意第五类信息。</p><p>第五，热点信息。访问频度比较高的信息，这种东西的第二特征就是它具有波段性。换句话说他不是稳定的，它具有一个时效性的。那么这类信息放哪儿了，放到我们的redis这个解决方案中来进行存储。</p><p>具体的我们从我们的整个数据存储结构的设计上来看一下。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032351303.png"></p><p>我们的基础数据都存MySQL,在它的基础之上，我们把它连在一块儿，同时对外提供服务。向上走，有一些信息加载完以后,要放到我们的MongoDB中。还有一类信息，我们放到我们专用的文件系统中（比如图片），就放到我们的这个搜索专用的，如Lucene、solr及集群里边，或者用ES的这种技术里边。那么剩下来的热点信息，放到我们的redis里面。</p><h3 id="1-2-Redis概念"><a href="#1-2-Redis概念" class="headerlink" title="1.2 Redis概念"></a>1.2 Redis概念</h3><h4 id="1-2-1-redis概念"><a href="#1-2-1-redis概念" class="headerlink" title="1.2.1 redis概念"></a>1.2.1 redis概念</h4><p>概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。</p><p>特征：</p><p>（1）数据间没有必然的关联关系；</p><p>（2）内部采用单线程机制进行工作；</p><p>（3）高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</p><p>（4）多数据类型支持</p><p>字符串类型，string  list</p><p>列表类型，hash  set</p><p>散列类型，zset/sorted_set</p><p>集合类型</p><p>有序集合类型</p><p>（5）支持持久化，可以进行数据灾难恢复</p><h4 id="1-2-2-redis的应用场景"><a href="#1-2-2-redis的应用场景" class="headerlink" title="1.2.2 redis的应用场景"></a>1.2.2 redis的应用场景</h4><p>（1）为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。</p><p>（2）即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。</p><p>（3）时效性信息控制。如验证码控制、投票控制等。</p><p>（4）分布式数据共享。如分布式集群架构中的 session 分离<br>消息队列.</p><h3 id="1-3-Redis-的下载与安装"><a href="#1-3-Redis-的下载与安装" class="headerlink" title="1.3 Redis 的下载与安装"></a>1.3 Redis 的下载与安装</h3><p>后期所有资料分4中不同色块显示，详情如下：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032352663.png"></p><h4 id="1-3-1-Redis-的下载与安装"><a href="#1-3-1-Redis-的下载与安装" class="headerlink" title="1.3.1 Redis 的下载与安装"></a>1.3.1 Redis 的下载与安装</h4><p>本课程所示，均基于Center OS7安装Redis。</p><p>（1)下载Redis</p><p>下载安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure><p>解压安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure><p>编译（在解压的目录中执行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装（在解压的目录中执行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p>（2）安装 Redis</p><p>redis-server，服务器启动命令 客户端启动命令</p><p>redis-cli，redis核心配置文件</p><p>redis.conf，RDB文件检查工具（快照持久化文件）</p><p>redis-check-dump，AOF文件修复工具</p><p>redis-check-aof</p><h3 id="1-4-Redis服务器启动"><a href="#1-4-Redis服务器启动" class="headerlink" title="1.4 Redis服务器启动"></a>1.4 Redis服务器启动</h3><h4 id="1-4-1-Redis服务器启动"><a href="#1-4-1-Redis服务器启动" class="headerlink" title="1.4.1 Redis服务器启动"></a>1.4.1 Redis服务器启动</h4><p>启动服务器——参数启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server [--port port]</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --port 6379</span><br></pre></td></tr></table></figure><p>启动服务器——配置文件启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server config_file_name</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><h4 id="1-4-2-Redis客户端启动"><a href="#1-4-2-Redis客户端启动" class="headerlink" title="1.4.2 Redis客户端启动"></a>1.4.2 Redis客户端启动</h4><p>启动客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [-h host] [-p port]</span><br></pre></td></tr></table></figure><p>范 例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli –h 61.129.65.248 –p 6384</span><br></pre></td></tr></table></figure><p>注意：服务器启动指定端口使用的是–port，客户端启动指定端口使用的是-p。-的数量不同。</p><h4 id="1-4-3-Redis基础环境设置约定"><a href="#1-4-3-Redis基础环境设置约定" class="headerlink" title="1.4.3 Redis基础环境设置约定"></a>1.4.3 Redis基础环境设置约定</h4><p>创建配置文件存储目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> conf</span><br></pre></td></tr></table></figure><p>创建服务器文件存储目录（包含日志、数据、临时配置文件等）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> data</span><br></pre></td></tr></table></figure><p>创建快速访问链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s redis-5.0.0 redis</span><br></pre></td></tr></table></figure><h3 id="1-5-配置文件启动与常用配置"><a href="#1-5-配置文件启动与常用配置" class="headerlink" title="1.5 配置文件启动与常用配置"></a>1.5 配置文件启动与常用配置</h3><h4 id="1-5-1-服务器端设定"><a href="#1-5-1-服务器端设定" class="headerlink" title="1.5.1 服务器端设定"></a>1.5.1 服务器端设定</h4><p>设置服务器以守护进程的方式运行，开启后服务器控制台中将打印服务器运行信息（同日志内容相同）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure><p>绑定主机地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> ip</span><br></pre></td></tr></table></figure><p>设置服务器端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port port</span><br></pre></td></tr></table></figure><p>设置服务器文件保存地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> path</span><br></pre></td></tr></table></figure><h4 id="1-5-2-客户端配置"><a href="#1-5-2-客户端配置" class="headerlink" title="1.5.2  客户端配置"></a>1.5.2  客户端配置</h4><p> 服务器允许客户端连接最大数量，默认0，表示无限制。当客户端连接到达上限后，Redis会拒绝新的连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients count</span><br></pre></td></tr></table></figure><p>客户端闲置等待最大时长，达到最大值后关闭对应连接。如需关闭该功能，设置为 0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">timeout</span> seconds</span><br></pre></td></tr></table></figure><h4 id="1-5-3-日志配置"><a href="#1-5-3-日志配置" class="headerlink" title="1.5.3  日志配置"></a>1.5.3  日志配置</h4><p>设置服务器以指定日志记录级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure><p>日志记录文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile filename</span><br></pre></td></tr></table></figure><p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。</p><h3 id="1-6-Redis基本操作"><a href="#1-6-Redis基本操作" class="headerlink" title="1.6 Redis基本操作"></a>1.6 Redis基本操作</h3><h4 id="1-6-1-命令行模式工具使用思考"><a href="#1-6-1-命令行模式工具使用思考" class="headerlink" title="1.6.1  命令行模式工具使用思考"></a>1.6.1  命令行模式工具使用思考</h4><p>功能性命令</p><p>帮助信息查阅</p><p>退出指令</p><p>清除屏幕信息</p><h4 id="1-6-2-信息读写"><a href="#1-6-2-信息读写" class="headerlink" title="1.6.2  信息读写"></a>1.6.2  信息读写</h4><p>设置 key，value 数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name itheima</span><br></pre></td></tr></table></figure><p>根据 key 查询对应的 value，如果不存在，返回空（nil）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure><h4 id="1-6-3-帮助信息"><a href="#1-6-3-帮助信息" class="headerlink" title="1.6.3  帮助信息"></a>1.6.3  帮助信息</h4><p>获取命令帮助文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>获取组中所有命令信息名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [@group-name]</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @string</span><br></pre></td></tr></table></figure><p>1.6.4  退出命令行客户端模式</p><p>退出客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>快捷键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure><h4 id="1-6-4-redis入门总结"><a href="#1-6-4-redis入门总结" class="headerlink" title="1.6.4  redis入门总结"></a>1.6.4  redis入门总结</h4><p>到这里，Redis 入门的相关知识，我们就全部学习完了，再来回顾一下，这个部分我们主要讲解了哪些内容呢？</p><p>首先，我们对Redis进行了一个简单介绍，包括NoSQL的概念、Redis的概念等。</p><p>然后，我们介绍了Redis 的下载与安装。包括下载与安装、服务器与客户端启动、以及相关配置文件（3类）。</p><p>最后，我们介绍了Redis 的基本操作。包括数据读写、退出与帮助信息获取。</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>在这个部分，我们将学习一共要学习三大块内容，首先需要了解一下数据类型，接下来将针对着我们要学习的数据类型进行逐一的讲解，如string、hash、list、set等，最后我们通过一个案例来总结前面的数据类型的使用场景。</p><h3 id="2-1-数据存储类型介绍"><a href="#2-1-数据存储类型介绍" class="headerlink" title="2.1  数据存储类型介绍"></a>2.1  数据存储类型介绍</h3><h4 id="2-1-1-业务数据的特殊性"><a href="#2-1-1-业务数据的特殊性" class="headerlink" title="2.1.1  业务数据的特殊性"></a>2.1.1  业务数据的特殊性</h4><p>在讲解数据类型之前，我们得先思考一个问题，数据类型既然是用来描述数据的存储格式的，如果你不知道哪些数据未来会进入到我们来的redis中，那么对应的数据类型的选择，你就会出现问题，我们一块来看一下：</p><p>（1）原始业务功能设计</p><p>秒杀。他这个里边数据变化速度特别的快，访问量也特别的高，用户大量涌入以后都会针对着一部分数据进行操作，这一类要记住。</p><p>618活动。对于我们京东的618活动、以及天猫的双11活动，相信大家不用说都知道这些数据一定要进去，因为他们的访问频度实在太高了。</p><p>排队购票。我们12306的票务信息。这些信息在原始设计的时候，他们就注定了要进redis。</p><p>（2）运营平台监控到的突发高频访问数据</p><p>此类平台临时监控到的这些数据，比如说现在出来的一个八卦的信息，这个新闻一旦出现以后呢，顺速的被围观了，那么这个时候，这个数据就会变得访量特别高，那么这类信息也要进入进去。</p><p>（3）高频、复杂的统计数据</p><p>在线人数。比如说直播现在很火，直播里边有很多数据，例如在线人数。进一个人出一个人，这个数据就要跳动，那么这个访问速度非常的快，而且访量很高，并且它里边有一个复杂的数据统计，在这里这种信息也要进入到我们的redis中。</p><p>投票排行榜。投票投票类的信息他的变化速度也比较快，为了追求一个更快的一个即时投票的名次变化，这种数据最好也放到redis中。</p><h4 id="2-1-2-Redis-数据类型-5种常用"><a href="#2-1-2-Redis-数据类型-5种常用" class="headerlink" title="2.1.2  Redis 数据类型(5种常用)"></a>2.1.2  Redis 数据类型(5种常用)</h4><p>基于以上数据特征我们进行分析，最终得出来我们的Redis中要设计5种 数据类型：</p><p>string、hash、list、set、sorted_set/zset（应用性较低）</p><h3 id="2-2-string数据类型"><a href="#2-2-string数据类型" class="headerlink" title="2.2  string数据类型"></a>2.2  string数据类型</h3><p>在学习第一个数据类型之前，先给大家介绍一下，在随后这部分内容的学习过程中，我们每一种数据类型都分成三块来讲：首先是讲下它的基本操作，接下来讲一些它的扩展操作，最后我们会去做一个小的案例分析。</p><h4 id="2-2-1Redis-数据存储格式"><a href="#2-2-1Redis-数据存储格式" class="headerlink" title="2.2.1Redis 数据存储格式"></a>2.2.1Redis 数据存储格式</h4><p>在学习string这个数据形式之前，我们先要明白string到底是修饰什么的。我们知道redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储。</p><p>对于这种结构来说，我们用来存储数据一定是一个值前面对应一个名称。我们通过名称来访问后面的值。按照这种形势，我们可以对出来我们的存储格式。前面这一部分我们称为key。后面的一部分称为value，而我们的数据类型，他一定是修饰value的。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032352284.png"></p><p>数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。</p><h4 id="2-2-2-string-类型"><a href="#2-2-2-string-类型" class="headerlink" title="2.2.2  string 类型"></a>2.2.2  string 类型</h4><p>（1）存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型。</p><p>string，他就是存一个字符串儿，注意是value那一部分是一个字符串，它是redis中最基本、最简单的存储数据的格式。</p><p>（2）存储数据的格式：一个存储空间保存一个数据</p><p>每一个空间中只能保存一个字符串信息，这个信息里边如果是存的纯数字，他也能当数字使用，我们来看一下，这是我们的数据的存储空间。</p><p>（3）存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用.</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032353453.png"></p><p>一个key对一个value，而这个itheima就是我们所说的string类型，当然它也可以是一个纯数字的格式。</p><h4 id="2-2-3-string-类型数据的基本操作"><a href="#2-2-3-string-类型数据的基本操作" class="headerlink" title="2.2.3  string 类型数据的基本操作"></a>2.2.3  string 类型数据的基本操作</h4><p>（1）基础指令</p><p>添加/修改数据添加/修改数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>判定性添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><p>添加/修改多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2 …</span><br></pre></td></tr></table></figure><p>获取多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 …</span><br></pre></td></tr></table></figure><p>获取数据字符个数（字符串长度）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><p>（2）单数据操作与多数据操作的选择之惑</p><p>即set 与mset的关系。这对于这两个操作来说，没有什么你应该选哪个，而是他们自己的特征是什么，你要根据这个特征去比对你的业务，看看究竟适用于哪个。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032353965.png"></p><p>假如说这是我们现在的服务器，他要向redis要数据的话，它会发出一条指令。那么当这条指令发过来的时候，比如说是这个set指令过来，那么它会把这个结果返回给你，这个时候我们要思考这里边一共经过了多长时间。</p><p>首先，发送set指令要时间，这是网络的一个时间，接下来redis要去运行这个指令要消耗时间，最终把这个结果返回给你又有一个时间，这个时间又是一个网络的时间，那我们可以理解为：一个指令发送的过程中需要消耗这样的时间.</p><p>但是如果说现在不是一条指令了，你要发3个set的话，还要多长时间呢？对应的发送时间要乘3了，因为这是三个单条指令,而运行的操作时间呢，它也要乘3了，但最终返回的也要发3次，所以这边也要乘3。</p><p>于是我们可以得到一个结论：单指令发3条它需要的时间，假定他们两个一样，是6个网络时间加3个处理时间，如果我们把它合成一个mset呢，我们想一想。</p><p>假如说用多指令发3个指令的话，其实只需要发一次就行了。这样我们可以得到一个结论，多指令发3个指令的话，其实它是两个网络时间加上3个redis的操作时间，为什么这写一个小加号呢，就是因为毕竟发的信息量变大了，所以网络时间有可能会变长。</p><p>那么通过这张图，你就可以得到一个结论，我们单指令和多指令他们的差别就在于你发送的次数是多还是少。当你影响的数据比较少的时候，你可以用单指令，也可以用多指令。但是一旦这个量大了，你就要选择多指令了，他的效率会高一些。</p><h3 id="2-3-string-类型数据的扩展操作"><a href="#2-3-string-类型数据的扩展操作" class="headerlink" title="2.3  string 类型数据的扩展操作"></a>2.3  string 类型数据的扩展操作</h3><h4 id="2-3-1-string-类型数据的扩展操作"><a href="#2-3-1-string-类型数据的扩展操作" class="headerlink" title="2.3.1  string 类型数据的扩展操作"></a>2.3.1  string 类型数据的扩展操作</h4><p>下面我们来看一string的扩展操作，分成两大块：一块是对数字进行操作的，第二块是对我们的key的时间进行操作的。</p><p>设置数值数据增加指定范围的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure><p>设置数值数据减少指定范围的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><p>设置数据具有指定的生命周期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure><h4 id="2-3-2-string-类型数据操作的注意事项"><a href="#2-3-2-string-类型数据操作的注意事项" class="headerlink" title="2.3.2  string 类型数据操作的注意事项"></a>2.3.2  string 类型数据操作的注意事项</h4><p>(1)数据操作不成功的反馈与数据正常操作之间的差异</p><p>表示运行结果是否成功</p><p>(integer) 0  → false                 失败</p><p>(integer) 1  → true                  成功</p><p>表示运行结果值</p><p>(integer) 3  → 3                        3个</p><p>(integer) 1  → 1                         1个</p><p>(2)数据未获取到时，对应的数据为（nil），等同于null</p><p>(3)数据最大存储量：512MB</p><p>(4)string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算</p><p>(5)按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错<br>9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE）</p><p>(6)redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响.</p><h3 id="2-4string应用场景与key命名约定"><a href="#2-4string应用场景与key命名约定" class="headerlink" title="2.4string应用场景与key命名约定"></a>2.4string应用场景与key命名约定</h3><h4 id="2-4-1-应用场景"><a href="#2-4-1-应用场景" class="headerlink" title="2.4.1  应用场景"></a>2.4.1  应用场景</h4><p>它的应用场景在于：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032354454.png"></p><p>我们来思考一下：这些信息是不是你进入大V的页面儿以后就要读取这写信息的啊，那这种信息一定要存储到我们的redis中，因为他的访问量太高了！那这种数据应该怎么存呢？我们来一块儿看一下方案！</p><h4 id="2-4-2-解决方案"><a href="#2-4-2-解决方案" class="headerlink" title="2.4.2  解决方案"></a>2.4.2  解决方案</h4><p>（1）在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:user:id:3506728370:fans→12210947</span><br><span class="line">eg:user:id:3506728370:blogs→6164</span><br><span class="line">eg:user:id:3506728370:focuses→83</span><br></pre></td></tr></table></figure><p>（2）也可以使用json格式保存数据</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg:user:id:3506728370    →&#123;“fans”：12210947，“blogs”：6164，“ focuses ”：83 &#125;</span><br></pre></td></tr></table></figure><p>（3） key 的设置约定</p><p>数据库中的热点数据key命名惯例</p><table><thead><tr><th></th><th><strong>表名</strong></th><th><strong>主键名</strong></th><th>主键值</th><th><strong>字段名</strong></th></tr></thead><tbody><tr><td>eg1：</td><td>order</td><td>id</td><td>29437595</td><td>name</td></tr><tr><td>eg2：</td><td>equip</td><td>id</td><td>390472345</td><td>type</td></tr><tr><td>eg3：</td><td>news</td><td>id</td><td>202004150</td><td>title</td></tr></tbody></table><h3 id="2-5-hash的基本操作"><a href="#2-5-hash的基本操作" class="headerlink" title="2.5  hash的基本操作"></a>2.5  hash的基本操作</h3><p>下面我们来学习第二个数据类型hash。</p><h4 id="2-5-1-数据存储的困惑"><a href="#2-5-1-数据存储的困惑" class="headerlink" title="2.5.1  数据存储的困惑"></a>2.5.1  数据存储的困惑</h4><p>对象类数据的存储如果具有较频繁的更新需求操作会显得笨重！</p><p>在正式学习之前，我们先来看一个关于数据存储的困惑：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032354269.png"></p><p>比如说前面我们用以上形式存了数据，如果我们用单条去存的话，它存的条数会很多。但如果我们用json格式，它存一条数据就够了。问题来了，假如说现在粉丝数量发生变化了，你要把整个值都改了。但是用单条存的话就不存在这个问题，你只需要改其中一个就行了。这个时候我们就想，有没有一种新的存储结构，能帮我们解决这个问题呢。</p><p>我们一块儿来分析一下：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032355280.png"></p><p>如上图所示：单条的话是对应的数据在后面放着。仔细观察：我们看左边是不是长得都一模一样啊，都是对应的表名、ID等的一系列的东西。我们可以将右边红框中的这个区域给他封起来。</p><p>那如果要是这样的形式的话，如下图，我们把它一合并，并把右边的东西给他变成这个格式，这不就行了吗？</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032355356.png"></p><p>这个图其实大家并不陌生，第一，你前面学过一个东西叫hashmap不就这格式吗？第二，redis自身不也是这格式吗？那是什么意思呢？注意，这就是我们要讲的第二种格式，hash。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032356147.png"></p><p>在右边对应的值，我们就存具体的值，那左边儿这就是我们的key。问题来了，那中间的这一块叫什么呢？这个东西我们给他起个名儿，叫做field字段。那么右边儿整体这块儿空间我们就称为hash，也就是说hash是存了一个key value的存储空间。</p><h4 id="2-5-2-hash-类型"><a href="#2-5-2-hash-类型" class="headerlink" title="2.5.2  hash 类型"></a>2.5.2  hash 类型</h4><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p><p>需要的存储结构：一个存储空间保存多个键值对数据</p><p>hash类型：底层使用哈希表结构实现数据存储</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032356346.png"></p><p>如上图所示，这种结构叫做hash，左边一个key，对右边一个存储空间。这里要明确一点，右边这块儿存储空间叫hash，也就是说hash是指的一个数据类型，他指的不是一个数据，是这里边的一堆数据，那么它底层呢，是用hash表的结构来实现的。</p><p>值得注意的是：</p><p>如果field数量较少，存储结构优化为类数组结构</p><p>如果field数量较多，存储结构使用HashMap结构</p><h4 id="2-5-3-hash-类型数据的基本操作"><a href="#2-5-3-hash-类型数据的基本操作" class="headerlink" title="2.5.3  hash 类型数据的基本操作"></a>2.5.3  hash 类型数据的基本操作</h4><p>添加/修改数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">hgetall key</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure><p>设置field的值，如果该field存在则不做任何操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure><p>添加/修改多个数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2 …</span><br></pre></td></tr></table></figure><p>获取多个数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2 …</span><br></pre></td></tr></table></figure><p>获取哈希表中字段的数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><p>获取哈希表中是否存在指定的字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><h3 id="2-6-hash的拓展操作"><a href="#2-6-hash的拓展操作" class="headerlink" title="2.6  hash的拓展操作"></a>2.6  hash的拓展操作</h3><p>在看完hash的基本操作后，我们再来看他的拓展操作，他的拓展操作相对比较简单：</p><h4 id="2-6-1-hash-类型数据扩展操作"><a href="#2-6-1-hash-类型数据扩展操作" class="headerlink" title="2.6.1  hash 类型数据扩展操作"></a>2.6.1  hash 类型数据扩展操作</h4><p>获取哈希表中所有的字段名或字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure><p>设置指定字段的数值数据增加指定范围的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure><h4 id="2-6-2-hash类型数据操作的注意事项"><a href="#2-6-2-hash类型数据操作的注意事项" class="headerlink" title="2.6.2  hash类型数据操作的注意事项"></a>2.6.2  hash类型数据操作的注意事项</h4><p>(1)hash类型中value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）。</p><p>(2）每个 hash 可以存储 232 - 1 个键值对<br>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计 的，切记不可滥用，更不可以将hash作为对象列表使用。</p><p>(3)hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。</p><h3 id="2-7-hash应用场景"><a href="#2-7-hash应用场景" class="headerlink" title="2.7  hash应用场景"></a>2.7  hash应用场景</h3><h4 id="2-7-1-应用场景"><a href="#2-7-1-应用场景" class="headerlink" title="2.7.1  应用场景"></a>2.7.1  应用场景</h4><p>双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000  张。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032357036.png"></p><p>也就是商家有了，商品有了，数量有了。最终我们的用户买东西就是在改变这个数量。那你说这个结构应该怎么存呢？对应的商家的ID作为key，然后这些充值卡的ID作为field，最后这些数量作为value。而我们所谓的操作是其实就是increa这个操作，只不过你传负值就行了。看一看对应的解决方案：</p><h4 id="2-7-2-解决方案"><a href="#2-7-2-解决方案" class="headerlink" title="2.7.2  解决方案"></a>2.7.2  解决方案</h4><p>以商家id作为key</p><p>将参与抢购的商品id作为field</p><p>将参与抢购的商品数量作为对应的value</p><p>抢购时使用降值的方式控制产品数量</p><p>注意：实际业务中还有超卖等实际问题，这里不做讨论</p><h3 id="2-8-list基本操作"><a href="#2-8-list基本操作" class="headerlink" title="2.8  list基本操作"></a>2.8  list基本操作</h3><p>前面我们存数据的时候呢，单个数据也能存，多个数据也能存，但是这里面有一个问题，我们存多个数据用hash的时候它是没有顺序的。我们平时操作，实际上数据很多情况下都是有顺序的，那有没有一种能够用来存储带有顺序的这种数据模型呢，list就专门来干这事儿。</p><h4 id="2-8-1-list-类型"><a href="#2-8-1-list-类型" class="headerlink" title="2.8.1  list 类型"></a>2.8.1  list 类型</h4><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p><p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p><p>list类型：保存多个数据，底层使用双向链表存储结构实现</p><p>先来通过一张图，回忆一下顺序表、链表、双向链表。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032357710.png"></p><p>list对应的存储结构是什么呢？里边存的这个东西是个列表，他有一个对应的名称。就是key存一个list的这样结构。对应的基本操作，你其实是可以想到的。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032357161.png"></p><p>来看一下，因为它是双向的，所以他左边右边都能操作，它对应的操作结构两边都能进数据。这就是链表的一个存储结构。往外拿数据的时候怎么拿呢？通常是从一端拿，当然另一端也能拿。如果两端都能拿的话，这就是个双端队列，两边儿都能操作。如果只能从一端进一端出，这个模型咱们前面了解过，叫做栈。</p><h4 id="2-8-2-list-类型数据基本操作"><a href="#2-8-2-list-类型数据基本操作" class="headerlink" title="2.8.2 list 类型数据基本操作"></a>2.8.2 list 类型数据基本操作</h4><p>最后看一下他的基本操作</p><p>添加/修改数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 [value2] ……</span><br><span class="line">rpush key value1 [value2] ……</span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><p>获取并移除数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure><h3 id="2-9-list扩展操作"><a href="#2-9-list扩展操作" class="headerlink" title="2.9  list扩展操作"></a>2.9  list扩展操作</h3><h4 id="2-9-1-list-类型数据扩展操作"><a href="#2-9-1-list-类型数据扩展操作" class="headerlink" title="2.9.1  list 类型数据扩展操作"></a>2.9.1  list 类型数据扩展操作</h4><p>移除指定数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure><p>规定时间内获取并移除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line">brpoplpush source destination timeout</span><br></pre></td></tr></table></figure><h4 id="2-9-2-list-类型数据操作注意事项"><a href="#2-9-2-list-类型数据操作注意事项" class="headerlink" title="2.9.2  list 类型数据操作注意事项"></a>2.9.2  list 类型数据操作注意事项</h4><p>（1）list中保存的数据都是string类型的，数据总容量是有限的，最多232 - 1 个元素(4294967295)。</p><p>（2）list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</p><p>（3）获取全部数据操作结束索引设置为-1</p><p>（4）list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</p><h3 id="2-10-list-应用场景"><a href="#2-10-list-应用场景" class="headerlink" title="2.10 list 应用场景"></a>2.10 list 应用场景</h3><h4 id="2-10-1-应用场景"><a href="#2-10-1-应用场景" class="headerlink" title="2.10.1  应用场景"></a>2.10.1  应用场景</h4><p>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032358660.png"></p><p>假如现在你有多台服务器，每一台服务器都会产生它的日志，假设你是一个运维人员，你想看它的操作日志，你怎么看呢？打开A机器的日志看一看，打开B机器的日志再看一看吗？这样的话你会可能会疯掉的！因为左边看的有可能它的时间是11:01，右边11:02，然后再看左边11:03，它们本身是连续的，但是你在看的时候就分成四个文件了，这个时候你看起来就会很麻烦。能不能把他们合并呢？答案是可以的！怎么做呢？建立起redis服务器。当他们需要记日志的时候，记在哪儿,全部发给redis。等到你想看的时候，通过服务器访问redis获取日志。然后得到以后，就会得到一个完整的日志信息。那么这里面就可以获取到完整的日志了，依靠什么来实现呢？就依靠我们的list的模型的顺序来实现。进来一组数据就往里加，谁先进来谁先加进去，它是有一定的顺序的。</p><h4 id="2-10-2-解决方案"><a href="#2-10-2-解决方案" class="headerlink" title="2.10.2  解决方案"></a>2.10.2  解决方案</h4><p>依赖list的数据具有顺序的特征对信息进行管理</p><p>使用队列模型解决多路信息汇总合并的问题</p><p>使用栈模型解决最新消息的问题</p><h3 id="2-11-set-基本操作"><a href="#2-11-set-基本操作" class="headerlink" title="2.11  set 基本操作"></a>2.11  set 基本操作</h3><h4 id="2-11-1-set类型"><a href="#2-11-1-set类型" class="headerlink" title="2.11.1 set类型"></a>2.11.1 set类型</h4><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032358049.png"></p><p>通过这个名称，大家也基本上能够认识到和我们Java中的set完全一样。我们现在要存储大量的数据，并且要求提高它的查询效率。用list这种链表形式，它的查询效率是不高的，那怎么办呢？这时候我们就想，有没有高效的存储机制。其实前面咱讲Java的时候说过hash表的结构就非常的好，但是这里边我们已经有hash了，他做了这么一个设定，干嘛呢，他把hash的存储空间给改一下，右边你原来存数据改掉,全部存空，那你说数据放哪儿了？放到原来的filed的位置，也就在这里边存真正的值，那么这个模型就是我们的set 模型。</p><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。</p><p>看一下它的整个结构：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032359858.png"></p><h4 id="2-11-2-set类型数据的基本操作"><a href="#2-11-2-set类型数据的基本操作" class="headerlink" title="2.11.2 set类型数据的基本操作"></a>2.11.2 set类型数据的基本操作</h4><p>添加数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure><p>获取全部数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure><p>获取集合数据总量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure><p>判断集合中是否包含指定数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><p>随机获取集合中指定数量的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure><p>随机获取集中的某个数据并将该数据移除集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [count]</span><br></pre></td></tr></table></figure><h3 id="2-12-set-类型数据的扩展操作"><a href="#2-12-set-类型数据的扩展操作" class="headerlink" title="2.12  set 类型数据的扩展操作"></a>2.12  set 类型数据的扩展操作</h3><h4 id="2-12-1-set-类型数据的扩展操作"><a href="#2-12-1-set-类型数据的扩展操作" class="headerlink" title="2.12.1  set 类型数据的扩展操作"></a>2.12.1  set 类型数据的扩展操作</h4><p>求两个集合的交、并、差集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 [key2 …]  </span><br><span class="line">sunion key1 [key2 …]  </span><br><span class="line">sdiff key1 [key2 …]</span><br></pre></td></tr></table></figure><p>求两个集合的交、并、差集并存储到指定集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key1 [key2 …]  </span><br><span class="line">sunionstore destination key1 [key2 …]  </span><br><span class="line">sdiffstore destination key1 [key2 …]</span><br></pre></td></tr></table></figure><p>将指定数据从原始集合中移动到目标集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure><p>通过下面一张图回忆一下交、并、差</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032359204.png"></p><h4 id="2-12-2-set-类型数据操作的注意事项"><a href="#2-12-2-set-类型数据操作的注意事项" class="headerlink" title="2.12.2  set 类型数据操作的注意事项"></a>2.12.2  set 类型数据操作的注意事项</h4><p>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。</p><p>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。</p><h3 id="2-13-set应用场景"><a href="#2-13-set应用场景" class="headerlink" title="2.13  set应用场景"></a>2.13  set应用场景</h3><h4 id="2-13-1-set应用场景"><a href="#2-13-1-set应用场景" class="headerlink" title="2.13.1  set应用场景"></a>2.13.1  set应用场景</h4><p>（1）黑名单</p><p>资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，  快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火 车票、机票、酒店刷票代购软件，电商刷评论、刷好评。</p><p>同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。</p><p>ps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</p><p>（2）白名单</p><p>对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证。</p><h4 id="2-13-2-解决方案"><a href="#2-13-2-解决方案" class="headerlink" title="2.13.2  解决方案"></a>2.13.2  解决方案</h4><p>基于经营战略设定问题用户发现、鉴别规则</p><p>周期性更新满足规则的用户黑名单，加入set集合</p><p>用户行为信息达到后与黑名单进行比对，确认行为去向</p><p>黑名单过滤IP地址：应用于开放游客访问权限的信息源</p><p>黑名单过滤设备信息：应用于限定访问设备的信息源</p><p>黑名单过滤用户：应用于基于访问权限的信息源</p><h3 id="2-14-实践案例"><a href="#2-14-实践案例" class="headerlink" title="2.14  实践案例"></a>2.14  实践案例</h3><h4 id="2-14-1业务场景"><a href="#2-14-1业务场景" class="headerlink" title="2.14.1业务场景"></a>2.14.1业务场景</h4><p>使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发 送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示。</p><p>我们分析一下：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208032359610.png"></p><p>100这台手机代表你。而200、300、400这三台代表你好友的手机。在这里有一些东西需要交代一下，因为我们每个人的都会对自己的微信中的一些比较重要的人设置会话置顶，将他的那条对话放在最上面。我们假定这个人有两个会话置顶的好友，分别是400和500，而这里边就包含400.</p><p>下面呢，我们就来发这个消息，第一个发消息的是300，他发了个消息给100。发完以后，这个东西应该怎么存储呢？在这里面一定要分开，记录置顶的这些人的会话，对应的会话显示顺序和非置顶的一定要分两。</p><p>这里面我们创建两个模型，一个是普通的，一个是置顶的，而上面的这个置顶的用户呢，我们用set来存储，因为不重复。而下面这些因为有顺序，很容易想到用list去存储,不然你怎么表达顺序呢？</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040000639.png"></p><p>那当300发给消息给100以后，这个时候我们先判定你在置顶人群中吗？不在,那好，300的消息对应的顺序就应该放在普通的列表里边。而在这里边，我们把300加进去。第一个数据也就是现在300。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040000003.png"></p><p>接下来400，发了个消息。判断一下，他是需要置顶的，所以400将进入list的置顶里边放着。当前还没有特殊的地方。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040001285.png"></p><p>再来200发消息了，和刚才的判定方法一样，先看在不在置顶里，不在的话进普通，然后在普通里边把200加入就行了，OK，到这里目前还没有顺序变化。</p><p>接下来200又发消息过来，同一个人给你连发了两条，那这个时候200的消息到达以后，先判断是否在置顶范围，不在，接下来他要放在list普通中，这里你要注意一点，因为这里边已经有200，所以进来以后先干一件事儿，把200杀掉，没有200，然后再把200加进来，那你想一下，现在这个位置顺序是什么呢？就是新的都在右边，对不对？</p><p>还记得我们说list模型，如果是一个双端队列，它是可以两头进两头出。当然我们双端从一头进一头出，这就是栈模型，现在咱们运用的就是list模型中的栈模型。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040001577.png"></p><p>现在300发消息，先判定他在不在，不在，用普通的队列，接下来按照刚才的操作，不管你里边原来有没有300，我先把300杀掉，没了，200自然就填到300的位置了，他现在是list里面唯一一个，然后让300进来，注意是从右侧进来的，那么现在300就是最新的。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040001364.png"></p><p>那么到这里呢，我们让100来读取消息。你觉得这个消息顺序应该是什么样的？首先置顶的400有一个，他跑在最上面，然后list普通如果出来的话，300是最新的消息，而200在他后面的。用这种形式，我们就可以做出来他的消息顺序来。</p><h4 id="2-14-2-解决方案"><a href="#2-14-2-解决方案" class="headerlink" title="2.14.2  解决方案"></a>2.14.2  解决方案</h4><p>看一下最终的解决方案：</p><p>依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用</p><p>置顶与普通会话分别创建独立的list分别管理</p><p>当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）</p><p>多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id</p><p>推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据<br>消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新</p><h4 id="2-14-3-数据类型总结"><a href="#2-14-3-数据类型总结" class="headerlink" title="2.14.3  数据类型总结"></a>2.14.3  数据类型总结</h4><p>总结一下，在整个数据类型的部分，我们主要介绍了哪些内容：</p><p>首先我们了解了一下数据类型，接下来针对着我们要学习的数据类型，进行逐一讲解了string、hash、list、set等，最后通过一个案例总结了一下前面的数据类型的使用场景。</p><h2 id="3-常用指令"><a href="#3-常用指令" class="headerlink" title="3. 常用指令"></a>3. 常用指令</h2><p>在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西:</p><h3 id="3-1-key-操作分析"><a href="#3-1-key-操作分析" class="headerlink" title="3.1  key 操作分析"></a>3.1  key 操作分析</h3><h4 id="3-1-1-key应该设计哪些操作？"><a href="#3-1-1-key应该设计哪些操作？" class="headerlink" title="3.1.1  key应该设计哪些操作？"></a>3.1.1  key应该设计哪些操作？</h4><p>key是一个字符串，通过key获取redis中保存的数据</p><p>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</p><p>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</p><p>对于key快速查询操作，例如：按指定策略查询key</p><h4 id="3-1-2-key-基本操作"><a href="#3-1-2-key-基本操作" class="headerlink" title="3.1.2  key 基本操作"></a>3.1.2  key 基本操作</h4><p>删除指定key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>获取key是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><p>获取key的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> key</span><br></pre></td></tr></table></figure><p>3.1.3  拓展操作</p><p>排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p>改名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure><h4 id="3-1-3-key-扩展操作（时效性控制）"><a href="#3-1-3-key-扩展操作（时效性控制）" class="headerlink" title="3.1.3  key 扩展操作（时效性控制）"></a>3.1.3  key 扩展操作（时效性控制）</h4><p>为指定key设置有效期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure><p>获取key的有效时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure><p>切换key从时效性转换为永久性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure><h4 id="3-1-4-key-扩展操作（查询模式）"><a href="#3-1-4-key-扩展操作（查询模式）" class="headerlink" title="3.1.4  key 扩展操作（查询模式）"></a>3.1.4  key 扩展操作（查询模式）</h4><p>查询key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p>查询模式规则</p><p>*匹配任意数量的任意符号      ?    配合一个任意符号    []    匹配一个指定符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys *  keys    查询所有</span><br><span class="line">it*  keys       查询所有以it开头</span><br><span class="line">*heima          查询所有以heima结尾</span><br><span class="line">keys ??heima    查询所有前面两个字符任意，后面以heima结尾 查询所有以</span><br><span class="line">keys user:?     user:开头，最后一个字符任意</span><br><span class="line">keys u[st]er:1  查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span><br></pre></td></tr></table></figure><h3 id="3-2-数据库指令"><a href="#3-2-数据库指令" class="headerlink" title="3.2  数据库指令"></a>3.2  数据库指令</h3><h4 id="3-2-1-key-的重复问题"><a href="#3-2-1-key-的重复问题" class="headerlink" title="3.2.1  key 的重复问题"></a>3.2.1  key 的重复问题</h4><p>在这个地方我们来讲一下数据库的常用指令，在讲这个东西之前，我们先思考一个问题：</p><p>假如说你们十个人同时操作redis，会不会出现key名字命名冲突的问题。</p><p>一定会，为什么?因为你的key是由程序而定义的。你想写什么写什么，那在使用的过程中大家都在不停的加，早晚有一天他会冲突的。</p><p>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。</p><p>那这个问题我们要不要解决？要！怎么解决呢？我们最好把数据进行一个分类，除了命名规范我们做统一以外，如果还能把它分开，这样是不是冲突的机率就会小一些了，这就是咱们下面要说的解决方案！</p><h4 id="3-2-2-解决方案"><a href="#3-2-2-解决方案" class="headerlink" title="3.2.2  解决方案"></a>3.2.2  解决方案</h4><p>redis为每个服务提供有16个数据库，编号从0到15</p><p>每个数据库之间的数据相互独立</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040002770.png"></p><p>在对应的数据库中划出一块区域，说他就是几，你就用几那块，同时，其他的这些都可以进行定义，一共是16个，这里边需要注意一点，他们这16个共用redis的内存。没有说谁大谁小，也就是说数字只是代表了一块儿区域，区域具体多大未知。这是数据库的一个分区的一个策略！</p><h4 id="3-2-3-数据库的基本操作"><a href="#3-2-3-数据库的基本操作" class="headerlink" title="3.2.3   数据库的基本操作"></a>3.2.3   数据库的基本操作</h4><p>切换数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure><p>其他操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure><h4 id="3-2-4-数据库扩展操作"><a href="#3-2-4-数据库扩展操作" class="headerlink" title="3.2.4  数据库扩展操作"></a>3.2.4  数据库扩展操作</h4><p>数据移动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><p>数据总量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure><p>数据清除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb  flushall</span><br></pre></td></tr></table></figure><h2 id="4-Jedis"><a href="#4-Jedis" class="headerlink" title="4. Jedis"></a>4. Jedis</h2><p>在学习完redis后，我们现在就要用Java来连接redis了，也就是我们的这一章要学的Jedis了。在这个部分，我们主要讲解以下3个内容：</p><p>HelloWorld（Jedis版）</p><p>Jedis简易工具类开发</p><p>可视化客户端</p><h3 id="4-1-Jedis简介"><a href="#4-1-Jedis简介" class="headerlink" title="4.1  Jedis简介"></a>4.1  Jedis简介</h3><h4 id="4-1-1-编程语言与redis"><a href="#4-1-1-编程语言与redis" class="headerlink" title="4.1.1  编程语言与redis"></a>4.1.1  编程语言与redis</h4><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040002555.png"></p><p>对于我们现在的数据来说，它是在我们的redis中，而最终我们是要做程序。那么程序就要和我们的redis进行连接。干什么事情呢？两件事：程序中有数据的时候，我们要把这些数据全部交给redis管理。同时，redis中的数据还能取出来，回到我们的应用程序中。那在这个过程中，在Java与redis之间打交道的这个东西就叫做Jedis.简单说，Jedis就是提供了Java与redis的连接服务的，里边有各种各样的API接口，你可以去调用它。</p><p>除了Jedis外，还有没有其他的这种连接服务呢？其实还有很多，了解一下：</p><p>Java语言连接redis服务 Jedis（SpringData、Redis 、 Lettuce）</p><p>其它语言：C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala</p><h4 id="4-1-2-准备工作"><a href="#4-1-2-准备工作" class="headerlink" title="4.1.2  准备工作"></a>4.1.2  准备工作</h4><p>(1)jar包导入</p><p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a></p><p>基于maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)客户端连接redis</p><p>连接redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure><p>操作redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(&quot;name&quot;, &quot;itheima&quot;);  jedis.get(&quot;name&quot;);</span><br></pre></td></tr></table></figure><p>关闭redis连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><p>API文档</p><p><a href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a></p><h4 id="4-1-3-代码实现"><a href="#4-1-3-代码实现" class="headerlink" title="4.1.3 代码实现"></a>4.1.3 代码实现</h4><p>创建：com.itheima.JedisTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.40.130&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2.执行操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;39&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = jedis.lrange(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:list1 ) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;poi&quot;</span>,<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">len</span> <span class="operator">=</span> jedis.scard(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="comment">//3.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Jedis简易工具类开发"><a href="#4-2-Jedis简易工具类开发" class="headerlink" title="4.2  Jedis简易工具类开发"></a>4.2  Jedis简易工具类开发</h3><p>前面我们做的程序还是有点儿小问题，就是我们的Jedis对象的管理是我们自己创建的，真实企业开发中是不可能让你去new一个的，那接下来咱们就要做一个工具类，简单来说，就是做一个创建Jedis的这样的一个工具。</p><h4 id="4-2-1-基于连接池获取连接"><a href="#4-2-1-基于连接池获取连接" class="headerlink" title="4.2.1  基于连接池获取连接"></a>4.2.1  基于连接池获取连接</h4><p>JedisPool：Jedis提供的连接池技术 </p><p>poolConfig:连接池配置对象 </p><p>host:redis服务地址</p><p>port:redis服务端口号</p><p>JedisPool的构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (String)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-封装连接参数"><a href="#4-2-2-封装连接参数" class="headerlink" title="4.2.2  封装连接参数"></a>4.2.2  封装连接参数</h4><p>创建jedis的配置文件：jedis.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jedis.host</span>=<span class="string">192.168.40.130  </span></span><br><span class="line"><span class="attr">jedis.port</span>=<span class="string">6379  </span></span><br><span class="line"><span class="attr">jedis.maxTotal</span>=<span class="string">50  </span></span><br><span class="line"><span class="attr">jedis.maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-加载配置信息"><a href="#4-2-3-加载配置信息" class="headerlink" title="4.2.3  加载配置信息"></a>4.2.3  加载配置信息</h4><p> 创建JedisUtils：com.itheima.util.JedisUtils，使用静态代码块初始化资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxIdel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jpc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        maxTotal = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">        maxIdel = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxIdel&quot;</span>));</span><br><span class="line">        host = bundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">        port = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line">        <span class="comment">//Jedis连接池配置</span></span><br><span class="line">        jpc = <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jpc.setMaxTotal(maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdel);</span><br><span class="line">        jp = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jpc,host,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-获取连接"><a href="#4-2-4-获取连接" class="headerlink" title="4.2.4  获取连接"></a>4.2.4  获取连接</h4><p> 对外访问接口，提供jedis连接对象，连接从连接池获取，在JedisUtils中添加一个获取jedis的方法：getJedis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line"><span class="keyword">return</span> jedis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-可视化客户端"><a href="#4-3-可视化客户端" class="headerlink" title="4.3  可视化客户端"></a>4.3  可视化客户端</h3><p>4.3.1  Redis Desktop Manager</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040003545.png"></p><h2 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5. 持久化"></a>5. 持久化</h2><p>下面呢，进入到持久化的学习.这部分内容理解的东西多，操作的东西少。在这个部分，我们将讲解四个东西：</p><p>持久化简介</p><p>RDB</p><p>AOF</p><p>RDB与AOF区别</p><h3 id="5-1-持久化简介"><a href="#5-1-持久化简介" class="headerlink" title="5.1  持久化简介"></a>5.1  持久化简介</h3><h4 id="5-1-1-场景-意外断电"><a href="#5-1-1-场景-意外断电" class="headerlink" title="5.1.1  场景-意外断电"></a>5.1.1  场景-意外断电</h4><p>不知道大家有没有遇见过，就是正工作的时候停电了，如果你用的是笔记本电脑还好，你有电池，但如果你用的是台式机呢，那恐怕就比较灾难了，假如你现在正在写一个比较重要的文档，如果你要使用的是word，这种办公自动化软件的话，他一旦遇到停电，其实你不用担心，因为它会给你生成一些其他的文件。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040003682.png"></p><p>其实他们都在做一件事儿，帮你自动恢复，有了这个文件，你前面的东西就不再丢了。那什么是自动恢复呢？你要先了解他的整个过程。</p><p>我们说自动恢复，其实基于的一个前提就是他提前把你的数据给存起来了。你平常操作的所有信息都是在内存中的，而我们真正的信息是保存在硬盘中的，内存中的信息断电以后就消失了，硬盘中的信息断电以后还可以保留下来！</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040004614.png"></p><p>我们将文件由内存中保存到硬盘中的这个过程，我们叫做数据保存，也就叫做持久化。但是把它保存下来不是你的目的，最终你还要把它再读取出来，它加载到内存中这个过程，我们叫做数据恢复，这就是我们所说的word为什么断电以后还能够给你保留文件，因为它执行了一个自动备份的过程，也就是通过自动的形式，把你的数据存储起来，那么有了这种形式以后，我们的数据就可以由内存到硬盘上实现保存。</p><h4 id="5-1-2-什么是持久化"><a href="#5-1-2-什么是持久化" class="headerlink" title="5.1.2  什么是持久化"></a>5.1.2  什么是持久化</h4><p>(1)什么是持久化</p><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 。</p><p>持久化用于防止数据的意外丢失，确保数据安全性。</p><p>(2)持久化过程保存什么？</p><p>我们知道一点，计算机中的数据全部都是二进制，如果现在我要你给我保存一组数据的话，你有什么样的方式呢，其实最简单的就是现在长什么样，我就记下来就行了，那么这种是记录纯粹的数据，也叫做快照存储，也就是它保存的是某一时刻的数据状态。</p><p>还有一种形式，它不记录你的数据，它记录你所有的操作过程，比如说大家用idea的时候，有没有遇到过写错了ctrl+z撤销，然后ctrl+y还能恢复，这个地方它也是在记录，但是记录的是你所有的操作过程，那我想问一下，操作过程，我都给你留下来了，你说数据还会丢吗？肯定不会丢，因为你所有的操作过程我都保存了。这种保存操作过程的存储，用专业术语来说可以说是日志，这是两种不同的保存数据的形式啊。</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040004627.png"></p><p>总结一下：</p><p>第一种：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。</p><p>第二种：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。</p><h3 id="5-2-RDB"><a href="#5-2-RDB" class="headerlink" title="5.2  RDB"></a>5.2  RDB</h3><h4 id="5-2-1-save指令"><a href="#5-2-1-save指令" class="headerlink" title="5.2.1  save指令"></a>5.2.1  save指令</h4><p>手动执行一次保存操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><p><strong>save指令相关配置</strong></p><p>设置本地数据库文件名，默认值为 dump.rdb，通常设置为dump-端口号.rdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename filename</span><br></pre></td></tr></table></figure><p>设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir path</span><br></pre></td></tr></table></figure><p>设置存储至本地数据库时是否压缩数据，默认yes，设置为no，节省 CPU 运行时间，但存储文件变大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes|no</span><br></pre></td></tr></table></figure><p>设置读写文件过程是否进行RDB格式校验，默认yes，设置为no，节约读写10%时间消耗，单存在数据损坏的风险</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbchecksum yes|no</span><br></pre></td></tr></table></figure><p><strong>save指令工作原理</strong></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040004782.png"></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040005022.png"></p><p>需要注意一个问题，来看一下，现在有四个客户端各自要执行一个指令，把这些指令发送到redis服务器后，他们执行有一个先后顺序问题，假定就是按照1234的顺序放过去的话，那会是什么样的？</p><p>记得redis是个单线程的工作模式，它会创建一个任务队列，所有的命令都会进到这个队列里边，在这儿排队执行，执行完一个消失一个，当所有的命令都执行完了，OK，结果达到了。</p><p>但是如果现在我们执行的时候save指令保存的数据量很大会是什么现象呢？</p><p>他会非常耗时，以至于影响到它在执行的时候，后面的指令都要等，所以说这种模式是不友好的，这是save指令对应的一个问题，当cpu执行的时候会阻塞redis服务器，直到他执行完毕，所以说我们不建议大家在线上环境用save指令。</p><h4 id="5-2-2-bgsave指令"><a href="#5-2-2-bgsave指令" class="headerlink" title="5.2.2  bgsave指令"></a>5.2.2  bgsave指令</h4><p>之前我们讲到了当save指令的数据量过大时，单线程执行方式造成效率过低，那应该如何处理？</p><p>此时我们可以使用：<strong>bgsave</strong>指令，bg其实是background的意思，后台执行的意思</p><p>手动启动后台保存操作，但不是立即执行</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bgsave</span></span><br></pre></td></tr></table></figure><p><strong>bgsave指令相关配置</strong></p><p>后台存储过程中如果出现错误现象，是否停止保存操作，默认yes</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop-writes-on-bgsave-error</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure><p>其 他</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dbfilename</span> <span class="string">filename  </span></span><br><span class="line"><span class="attr">dir</span> <span class="string">path  </span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes|no  </span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure><p><strong>bgsave指令工作原理</strong></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040005685.png"></p><p>当执行bgsave的时候，客户端发出bgsave指令给到redis服务器。注意，这个时候服务器马上回一个结果告诉客户端后台已经开始了，与此同时它会创建一个子进程，使用Linux的fork函数创建一个子进程，让这个子进程去执行save相关的操作，此时我们可以想一下，我们主进程一直在处理指令，而子进程在执行后台的保存，它会不会干扰到主进程的执行吗？</p><p>答案是不会，所以说他才是主流方案。子进程开始执行之后，它就会创建啊RDB文件把它存起来，操作完以后他会把这个结果返回，也就是说bgsave的过程分成两个过程，第一个是服务端拿到指令直接告诉客户端开始执行了；另外一个过程是一个子进程在完成后台的保存操作，操作完以后回一个消息。</p><h4 id="5-2-3-save配置自动执行"><a href="#5-2-3-save配置自动执行" class="headerlink" title="5.2.3 save配置自动执行"></a>5.2.3 save配置自动执行</h4><p>设置自动持久化的条件，满足限定时间范围内key的变化数量达到指定数量即进行持久化</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">save</span> <span class="string">second changes</span></span><br></pre></td></tr></table></figure><p>参数</p><p>second：监控时间范围</p><p>changes：监控key的变化量</p><p>范例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>其他相关配置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbfilename filename</span><br><span class="line">dir path</span><br><span class="line">rdbcompression yes|no</span><br><span class="line">rdbchecksum yes|no</span><br><span class="line">stop-writes-on-bgsave-error yes|no</span><br></pre></td></tr></table></figure><p><strong>save配置工作原理</strong></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040005513.png"></p><h4 id="5-2-4-RDB三种启动方式对比"><a href="#5-2-4-RDB三种启动方式对比" class="headerlink" title="5.2.4 RDB三种启动方式对比"></a>5.2.4 RDB三种启动方式对比</h4><table><thead><tr><th>方式</th><th>save指令</th><th>bgsave指令</th></tr></thead><tbody><tr><td>读写</td><td>同步</td><td>异步</td></tr><tr><td>阻塞客户端指令</td><td>是</td><td>否</td></tr><tr><td>额外内存消耗</td><td>否</td><td>是</td></tr><tr><td>启动新进程</td><td>否</td><td>是</td></tr></tbody></table><p><strong>RDB特殊启动形式</strong></p><p>服务器运行过程中重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure><p>关闭服务器时指定保存数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure><p>全量复制（在主从复制中详细讲解）</p><p><strong>RDB优点：</strong></p><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li><li>RDB恢复数据的速度要比AOF快很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul><p><strong>RDB缺点</strong></p><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li></ul><h3 id="5-3-AOF"><a href="#5-3-AOF" class="headerlink" title="5.3  AOF"></a>5.3  AOF</h3><p>为什么要有AOF,这得从RDB的存储的弊端说起：</p><ul><li>存储数据量较大，效率较低，基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul><p>那解决的思路是什么呢？</p><ul><li>不写全数据，仅记录部分数据</li><li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li><li>对所有操作均进行记录，排除丢失数据的风险</li></ul><h4 id="5-3-1-AOF概念"><a href="#5-3-1-AOF概念" class="headerlink" title="5.3.1 AOF概念"></a>5.3.1 AOF概念</h4><p><strong>AOF</strong>(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。<strong>与RDB相比可以简单理解为由记录数据改为记录数据产生的变化</strong></p><p>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p><p><strong>AOF写数据过程</strong></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040006065.png"></p><p><strong>启动AOF相关配置</strong></p><p>开启AOF持久化功能，默认no，即不开启状态</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">appendonly</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure><p>AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">appendfilename</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure><p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dir</span></span><br></pre></td></tr></table></figure><p>AOF写数据策略，默认为everysec</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">appendfsync</span> <span class="string">always|everysec|no</span></span><br></pre></td></tr></table></figure><h4 id="5-3-2-AOF执行策略"><a href="#5-3-2-AOF执行策略" class="headerlink" title="5.3.2 AOF执行策略"></a>5.3.2 AOF执行策略</h4><p>AOF写数据三种策略(appendfsync)</p><ul><li><strong>always</strong>(每次）：每次写入操作均同步到AOF文件中数据零误差，性能较低，不建议使用。</li></ul><ul><li><strong>everysec</strong>（每秒）：每秒将缓冲区中的指令同步到AOF文件中，在系统突然宕机的情况下丢失1秒内的数据 数据准确性较高，性能较高，建议使用，也是默认配置</li></ul><ul><li><strong>no</strong>（系统控制）：由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li></ul><h4 id="5-3-3-AOF重写"><a href="#5-3-3-AOF重写" class="headerlink" title="5.3.3 AOF重写"></a>5.3.3 AOF重写</h4><p>场景：AOF写数据遇到的问题，如果连续执行如下指令该如何处理</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040006782.png"></p><p><strong>什么叫AOF重写？</strong></p><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录。</p><p><strong>AOF重写作用</strong></p><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><p><strong>AOF重写规则</strong></p><ul><li>进程内具有时效性的数据，并且数据已超时将不再写入文件</li></ul><ul><li><p>非写入类的无效指令将被忽略，只保留最终数据的写入命令</p><p>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</p><p>如select指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录</p></li><li><p>对同一数据的多条写命令合并为一条命令</p></li></ul><p>如lpushlist1 a、lpush list1 b、lpush list1 c可以转化为：lpush list1 a b c。</p><p>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</p><p><strong>AOF重写方式</strong></p><ul><li>手动重写</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bgrewriteaof</span></span><br></pre></td></tr></table></figure><p><strong>手动重写原理分析：</strong></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040006229.png"></p><ul><li>自动重写</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">size</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">percentage</span></span><br></pre></td></tr></table></figure><p>自动重写触发条件设置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">size</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">percent</span></span><br></pre></td></tr></table></figure><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aof_current_size</span>  <span class="string"></span></span><br><span class="line"><span class="attr">aof_base_size</span></span><br></pre></td></tr></table></figure><p> 自动重写触发条件公式：</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007155.png"></p><h4 id="5-3-4-AOF工作流程及重写流程"><a href="#5-3-4-AOF工作流程及重写流程" class="headerlink" title="5.3.4 AOF工作流程及重写流程"></a>5.3.4 AOF工作流程及重写流程</h4><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007616.png"></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007514.png"></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202208040007420.png"></p><h3 id="5-4-RDB与AOF区别"><a href="#5-4-RDB与AOF区别" class="headerlink" title="5.4  RDB与AOF区别"></a>5.4  RDB与AOF区别</h3><h4 id="5-4-1-RDB与AOF对比（优缺点）"><a href="#5-4-1-RDB与AOF对比（优缺点）" class="headerlink" title="5.4.1 RDB与AOF对比（优缺点）"></a>5.4.1 RDB与AOF对比（优缺点）</h4><table><thead><tr><th>持久化方式</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级：压缩）</td><td>大（指令级：重写）</td></tr><tr><td>存储速度</td><td>慢</td><td>快</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>会丢失数据</td><td>依据策略决定</td></tr><tr><td>资源消耗</td><td>高/重量级</td><td>低/轻量级</td></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr></tbody></table><h4 id="5-4-2-RDB与AOF应用场景"><a href="#5-4-2-RDB与AOF应用场景" class="headerlink" title="5.4.2 RDB与AOF应用场景"></a>5.4.2 RDB与AOF应用场景</h4><p>RDB与AOF的选择之惑</p><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案</li></ul><p>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。</p><p>注意：由于AOF文件存储体积较大，且恢复速度较慢</p><ul><li>数据呈现阶段有效性，建议使用RDB持久化方案</li></ul><p>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案</p><p>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</p><p><strong>综合比对</strong></p><ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启 RDB和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习</title>
      <link href="/2022/03/01/go/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/01/go/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>Project项目名，-》src目录 -》go_code -&gt;&gt; 模块1，模块2 -&gt;&gt; main文件夹和其他文件夹</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212134868.png" alt="image-20220217214708424"></p><p><img src="media/16946123129615.jpg"></p><p>在对应的go文件目录下用cmd窗口打开，并运行 go build hello.go就会生成可执行文件hello.exe</p><p>==还可以通过 go build -o aaa/myhello.exe hello.go 指定生成的exe文件所在的目录==</p><p>==go build -o ../package/myhello.exe hello.go  回退上一级的package目录生成==</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135198.png" alt="image-20220217215651703"></p><h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><ol><li><p>使用shift+tab 和tab 或者 使用命令 gofmt  -w  文件名.go</p></li><li><p>运算符两边习惯各加一个空格</p></li><li><p>注意保持package包名和所在的外面文件夹的名字一样。除了package main</p></li><li><p>变量名、函数名、常量名 采用驼峰法，且首字母大写则可以被其他包访问；首字母小谢则只能在本包中使用，（可以理解成首字母大写是公开的，首字母小写是私有的，在golang里没有public，private等关键字）</p></li><li><p>Go 的源文件以 .go 为后缀名存储在计算机中，这些文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 scanner_test.go 。文件名不包含空格或其他特殊字符。</p></li><li><p>在习惯上，Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名</p></li><li><p>导入其他包时，注意import完整的路径按理说应该是 D:/Project/src/go_code/project1/module1 类似这种的，但是因为设置了gopath所以前面D:/Project是可以不用写的，然后src又是默认的，因此</p><p>import  “go_code/project1/module1” 这样写就行</p></li></ol><h2 id="IDE报错"><a href="#IDE报错" class="headerlink" title="IDE报错"></a>IDE报错</h2><h3 id="command-line-arguments-undefined"><a href="#command-line-arguments-undefined" class="headerlink" title="command-line-arguments undefined:"></a>command-line-arguments undefined:</h3><p>问题是使用goland开发。同一个包下两个或多个go文件，包名为main，点击其中一个文件的main()方法运行另一个文件的方法时报错，</p><p>解决办法是在goland中ctrl两个文件一起然后右键build运行</p><p>#go mod依赖管理</p><h2 id="传统模式建项目"><a href="#传统模式建项目" class="headerlink" title="传统模式建项目"></a>传统模式建项目</h2><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135392.png" alt="image-20220228122245833"></p><p>注意项目要放在gopath目录下的src目录下，注意要把go111module设为off</p><p>##go mod方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init</span><br><span class="line"><span class="keyword">go</span> mod download</span><br><span class="line"><span class="keyword">go</span> mod tidy <span class="comment">//更新</span></span><br><span class="line"></span><br><span class="line">运行<span class="keyword">go</span> get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</span><br><span class="line"></span><br><span class="line">GOPROXY=https:<span class="comment">//mirrors.aliyun.com,direct.</span></span><br></pre></td></tr></table></figure><p>运行的</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135915.png" alt="image-20220221190349551"></p><p>这样最后下载的包会自动放在gopath目录下的与src同级的pkg目录（自动生成） ==因为设置了本项目的GOpath==</p><p>如果不设置这个的话gomod下载的依赖会自动放在全局GOPATH的pkg目录下</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135793.png" alt="image-20220227143912789"></p><p>为整个GOPATH编制索引得加上==会将当前项目作为GOPATH 这个是推荐的。这样各个项目彼此独立不会存在谁污染谁的问题。   暂时不知道啥用，加上和不加上好像没区别==，</p><p>点击爆红的import alt+enter可以让你在代码中同步依赖然后就能自动拉取已经在本地pkg中的包</p><p>GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135018.png" alt="image-20220221190415461"></p><p>然后控制端用go mod tidy就行</p><h2 id="实现导入自己的包"><a href="#实现导入自己的包" class="headerlink" title="实现导入自己的包"></a>实现导入自己的包</h2><p>#github和git的操作</p><ol><li><p>ctrl+shift+A 窗口搜索 克隆 ， 然后克隆项目</p></li><li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135880.png" alt="image-20220221000947454"></p></li><li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135902.png" alt="image-20220221001100085"></p></li><li><p>alt+9查看历史提交</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135692.png" alt="image-20220221001631443"></p></li></ol><p><strong>goland操作</strong></p><ol><li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135065.png" alt="image-20220221175447112">按ctrl+i快速实现一个接口，会自动创建结构体和该结构体实现了这个接口</p></li><li><p>按F2直接跳到警告部分代码，对数字和字符串按个.直接能解析</p></li><li><p>ctrl+w</p></li></ol><p>#go的标准库</p><blockquote><p><a href="http://word.topgoer.com/">http://word.topgoer.com/</a> 查看标准库</p></blockquote><p>###strings</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">strings.EqualFold(<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;go&quot;</span>)<span class="comment">//判断是否忽略大小写相等 结果true</span></span><br><span class="line"></span><br><span class="line">strings.HasPrefix(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;你&quot;</span>)<span class="comment">//判断是否有前缀，结果true</span></span><br><span class="line"></span><br><span class="line">strings.HasSuffix(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;好&quot;</span>)<span class="comment">//判断后缀，结果true</span></span><br><span class="line"></span><br><span class="line">strings.Contains(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&quot;好&quot;</span>)<span class="comment">//结果true</span></span><br><span class="line"></span><br><span class="line">strings.ContainsRune(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&#x27;好&#x27;</span>)<span class="comment">//判断字符串s是否包含utf-8码值r。结果true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func ContainsAny(s, chars string) bool  </span></span><br><span class="line"><span class="comment">//判断字符串s是否包含字符串chars中的任一字符。</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;team&quot;</span>, <span class="string">&quot;i&quot;</span>)<span class="comment">//false</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;failure&quot;</span>, <span class="string">&quot;u &amp; i&quot;</span>)<span class="comment">//true</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="comment">//false</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">strings.Count(<span class="string">&quot;你我我好我我&quot;</span>,<span class="string">&quot;我我&quot;</span>)<span class="comment">//返回字符串s中有几个不重复的sep子串。返回2</span></span><br><span class="line"></span><br><span class="line">strings.Index(<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;ken&quot;</span>)<span class="comment">//返回4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="type">string</span>, c <span class="type">byte</span>)</span></span> <span class="type">int</span><span class="comment">//字符c在s中第一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="type">string</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span><span class="comment">//unicode码值r在s中第一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span>   <span class="comment">//字符串chars中的任一utf-8码值在s中第一次出现的位置，如果不存在或者chars为空字符串则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep <span class="type">string</span>)</span></span> <span class="type">int</span>  <span class="comment">//子串sep在字符串s中最后一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span>  <span class="comment">//字符串chars中的任一utf-8码值在s中最后一次出现的位置，如不存在或者chars为空字符串则返回-1。</span></span><br><span class="line">strings.LastIndexAny(<span class="string">&quot;你好呀啊&quot;</span>,<span class="string">&quot;d啊 你&quot;</span>)<span class="comment">//返回9.因为一个汉字占三个字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回s中每个单词的首字母都改为标题格式的字符串拷贝。<span class="doctag">BUG:</span> Title用于划分单词的规则不能很好的处理Unicode标点符号。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回将所有字母都转为对应的小写版本的拷贝。不会改变s的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将所有字母都转为对应的大写版本的拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="type">string</span>, count <span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">//返回count个s串联的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%q]&quot;</span>, strings.Trim(<span class="string">&quot; !!! Achtung! Achtung! !!! &quot;</span>, <span class="string">&quot;! &quot;</span>))</span><br><span class="line">Output:</span><br><span class="line">[<span class="string">&quot;Achtung! Achtung&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前后端所有空白（unicode.IsSpace指定）都去掉的字符串。</span></span><br><span class="line">fmt.Println(strings.TrimSpace(<span class="string">&quot; \t\n a lone gopher \n\t\r\n&quot;</span>))</span><br><span class="line">Output:</span><br><span class="line">a lone gopher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回去除s可能的前缀prefix的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回将s后端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回去除s可能的后缀suffix的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span><span class="comment">//返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。</span></span><br><span class="line"></span><br><span class="line">strings.Split(<span class="string">&quot;a,b,c&quot;</span>,<span class="string">&quot;,&quot;</span>)<span class="comment">//返回值是一个字符串数组元素是abc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//将一系列字符串连接为一个字符串，之间用sep来分隔。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>###time</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time.Now().Year()<span class="comment">//获取当前年</span></span><br><span class="line">time.Now().Month()<span class="comment">//获取当前年</span></span><br><span class="line">time.Now().Unix()<span class="comment">//返回从1970到现在的秒值</span></span><br><span class="line">time.Now().UnixNano <span class="comment">//返回从1970到现在的纳秒值</span></span><br><span class="line"></span><br><span class="line">elapsed := time.Since(start)<span class="comment">//可以获得从start秒开始到现在的毫秒值</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s))) <span class="comment">//逆序排</span></span><br></pre></td></tr></table></figure><h1 id="golang变量"><a href="#golang变量" class="headerlink" title="golang变量"></a>golang变量</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol><li><p>``` go<br>var i int //i此时是默认值0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` go</span><br><span class="line">   var i = 10.11 //根据值自行判断变量类型 （类型推导）</span><br></pre></td></tr></table></figure></li><li><p>``` go<br>i := “tom” //省略var，注意 := 左侧的变量不应该是已经声明过的，否则会编译错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ``` go</span><br><span class="line">   var n1 , n2 , n3 int //一次声明多个变量</span><br><span class="line">   var n1 , n2 , n2 = 100 , &quot;tom&quot; , 888</span><br><span class="line">   n1 , name , n3 := 100 , &quot;tom&quot; , 888</span><br></pre></td></tr></table></figure></li><li><p>一次性声明多个全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">n3 = <span class="number">300</span></span><br><span class="line">    n4 = <span class="number">900</span></span><br><span class="line">    n5 = <span class="string">&quot;mary&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li>基本数据类型<ol><li>数值型<ol><li>整数类型（int,int8,int16,int32,int64,uint,uint8,uint16,uint64,byte）</li><li>浮点类型 (float32 , float64)</li></ol></li><li>布尔型 （bool）</li><li>字符串（string）</li></ol></li><li>派生复杂数据类型<ol><li>指针</li><li>数组</li><li>结构体 (struct)</li><li>管道（Channel）</li><li>函数</li><li>切片 （slice）</li><li>接口 （interface）</li><li>map</li></ol></li></ol><p>###整数类型</p><p>注意rune与int32一样范围，表示一个Unicode码</p><p>byte用于表示字符，</p><p>int uint的大小与系统有关</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 = <span class="number">100</span> <span class="comment">//n1默认是int型</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//unsafe.Sizeof(n1) 是unsafe包的一个函数，可以返回n1变量占用的字节数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2 的 类型 %T  n2占用的字节数是 %d &quot;</span>, n2, unsafe.Sizeof(n2))</span><br></pre></td></tr></table></figure><p>###浮点类型</p><blockquote><p>注意的是</p><p>golang的浮点型默认声明为float64</p><p>var n = 1.12 // n此时是float64的</p></blockquote><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示golang中字符类型使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1 <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">var</span> c2 <span class="type">byte</span> = <span class="string">&#x27;0&#x27;</span> <span class="comment">//字符的0</span></span><br><span class="line">   <span class="comment">//当我们直接输出byte值，就是输出了的对应的字符的码值</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c1=&quot;</span>, c1)<span class="comment">//c1= 97</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c2=&quot;</span>, c2)<span class="comment">//c2= 48</span></span><br><span class="line">   <span class="comment">//如果我们希望输出对应字符，需要使用格式化输出</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c1=%c c2=%c\n&quot;</span>, c1, c2)<span class="comment">//c1=a c2=0</span></span><br><span class="line">   <span class="comment">//var c3 byte = &#x27;北&#x27; //overflow溢出</span></span><br><span class="line">   <span class="keyword">var</span> c3 <span class="type">int</span> = <span class="string">&#x27;北&#x27;</span> </span><br><span class="line">   fmt.Printf(<span class="string">&quot;c3=%c c3对应码值=%d\n&quot;</span>, c3, c3)<span class="comment">//c3=北 c3对应码值=21271</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//可以直接给某个变量赋一个数字，然后按格式化输出时%c，会输出该数字对应的unicode 字符</span></span><br><span class="line">   <span class="keyword">var</span> c4 <span class="type">int</span> = <span class="number">22269</span> <span class="comment">// 22269 -&gt; &#x27;国&#x27; </span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c4=%c\n&quot;</span>, c4)<span class="comment">//c4=国</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//字符类型是可以进行运算的，相当于一个整数,运输时是按照码值运行</span></span><br><span class="line">   <span class="keyword">var</span> n1 = <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">//  10 + 97 = 107</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1)<span class="comment">//n1= 107</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ch = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ch的类似是%t,占用的字节是%d&quot;</span>,ch,unsafe.Sizeof(ch))<span class="comment">//ch的类似是%!t(int32=97),占用的字节是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go的字符串是由单个字节连接起来的。字节使用UTF-8编码识别Unicode文本，因此没有中文乱码问题</p><p>字符串一旦赋值，不能修改</p><p>可以用反引号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串遍历方式1-传统方式,注意这种方式对str2可以修改，但对str不能修改也就是说我们可以用str2[1]=&#x27;d&#x27;来修改值把‘北’改成‘d’</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;a北京&quot;</span></span><br><span class="line">str2 := []<span class="type">rune</span>(str) <span class="comment">// 就是把 str 转成 []rune</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index = %d , %c \n&quot;</span>, i,str2[i]) <span class="comment">//使用到下标...</span></span><br><span class="line">        <span class="comment">//输出是index = 0 , a index = 1 , 北 ，index = 2 , 京 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串遍历方式2-for-range</span></span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index=%d, val=%c \n&quot;</span>, index, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//index=0, val=a </span></span><br><span class="line"><span class="comment">//index=1, val=北 </span></span><br><span class="line"><span class="comment">//index=4, val=京 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>string底层是一个byte数组，如果需要修改字符串可以先将string转为[]byte 或者[]rune</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 := []<span class="type">rune</span>(str)</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">str = <span class="type">string</span>(arr1)</span><br></pre></td></tr></table></figure><hr><p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p><p><u><i>gopl.io/ch3/printints</i></u></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intsToString is like fmt.Sprint(values) but adds commas.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(intsToString([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)) <span class="comment">// &quot;[1, 2, 3]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似’[‘和’]’等ASCII字符则会更加有效。</p><p>bytes.Buffer类型有着很多实用的功能，我们在第七章讨论接口时将会涉及到，我们将看看如何将它用作一个I/O的输入和输出对象，例如当做Fprintf的io.Writer输出对象，或者当作io.Reader类型的输入源对象。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>###数组</p><ol><li><p>```go<br>var num [3]int = [3]int{1,2,3}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   var num = [3]int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></li><li><p>```go<br>var num = […]int{1,2,3}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   var num = [...]int&#123;1:800, 0:900, 2:999&#125;</span><br></pre></td></tr></table></figure></li><li><p>```go<br>num := […]string{1:”tom”, 0:”jack”, 2:”mary”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**数组的遍历方式**</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">for index,value := range array01&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>二维数组</strong></p><ol><li><p>```go<br>var arr [2][3]int //先声明再赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` go</span><br><span class="line">   var arr [2][3]int = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   var arr [2][3]int = [...][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   var arr = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   arr  := [...][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历方式</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(arr) ; i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr[i]); j++&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;%v\t&quot;</span>,arr[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span>(arr)&#123;</span><br><span class="line"><span class="keyword">for</span> j , v2 := <span class="keyword">range</span>(v)&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr[%v][%v] = %v&quot;</span>,i,j,v2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###切片</p><p><strong>语法</strong></p><ol><li><p>```go<br>var arr [5]int = […]{1,22,33,65,99}<br>slice := arr[1:3]//得先有数组，然后让切片去引用一个已经创建好的数组<br>//注意这里引用的是1 2下标 。然后对slice和arr的里的元素的修改会互相影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   var slice []float64 = make([]float64,5,10)//make方式创建cap容量是10，len长度是5的切片，切片内各个元素使用默认值，</span><br><span class="line">   var slice = make([]float64,5,10)</span><br><span class="line">   slice := make([]float64,5,10)</span><br><span class="line">   //通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素</span><br></pre></td></tr></table></figure></li><li><p>```go<br>var strSlice []string = []string{“tom”,”jack”,”mary”}<br>var strSlice  = []string{“tom”,”jack”,”mary”}<br>strSlice ：= []string{“tom”,”jack”,”mary”}<br>//方式3，定义一个切片，直接就指定具体数组，使用原理类似make的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过append（）来扩容</span><br><span class="line"></span><br><span class="line">1. 切片append操作的本质就是对数组扩容，go底层会创建一个新的数组newArr（安装扩容后大小），将slice原来包含的元素拷贝到新的数组newArr中，slice重新引用到newArr，注意newArr是在底层来维护的，程序员不可见，</span><br><span class="line">2. 因此append后两个数组的操作就独立开来了</span><br><span class="line">3. 切片之间的赋值需要通过copy函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ap的声</span><br><span class="line"></span><br><span class="line">### map</span><br><span class="line"></span><br><span class="line">当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</span><br><span class="line"></span><br><span class="line">map的声明</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">var mp map[string]string//注意声明不会分配内存，初始化需要make，分配内存后才能赋值和使用</span><br></pre></td></tr></table></figure></li></ol><p><strong>具体使用</strong></p><ol><li><p>```go<br>var a map[string]string = make(map[string]string,10)<br>b := make(map[string]string)<br>c := map[string]string{“stu1”:”陈某”,”stu2”:”黄某”}</p><p>var m = map[string]Vertex{</p><pre><code>&quot;Bell Labs&quot;: Vertex&#123;    40.68433, -74.39967,&#125;,&quot;Google&quot;: Vertex&#123;    37.42202, -122.08408,&#125;,</code></pre><p>}<br>//若顶级类型只是一个类型名，你可以在文法的元素中省略它。<br>var m = map[string]Vertex{</p><pre><code>&quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,&quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. 增删改查</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   city := make(map[string]string)</span><br><span class="line">   city[&quot;no1&quot;] = &quot;北京&quot;   //增加</span><br><span class="line">   city[&quot;no1&quot;] = &quot;深圳&quot;   //修改</span><br><span class="line">   delete(city,&quot;no1&quot;)//删除</span><br><span class="line">   </span><br><span class="line">   val , ok := city[&quot;no2&quot;]</span><br><span class="line">   if ok&#123;</span><br><span class="line">       fmt.Printf(&quot;有no1 key 值为%v \n&quot;,val) //查找</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       fmt.Printf(&quot;没有no1 key\n&quot;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>map的遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">city[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> city&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;k = %v  v = %v&quot;</span>,k,v)</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------</span><br><span class="line">capitals := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;France&quot;</span>: <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;Italy&quot;</span>: <span class="string">&quot;Rome&quot;</span>, <span class="string">&quot;Japan&quot;</span>: <span class="string">&quot;Tokyo&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> capitals &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Map item: Capital of&quot;</span>, key, <span class="string">&quot;is&quot;</span>, capitals[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>###map切片</p><p>切片的数据类型如果是map,则我们成为slice of map，map切片，这样使用则map个数可以动态变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素（参见下面的例子 8.4）。</span></span><br><span class="line">sm := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) </span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">s := []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;n1&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n2&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;n3&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n4&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面代码很重要，要注意</p><p><strong>应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> items &#123; <span class="comment">//i是切片的索引下标</span></span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version A: Value of items: %v\n&quot;</span>, items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">    items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">        item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">        item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This &#x27;item&#x27; will be lost on the next iteration.</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Version A: Value of items: [<span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>]]</span><br><span class="line">Version B: Value of items: [<span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>###sync.Map</p><p>Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">m.Store(key, n)</span><br><span class="line">value, _ := m.Load(key)</span><br><span class="line">fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###map排序</p><ol><li>先将map的key的顺序进行排序输出</li><li>对切片排序</li><li>遍历切片，然后按照key来输出map的值</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> k,_ := <span class="keyword">range</span> map1&#123;</span><br><span class="line">    keys = appen(keys,k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(keys)</span><br><span class="line"><span class="keyword">for</span> _,k := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;map1[%v] = %v \n&quot;</span> , k , map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意结构体没有给字段赋值，那么就用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面介绍创建结构体s的方式</span></span><br><span class="line"><span class="keyword">type</span> s <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 s <span class="comment">//此时用默认值</span></span><br><span class="line">s2 := s&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s4 *s = <span class="built_in">new</span>(s)</span><br><span class="line"><span class="keyword">var</span> s5 *s = &amp;s&#123;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s6 = &amp;s&#123;</span><br><span class="line">    name : <span class="string">&quot;小李&quot;</span></span><br><span class="line">    age : <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Price <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TV <span class="keyword">struct</span> &#123; <span class="comment">//这个也叫多重继承</span></span><br><span class="line">Goods   </span><br><span class="line">Brand</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV2 <span class="keyword">struct</span> &#123;</span><br><span class="line">*Goods</span><br><span class="line">*Brand</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值</span></span><br><span class="line">tv := TV&#123; Goods&#123;<span class="string">&quot;电视机001&quot;</span>, <span class="number">5000.99</span>&#125;,  Brand&#123;<span class="string">&quot;海尔&quot;</span>, <span class="string">&quot;山东&quot;</span>&#125;, &#125;</span><br><span class="line"></span><br><span class="line">tv4 := TV2&#123; </span><br><span class="line">&amp;Goods&#123;</span><br><span class="line">Name : <span class="string">&quot;电视机004&quot;</span>, </span><br><span class="line">Price : <span class="number">9000.99</span>,</span><br><span class="line">&#125;,  </span><br><span class="line">&amp;Brand&#123;</span><br><span class="line">Name : <span class="string">&quot;长虹&quot;</span>, </span><br><span class="line">Address : <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">&#125;, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意访问要这样写</span></span><br><span class="line">fmt.Println(<span class="string">&quot;tv4&quot;</span>, *tv4.Goods, *tv4.Brand)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>###接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stu)</span></span> Say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Say()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu Stu = Stu&#123;&#125;</span><br><span class="line"><span class="comment">// var u Usb = stu这样写会错误！ 会报 Stu类型没有实现Usb接口 ,</span></span><br><span class="line"><span class="comment">// 如果希望通过编译,  var u Usb = &amp;stu</span></span><br><span class="line"><span class="keyword">var</span> u Usb = &amp;stu</span><br><span class="line">u.Say()</span><br></pre></td></tr></table></figure><p>####值接收和指针接收</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Move() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Dog value run...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover    <span class="comment">// 声明一个Mover类型的变量x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = Dog&#123;&#125; <span class="comment">// d1是Dog类型</span></span><br><span class="line">x = d1         <span class="comment">// 可以将d1赋值给变量x</span></span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; <span class="comment">// d2是Dog指针类型</span></span><br><span class="line">x = d2          <span class="comment">// 也可以将d2赋值给变量x</span></span><br><span class="line">x.Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p><p>==但是注意下面的情况==</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (d Dog) Move() &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Dog value run...&quot;)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> Move() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Dog Point run...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Mover </span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d1 = Dog&#123;&#125; </span><br><span class="line">   x = d1         <span class="comment">// 这里会编译错误</span></span><br><span class="line">   x.Move()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; </span><br><span class="line">   x = d2          </span><br><span class="line">   x.Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>####接口的底层结构</p><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212136842.png" alt="image-20220226114637512"></p><h3 id="自定义数据类型type"><a href="#自定义数据类型type" class="headerlink" title="自定义数据类型type"></a>自定义数据类型type</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span> <span class="comment">//这时myInt就等价int来使用了</span></span><br><span class="line"><span class="keyword">type</span> mySum <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span><span class="comment">//这时mySum就等价一个函数类型</span></span><br></pre></td></tr></table></figure><h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>注意类型转化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int8</span> = <span class="type">int8</span>(num1) <span class="comment">//可以看成函数那样，并不会改变num1的结果和类型，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int32</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int</span> <span class="number">64</span></span><br><span class="line">n2 = n1 + <span class="number">20</span> <span class="comment">//int32的n1不能这样相加转int64的n2。必须强转 int64(n1) + 20</span></span><br></pre></td></tr></table></figure><p>##类型断言</p><p>​    为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><p>​    若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。  </p><p>​    否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。  </p><p>​    请注意这种语法和读取一个映射时的相同之处。  </p><hr><p>​    <strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。  </p><p>​    类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值），     它们针对给定接口值所存储的值的类型进行比较。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。  </p><p>​    此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。  </p><h3 id="字符串和数字类型的转换"><a href="#字符串和数字类型的转换" class="headerlink" title="字符串和数字类型的转换"></a>字符串和数字类型的转换</h3><p>==<strong>strconv包下</strong>==</p><blockquote><h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><blockquote><h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p>ParseBool() 函数用于将字符串转换为 bool 类型的值，它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误，函数签名如下。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><blockquote><p>ParseInt() 函数用于返回字符串表示的整数值（可以包含正负号），参数说明：</p><ul><li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。</li><li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li><li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><blockquote><h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p>ParseFloat() 函数用于将一个表示浮点数的字符串转换为 float 类型，参数说明：</p><ul><li>如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。</li><li>bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64；</li><li>返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p>FormatBool() 函数可以一个 bool 类型的值转换为对应的字符串类型，函数签名如下。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，其中，参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">        str := strconv.FormatInt(num, <span class="number">16</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">        <span class="comment">//type:string,value:64</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p>FormatFloat() 函数用于将浮点数转换为字符串类型，参数说明：</p><ul><li>bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。</li><li>fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd  十进制指数、“E”表示 -d.ddddE±dd  十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li><li>prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 fmt 为“g”、“G”时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ol><li>值类型<ol><li>int系列</li><li>float系列</li><li>bool</li><li>string</li><li>数组</li><li>结构体</li></ol></li><li>引用类型<ol><li>指针</li><li>slice切片</li><li>map</li><li>管道chan</li><li>interface</li></ol></li></ol><blockquote><p>注意值类型参数默认就是值传递，而引用类型参数默认就是引用传递。但是不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小</p></blockquote><blockquote><p>引用类型默认是引用传递，变量存储的是一个地址，这个地址对应的空间才是真正存储数据值，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</p></blockquote><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>注意下面几点</p><ol><li>golang没有三元运算符</li><li>只能写i++</li><li>取余的结果与被除数的符号一样</li><li>&amp;&amp;和||都具有短路效果</li></ol><h1 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a>分支和循环</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age := <span class="number">20</span> ; age &gt; <span class="number">18</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> key&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,n1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span> <span class="comment">//默认只能穿透一层</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">x = y</span><br><span class="line"><span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;mox 的 类型是: %T&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ol><li><p>``` go<br>var str string = “hello,wordld~”<br>for i := 0 ; i &lt; len(str) ; i++{</p><pre><code>fmt.Printf(&quot;%c \n&quot;,str[i])</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   i := 1</span><br><span class="line">   for i &lt;= 19&#123;</span><br><span class="line">       ///</span><br><span class="line">       i++</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>```go<br>k := 1<br>for {</p><pre><code>if k &lt;= 19 &#123;    &#125;else&#123;    break&#125;k++</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   //Golang提供for-range的方式可以方便遍历字符串和数组（能遍历中文）</span><br><span class="line">   str := &#x27;a北京&#x27;</span><br><span class="line">   for index , val := range str&#123;</span><br><span class="line">       fmt.Printf(&quot;index = %d,val = %c \n&quot;,index,val)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>```go<br>//对于while的实现改成<br>for{</p><pre><code>if 循环条件表达式&#123;    break&#125;//语句循环遍历迭代</code></pre><p>}</p><p>//对于dowhile的实现改成<br>for{</p><pre><code>//语句循环遍历迭代if 循环条件表达式&#123;    break&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## break continue</span><br><span class="line"></span><br><span class="line">### 生成随机数</span><br><span class="line"></span><br><span class="line">``` go</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">intn := rand.Intn(3)//intn取值是0,1,2</span><br><span class="line">println(intn)</span><br></pre></td></tr></table></figure></li></ol><p>###break和continue</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里演示一下指定标签的形式来使用 break</span></span><br><span class="line">lable2: </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">         <span class="keyword">break</span> lable2 <span class="comment">// j=0 j=1</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;j=&quot;</span>, j) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lable2:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">   <span class="comment">//lable1: // 设置一个标签在这里设置等价于普通的continue</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> lable2</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;i=&quot;</span>,i,<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出如下</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>###<strong>goto的使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="type">int</span> = <span class="number">30</span></span><br><span class="line"><span class="comment">//演示goto的使用</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ok1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">20</span> &#123;</span><br><span class="line">   <span class="keyword">goto</span> label1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;ok2&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok4&quot;</span>)</span><br><span class="line">label1:</span><br><span class="line">fmt.Println(<span class="string">&quot;ok5&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok6&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok7&quot;</span>)</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">ok1</span><br><span class="line">ok5</span><br><span class="line">ok6</span><br><span class="line">ok7</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="type">float64</span>, n2 <span class="type">byte</span>)</span></span> <span class="type">float64</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>,sub <span class="type">int</span>)&#123;&#125;<span class="comment">//支持对函数返回值命名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,args... <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;&#125;<span class="comment">//args是slice切片，通过args[index]访问</span></span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ol><li>在给一个go文件打包时，该包对应一个文件夹，go文件的的包名通常和文件所在的文件夹名字一致，一般为小写字母</li><li>import包时，路径从$GOPATH的src下开始，不用带src，编译器会自动从src下开始引入</li><li>为了让其他包的文件可以访问到本包的函数，该函数名的首字母需要大写，类似其他语言的public，这样才能跨包访问</li><li>在访问其他包函数变量时，语法是包名.函数名</li><li>如果包名较长，Go支持给包取别名，注意细节：取别名之后，原来的包名就不能使用了</li></ol><h2 id="函数注意事项"><a href="#函数注意事项" class="headerlink" title="函数注意事项"></a>函数注意事项</h2><ol><li><p>基本数据类型和数组默认都是值传递的，即进行值拷贝，在函数内修改，不会影响原来的值</p></li><li><p>如果希望函数内的变量能修改函数外的变量（指的是默认以值传递的方式的数据类型），可以传入变量的地址&amp;。函数内以指针的方式操作变量</p></li><li><p>go函数不支持重载</p></li><li><p>函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用，同时既然是数据类型，因此函数也可以作为形参，并且调用</p></li><li><p>每个源文件都可以包含一个<code>init函数</code>，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用</p></li><li><p>==函数初始化的执行顺序==</p><ol><li>先导入其他包，执行被导入的包的初始化</li><li>初始化顺序是先执行全局变量的初始化</li><li>然后执行init函数</li></ol></li><li><p>匿名函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res1 := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;<span class="keyword">return</span> n1+n2&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;<span class="keyword">return</span> n1+n2&#125;</span><br><span class="line">res2 := a(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局匿名函数：将匿名函数赋给一个全局变量</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    Fun1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span><span class="type">int</span>&#123;<span class="keyword">return</span> n1 + n2&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol><li><p>闭包就是一个函数和其相关的引用环境组合的一个整体</p></li><li><p>闭包的使用是通过返回一个匿名函数实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span> </span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      n = n + x</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := AddUpper()</span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">// 11 </span></span><br><span class="line">fmt.Println(f(<span class="number">2</span>))<span class="comment">// 13</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ol><li>当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数下一个语句</li><li>当函数执行完毕后，再从栈顶取出语句执行</li><li>在defer将语句放入到栈时，也会将相关的值拷贝同时入栈，</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">7</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">func1(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func1(&quot;Go&quot;) = 7, EOF</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;defer:&quot;</span>, i, y)</span><br><span class="line">&#125;(x)</span><br><span class="line">x += <span class="number">10</span></span><br><span class="line">y += <span class="number">100</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是</span></span><br><span class="line">x= <span class="number">20</span> y= <span class="number">120</span> </span><br><span class="line"><span class="keyword">defer</span>: <span class="number">10</span> <span class="number">120</span></span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol><li>函数内部声明定义的变量叫局部变量，作用域仅限于函数内部</li><li>函数外部声明定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效</li><li>如果变量在一个代码块，比如for/if中，那么这个变量的作用域就在该代码块中</li></ol><p>#异常处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//使用defer + recover 来捕获和处理异常</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := <span class="built_in">recover</span>()  <span class="comment">// recover()内置函数，可以捕获到异常</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="comment">// 说明捕获到错误</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;err=&quot;</span>, err)</span><br><span class="line">         <span class="comment">//这里就可以将错误信息发送给管理员....</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;发送邮件给admin@sohu.com~&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   num1 := <span class="number">10</span></span><br><span class="line">   num2 := <span class="number">0</span></span><br><span class="line">   res := num1 / num2</span><br><span class="line">   fmt.Println(<span class="string">&quot;res=&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数去读取以配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">      <span class="comment">//读取...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//返回一个自定义错误</span></span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误..&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>工厂模式创建对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span>   <span class="comment">//其它包不能直接访问..</span></span><br><span class="line">sal <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个工厂模式的函数，相当于构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">Name : name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> age &gt;<span class="number">0</span> &amp;&amp; age &lt;<span class="number">150</span> &#123;</span><br><span class="line">p.age = age</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;年龄范围不正确..&quot;</span>)</span><br><span class="line"><span class="comment">//给程序员给一个默认值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##继承</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A    <span class="comment">//这样就表示内嵌，但是和java的继承有些许不同，不能父类指针指向子类对象，Go中的内嵌方法不算重载的概念，算是叫隐藏。 </span></span><br><span class="line">    <span class="comment">//后面var b B; 然后可以直接b.name.或者b.A.name访问方法和变量  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##组合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    a A    <span class="comment">//这样就表示组合， 后面var b B; 然后只能b.a.name访问方法和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h3><p>​    比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// 编译错误！</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>​    而以指针为接收者的方法被调用时，接收者既能为值又能为指针：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>​    对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。     也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">p.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(v, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(p.Abs())   <span class="comment">//方法调用可以这样</span></span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br></pre></td></tr></table></figure><p>###基于指针对象的方法</p><p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实现是通过接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b2 <span class="type">float32</span> = <span class="number">2.1</span></span><br><span class="line">x = b2 <span class="comment">//空接口，可以接收任何类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> y, ok := x.(<span class="type">float32</span>); ok &#123; <span class="comment">//调用特有方法，需要类型断言来转型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;y的类型是 %T 值是%v&quot;</span>, y, y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;转换失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol><li><p>```go<br>file, err := os.Open(“d:/test.txt”) //打开文件<br>err = file.Close()  //关闭文件<br>if err != nil {</p><pre><code>fmt.Println(&quot;close file err=&quot;, err)</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 文件的读取有两种方式</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   reader := bufio.NewReader(file)</span><br><span class="line">   //循环的读取文件的内容</span><br><span class="line">   for &#123;</span><br><span class="line">   str, err := reader.ReadString(&#x27;\n&#x27;) // 读到一个换行就结束</span><br><span class="line">   //输出内容</span><br><span class="line">   fmt.Printf(str)</span><br><span class="line">   </span><br><span class="line">   if err == io.EOF &#123; // io.EOF表示文件的末尾</span><br><span class="line">   break</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   -----------------------------------------</span><br><span class="line">   content, err := ioutil.ReadFile(&quot;d:/test.txt&quot;)</span><br><span class="line">   fmt.Printf(&quot;%v&quot;, string(content)) // content是[]byte需要强转。文件的Open和Close被封装到 ReadFile 函数内部，不需要我们写</span><br></pre></td></tr></table></figure></li><li><p>文件的写入也有两种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">filePath := <span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//及时关闭file句柄</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">str := <span class="string">&quot;hello,Gardon\n&quot;</span> <span class="comment">// \r\n 表示换行</span></span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">writer.WriteString(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为writer是带缓存，因此在调用WriterString方法时，其实</span></span><br><span class="line"><span class="comment">//内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据</span></span><br><span class="line"><span class="comment">//真正写入到文件中， 否则文件中会没有数据!!!</span></span><br><span class="line">writer.Flush()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将d:/abc.txt 文件内容导入到  d:/kkk.txt</span></span><br><span class="line"></span><br><span class="line">data, err := ioutil.ReadFile(<span class="string">&quot;d:/abc.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">err = ioutil.WriteFile(<span class="string">&quot;d:/kkk.txt&quot;</span>, data, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断文件是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">_, err := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span> <span class="comment">//文件或者目录存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span> <span class="comment">//文件或文件夹不存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err <span class="comment">//其他类型错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(os.Args))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">   fmt.Println(i, <span class="string">&quot;---&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用flag解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;user 就是接收用户命令行中输入的 -u 后面的参数值</span></span><br><span class="line"><span class="comment">//&quot;u&quot; ,就是 -u 指定参数</span></span><br><span class="line"><span class="comment">//&quot;&quot; , 默认值</span></span><br><span class="line"><span class="comment">//&quot;用户名,默认为空&quot; 说明</span></span><br><span class="line">flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名,默认为空&quot;</span>)</span><br><span class="line">flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码,默认为空&quot;</span>)</span><br><span class="line">flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名,默认为localhost&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为3306&quot;</span>)</span><br><span class="line"><span class="comment">//这里有一个非常重要的操作,转换， 必须调用该方法</span></span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>)</span><br><span class="line"><span class="comment">//这样也能解析然后获取对应的参数到n和sep</span></span><br><span class="line"><span class="comment">//不过访问时要用 *n  *sep</span></span><br></pre></td></tr></table></figure><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>序列化和反序列化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将monster 序列化</span></span><br><span class="line">data, err := json.Marshal(&amp;monster) <span class="comment">//..</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="comment">//注意：反序列化map,不需要make,因为make操作被封装到 Unmarshal函数</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li><p>测试用例文件必须以 _test.go结尾。比如cal_test.go  其中cal不是固定的</p></li><li><p>测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAdd（注意A必须大写，即Test后的首字母必须大写） 同时测试用例函数的形参类型必须是*testing.T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">addf := aaa.Addf(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">//测试aaa包下的Addf函数</span></span><br><span class="line"><span class="keyword">if</span> addf == <span class="number">3</span> &#123;</span><br><span class="line">t.Logf(<span class="string">&quot;测试成功&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;测试失败&quot;</span>) <span class="comment">//当出现错误时用这个输出错误信息并退出程序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cmd&gt;go test  <code>如果运行正确，无日志，错误时会输出日志</code></p><p>cmd &gt; go test -v <code> 运行正确或是错误，都会输出日志</code></p><p>测试单个文件，一定要带上被测试的原文件 go test -v cal_test.go cal.go</p><p>测试单个方法 go test -v -test.run TestAddUpper<code>(这个是方法名)</code></p></li></ol><h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpuNum := runtime.NumCPU() <span class="comment">//系统CPU数量</span></span><br><span class="line"><span class="comment">//可以自己设置使用多个cpu</span></span><br><span class="line">runtime.GOMAXPROCS(cpuNum - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>协程goroutine运行要注意同时写的资源竞争问题，可以用 go build -race 来编译运行查看是否存在资源竞争问题</p><p>解决方法</p><ol><li><p>全局变量加锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="comment">// test 函数就是计算 n!, 让将这个结果放入到 myMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">res := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">res *= i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock.Lock()</span><br><span class="line">myMap[n] = res <span class="comment">//concurrent map writes?</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> test(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//休眠10秒钟【第二个问题 】</span></span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>```go<br>var wg sync.WaitGroup</p><p>func hello(i int) {</p><pre><code>defer wg.Done() // goroutine结束就登记-1fmt.Println(&quot;Hello Goroutine!&quot;, i)</code></pre><p>}<br>func main() {</p><pre><code>for i := 0; i &lt; 10; i++ &#123;    wg.Add(1) // 启动一个goroutine就登记+1    go hello(i)&#125;wg.Wait() // 等待所有登记的goroutine都结束</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **读写锁**</span><br><span class="line"></span><br><span class="line">   读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   var (</span><br><span class="line">   x      int64</span><br><span class="line">   wg     sync.WaitGroup</span><br><span class="line">   lock   sync.Mutex</span><br><span class="line">   rwlock sync.RWMutex</span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line">   func write() &#123;</span><br><span class="line">   // lock.Lock()   // 加互斥锁</span><br><span class="line">   rwlock.Lock() // 加写锁</span><br><span class="line">   x = x + 1</span><br><span class="line">   time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒</span><br><span class="line">   rwlock.Unlock()                   // 解写锁</span><br><span class="line">   // lock.Unlock()                     // 解互斥锁</span><br><span class="line">   wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func read() &#123;</span><br><span class="line">   // lock.Lock()                  // 加互斥锁</span><br><span class="line">   rwlock.RLock()               // 加读锁</span><br><span class="line">   time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒</span><br><span class="line">   rwlock.RUnlock()             // 解读锁</span><br><span class="line">   // lock.Unlock()                // 解互斥锁</span><br><span class="line">   wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func main() &#123;</span><br><span class="line">   start := time.Now()</span><br><span class="line">   for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">   wg.Add(1)</span><br><span class="line">   go write()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">   wg.Add(1)</span><br><span class="line">   go read()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   wg.Wait()</span><br><span class="line">   end := time.Now()</span><br><span class="line">   fmt.Println(end.Sub(start))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>channel</p><ol><li><p>channel本质就是一个数据结构-队列，数据先进先出</p></li><li><p>线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的</p></li><li><p>channel有类型的，一个string类型的channel只能存放string类型数据</p></li><li><p>channe的定义和初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//无缓冲的管道</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>) <span class="comment">//必须make才能用，而且还要指定len才能用</span></span><br><span class="line">b &lt;- <span class="string">&quot;dd&quot;</span></span><br><span class="line">b &lt;- <span class="string">&quot;aa&quot;</span></span><br><span class="line"></span><br><span class="line">val1 := &lt;-b</span><br></pre></td></tr></table></figure></li><li><p>channel的数据放满了后，就不能再放入了，若没有使用协程的情况下，如果channel的数据取完了，再取就会报  <code>fatal error: all goroutines are asleep - deadlock! </code> 错误</p></li><li><p>管道的遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历管道</span></span><br><span class="line">intChan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">intChan2 &lt;- i * <span class="number">2</span> <span class="comment">//放入100个数据到管道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历管道不能使用普通的 for 循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intChan2); i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;v=&quot;</span>, &lt;-intChan2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在遍历时，如果channel没有关闭，则会出现deadlock的错误</span></span><br><span class="line"><span class="comment">//在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</span></span><br><span class="line"><span class="built_in">close</span>(intChan2)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;v=&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">//另一种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">num, ok := &lt;-intChan <span class="comment">//intChan 取不到..</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line"><span class="keyword">break</span>  <span class="comment">//没数据时退出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只读或者只写的管道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在默认情况下下，管道是双向</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//两种写法都可以</span></span><br><span class="line">    chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">-------------------------------------</span><br><span class="line">chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">chan2 &lt;- <span class="number">20</span></span><br><span class="line"><span class="comment">//num := &lt;-chan2 //error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 声明为只读</span></span><br><span class="line">chan3 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">num2 := &lt;-chan3</span><br><span class="line"><span class="comment">//chan3&lt;- 30 //err</span></span><br></pre></td></tr></table></figure></li><li><p>select的用法</p><p>​    <code>select</code> 语句使一个 Go 程可以等待多个通信操作。  </p><p>​    <code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题，在实际开发中，可能我们不好确定什么关闭该管道.</span></span><br><span class="line"><span class="comment">//可以使用select 方式可以解决</span></span><br><span class="line">label:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">//注意: 这里，如果intChan一直没有关闭，不会一直阻塞而deadlock</span></span><br><span class="line"><span class="comment">//，会自动到下一个case匹配</span></span><br><span class="line"><span class="keyword">case</span> v := &lt;-intChan : </span><br><span class="line">fmt.Printf(<span class="string">&quot;从intChan读取的数据%d\n&quot;</span>, v)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">case</span> v := &lt;-stringChan :</span><br><span class="line">fmt.Printf(<span class="string">&quot;从stringChan读取的数据%s\n&quot;</span>, v)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">fmt.Printf(<span class="string">&quot;都取不到了，不玩了, 程序员可以加入逻辑\n&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">break</span> label</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><ol><li><p>Dial函数和服务端建立连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.191.2:8888&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;client dial err=&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//功能一：客户端可以发送单行数据，然后就退出</span></span><br><span class="line">reader := bufio.NewReader(os.Stdin) <span class="comment">//os.Stdin 代表标准输入[终端]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从终端读取一行用户输入，并准备发送给服务器</span></span><br><span class="line">line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;readString err=&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果用户输入的是 exit就退出</span></span><br><span class="line">line = strings.Trim(line, <span class="string">&quot; \r\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;客户端退出..&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再将line 发送给 服务器</span></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(line + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;conn.Write err=&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Listen函数创建的服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="comment">//这里我们循环的接收客户端发送的数据</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">//关闭conn</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//创建一个新的切片</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment">//conn.Read(buf)</span></span><br><span class="line"><span class="comment">//1. 等待客户端通过conn发送信息</span></span><br><span class="line"><span class="comment">//2. 如果客户端没有wrtie[发送]，那么协程就阻塞在这里</span></span><br><span class="line"><span class="comment">//fmt.Printf(&quot;服务器在等待客户端%s 发送信息\n&quot;, conn.RemoteAddr().String())</span></span><br><span class="line">n , err := conn.Read(buf) <span class="comment">//从conn读取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;客户端退出 err=%v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 显示客户端发送的内容到服务器的终端</span></span><br><span class="line">fmt.Print(<span class="type">string</span>(buf[:n])) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;服务器开始监听....&quot;</span>)</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;0.0.0.0:8888&quot;</span>)<span class="comment">//监听本机的端口</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;listen err=&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close() <span class="comment">//延时关闭listen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待客户端来链接我</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//等待客户端链接</span></span><br><span class="line">fmt.Println(<span class="string">&quot;等待客户端来链接....&quot;</span>)</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Accept() err=&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Accept() suc con=%v 客户端ip=%v\n&quot;</span>, conn, conn.RemoteAddr().String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里准备其一个协程，为客户端服务</span></span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h4 id="判断种类"><a href="#判断种类" class="headerlink" title="判断种类"></a>判断种类</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int64:</span><br><span class="line"><span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float32:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####修改值获取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;tom&quot;</span>      </span><br><span class="line">   fs := reflect.ValueOf(&amp;str) <span class="comment">//修改值必须用&amp;传参</span></span><br><span class="line">    aa := reflect.ValueOf(str).String() + <span class="string">&quot;aa&quot;</span><span class="comment">//获取值用.String() .Interface()   .Int()</span></span><br><span class="line">   fmt.Println(aa, str) <span class="comment">//输出结果：tomaa tom</span></span><br><span class="line">    fs.Elem().SetString(<span class="string">&quot;jack&quot;</span>) <span class="comment">////修改值必须先.Elem()</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, str)     <span class="comment">// jack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####结构体获取方法和成员</p><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   stu1 := student&#123;</span><br><span class="line">      Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">      Score: <span class="number">90</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t := reflect.TypeOf(stu1)</span><br><span class="line">   fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">   <span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">      field := t.Field(i)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">   <span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.NumMethod())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">methodType := v.Method(i).Type()</span><br><span class="line">fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line"><span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line"><span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">v.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========================</span><br><span class="line">args = <span class="built_in">append</span>(args, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">args = <span class="built_in">append</span>(agrs, reflect.ValueOf(<span class="number">40</span>))<span class="comment">//通过这种方式添加参数</span></span><br></pre></td></tr></table></figure><h1 id="go中的数据结构"><a href="#go中的数据结构" class="headerlink" title="go中的数据结构"></a>go中的数据结构</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span> <span class="comment">// 姓名</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="comment">// 年纪</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 Person.Age 从大到小排序</span></span><br><span class="line"><span class="keyword">type</span> PersonSlice []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Len() <span class="type">int</span> &#123; <span class="comment">// 重写 Len() 方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123; <span class="comment">// 重写 Swap() 方法</span></span><br><span class="line">   a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="comment">// 重写 Less() 方法， 从小到大排序</span></span><br><span class="line">   res := a[i].Age - a[j].Age</span><br><span class="line">   <span class="keyword">if</span> res == <span class="number">0</span> &#123;</span><br><span class="line">      res = strings.Compare(a[i].Name, a[j].Name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> res &gt; <span class="number">0</span> &#123;  <span class="comment">//从大到小排序，当年龄数字一样时，名字也是从大到小排序</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   people := []Person&#123;</span><br><span class="line">      &#123;<span class="string">&quot;ahang san&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;li si&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;bang wu&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;zhao liu&quot;</span>, <span class="number">26</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">   sort.Sort(PersonSlice(people)) <span class="comment">// 按照 Age 的升序排序</span></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">   sort.Sort(sort.Reverse(PersonSlice(people))) <span class="comment">// 按照 Age 的降序排序</span></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序正序，基本数据类型的切片用这几个函数</span></span><br><span class="line">sort.Sort(sort.IntSlice(intList))</span><br><span class="line">    sort.Sort(sort.Float64Slice(floatList))</span><br><span class="line">    sort.Sort(sort.StringSlice(stringList))</span><br></pre></td></tr></table></figure><p>##堆，优先队列</p><p>heap是常用的实现优先队列的方法。heap包对任意实现了heap接口的类型提供堆操作。堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：Len() int / Less(i, j int) bool / Swap(i, j  int) 再加上堆接口定义的两个方法：Push(x interface{}) / Pop()  interface{}。故只要实现了这五个方法，便定义了一个堆。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    heap.Push(h, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==优先队列：==</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu []stu</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*t) <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*t)[i].age &lt; (*t)[j].age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*t)[i], (*t)[j] = (*t)[j], (*t)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *t = <span class="built_in">append</span>(*t, x.(stu))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*t)</span><br><span class="line">    x := (*t)[n<span class="number">-1</span>]</span><br><span class="line">    *t = (*t)[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := &amp;Stu&#123;&#123;<span class="string">&quot;Amy&quot;</span>, <span class="number">21</span>&#125;, &#123;<span class="string">&quot;Dav&quot;</span>, <span class="number">15</span>&#125;, &#123;<span class="string">&quot;Spo&quot;</span>, <span class="number">22</span>&#125;, &#123;<span class="string">&quot;Reb&quot;</span>, <span class="number">11</span>&#125;&#125;</span><br><span class="line">    heap.Init(student)</span><br><span class="line">    one := stu&#123;<span class="string">&quot;hund&quot;</span>, <span class="number">9</span>&#125;</span><br><span class="line">    heap.Push(student, one)</span><br><span class="line">    <span class="keyword">for</span> student.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, heap.Pop(student))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h2><p>可以类比数据结构中线性表的删除</p><p>要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>下面的方式可以在LeetCode中使用，简单的实现栈和队列。但是在实际项目中不要这么使用，这么做会带来内存泄漏的风险。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入栈</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="number">1</span>)</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 出栈</span></span><br><span class="line">queue = queue[<span class="number">1</span>: <span class="built_in">len</span>(queue)]</span><br><span class="line">stack = stack[<span class="number">0</span>: <span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p> golang 内置的 <a href="https://links.jianshu.com/go?to=https://golang.org/pkg/container/list/"><code>container/list</code></a> 库提供了双向链表的数据结构。我们用这个也是很方便的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue := list.New()</span><br><span class="line">stack := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入栈</span></span><br><span class="line">queue.PushBack(<span class="number">123</span>)</span><br><span class="line">stack.PushBack(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 出栈 返回的数据是结构类型 Value 需要断言成相应的类型</span></span><br><span class="line">num1 = queue.Front() <span class="comment">//num1.Value才是具体值，不然是地址</span></span><br><span class="line">queue.Remove(num1)</span><br><span class="line"></span><br><span class="line">num2 = queue.Back()</span><br><span class="line">stack.Remove(num2)</span><br></pre></td></tr></table></figure><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span></span><br><span class="line"><span class="comment">// License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// See page 101.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package treesort provides insertion sort using an unbalanced binary tree.</span></span><br><span class="line"><span class="keyword">package</span> treesort</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+</span></span><br><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">   value       <span class="type">int</span></span><br><span class="line">   left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort sorts values in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> root *tree</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">      root = add(root, v)  <span class="comment">//建树</span></span><br><span class="line">   &#125;</span><br><span class="line">   appendValues(values[:<span class="number">0</span>], root)<span class="comment">//中序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues appends the elements of t to values in order</span></span><br><span class="line"><span class="comment">// and returns the resulting slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="type">int</span>, t *tree)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">      values = appendValues(values, t.left)</span><br><span class="line">      values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">      values = appendValues(values, t.right)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="type">int</span>)</span></span> *tree &#123;</span><br><span class="line">   <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class="line">      t = <span class="built_in">new</span>(tree)</span><br><span class="line">      t.value = value</span><br><span class="line">      <span class="keyword">return</span> t</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">      t.left = add(t.left, value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      t.right = add(t.right, value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!-</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %c %d&quot;</span>, &amp;a, &amp;b, &amp;c)</span><br><span class="line">---------------</span><br><span class="line"><span class="comment">//输入一行的话</span></span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> d [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> e []<span class="type">string</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d %d\n&quot;</span>, &amp;a, &amp;b, &amp;c)</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入字符串的两行&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s\n&quot;</span>, &amp;s) <span class="comment">//后面的\n不加的话按Enter键的也被加入e</span></span><br><span class="line">e = <span class="built_in">append</span>(e, s)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;请输入数组的两行三列&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b; j++ &#123;</span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;d[i][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>, d[i][j])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(e[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>###for循环中的陷阱</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary! 这个不能省略，不然就出错原因是d是引用地址</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map的值是切片的陷阱"><a href="#map的值是切片的陷阱" class="headerlink" title="map的值是切片的陷阱"></a>map的值是切片的陷阱</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span></span><br><span class="line">   m := <span class="built_in">make</span>(Map)</span><br><span class="line">   s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">   s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)<span class="comment">//[1 2 3]</span></span><br><span class="line">   m[<span class="string">&quot;q1mi&quot;</span>] = s</span><br><span class="line">   s = <span class="built_in">append</span>(s[:<span class="number">1</span>], s[<span class="number">2</span>:]...)<span class="comment">//相当于删除s[1],  [1 3]</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])<span class="comment">//[1 3 3]</span></span><br><span class="line">   s = <span class="built_in">append</span>(s,<span class="number">4</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])<span class="comment">//[1 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer的陷阱"><a href="#defer的陷阱" class="headerlink" title="defer的陷阱"></a>defer的陷阱</h3><p>==暂时还看不懂==</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   x := <span class="number">5</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> (y <span class="type">int</span>) &#123;</span><br><span class="line">   x := <span class="number">5</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;(x)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(f1())</span><br><span class="line">   fmt.Println(f2())</span><br><span class="line">   fmt.Println(f3())</span><br><span class="line">   fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   ret := a + b</span><br><span class="line">   fmt.Println(index, a, b, ret)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x := <span class="number">1</span></span><br><span class="line">   y := <span class="number">2</span></span><br><span class="line">   <span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">   x = <span class="number">10</span></span><br><span class="line">   <span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">   y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###牛客陷阱</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   a := <span class="number">12</span></span><br><span class="line">   &#123;</span><br><span class="line">      a := <span class="number">13</span></span><br><span class="line">      _ = a <span class="comment">// make compiler happy</span></span><br><span class="line">      fmt.Println(a)<span class="comment">//输出13</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)<span class="comment">//输出12</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于常量定义zero(const zero = 0.0)，zero是浮点型常量，这一说法是否正确。<code>错误</code>Go语言里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
