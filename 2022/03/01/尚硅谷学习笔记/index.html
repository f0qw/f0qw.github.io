<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"f0qw.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习总结Go语言。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言学习">
<meta property="og:url" content="http://f0qw.github.io/2022/03/01/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="kueen的博客">
<meta property="og:description" content="学习总结Go语言。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212134868.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135198.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135392.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135915.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135793.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135018.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135880.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135902.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135692.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135065.png">
<meta property="og:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212136842.png">
<meta property="article:published_time" content="2022-03-01T08:08:22.000Z">
<meta property="article:modified_time" content="2022-08-03T16:18:05.323Z">
<meta property="article:author" content="chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212134868.png">

<link rel="canonical" href="http://f0qw.github.io/2022/03/01/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Go语言学习 | kueen的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kueen的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://f0qw.github.io/2022/03/01/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kueen的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go语言学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-01 16:08:22" itemprop="dateCreated datePublished" datetime="2022-03-01T16:08:22+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-04 00:18:05" itemprop="dateModified" datetime="2022-08-04T00:18:05+08:00">2022-08-04</time>
              </span>

          
            <div class="post-description">学习总结Go语言。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>Project项目名，-》src目录 -》go_code -&gt;&gt; 模块1，模块2 -&gt;&gt; main文件夹和其他文件夹</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212134868.png" alt="image-20220217214708424"></p>
<p>在对应的go文件目录下用cmd窗口打开，并运行 go build hello.go就会生成可执行文件hello.exe</p>
<p>==还可以通过 go build -o aaa/myhello.exe hello.go 指定生成的exe文件所在的目录==</p>
<p>==go build -o ../package/myhello.exe hello.go  回退上一级的package目录生成==</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135198.png" alt="image-20220217215651703"></p>
<h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><ol>
<li><p>使用shift+tab 和tab 或者 使用命令 gofmt  -w  文件名.go</p>
</li>
<li><p>运算符两边习惯各加一个空格</p>
</li>
<li><p>注意保持package包名和所在的外面文件夹的名字一样。除了package main</p>
</li>
<li><p>变量名、函数名、常量名 采用驼峰法，且首字母大写则可以被其他包访问；首字母小谢则只能在本包中使用，（可以理解成首字母大写是公开的，首字母小写是私有的，在golang里没有public，private等关键字）</p>
</li>
<li><p>Go 的源文件以 .go 为后缀名存储在计算机中，这些文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 scanner_test.go 。文件名不包含空格或其他特殊字符。</p>
</li>
<li><p>在习惯上，Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名</p>
</li>
<li><p>导入其他包时，注意import完整的路径按理说应该是 D:/Project/src/go_code/project1/module1 类似这种的，但是因为设置了gopath所以前面D:/Project是可以不用写的，然后src又是默认的，因此</p>
<p>import  “go_code/project1/module1” 这样写就行</p>
</li>
</ol>
<h2 id="IDE报错"><a href="#IDE报错" class="headerlink" title="IDE报错"></a>IDE报错</h2><h3 id="command-line-arguments-undefined"><a href="#command-line-arguments-undefined" class="headerlink" title="command-line-arguments undefined:"></a>command-line-arguments undefined:</h3><p>问题是使用goland开发。同一个包下两个或多个go文件，包名为main，点击其中一个文件的main()方法运行另一个文件的方法时报错，</p>
<p>解决办法是在goland中ctrl两个文件一起然后右键build运行</p>
<p>#go mod依赖管理</p>
<h2 id="传统模式建项目"><a href="#传统模式建项目" class="headerlink" title="传统模式建项目"></a>传统模式建项目</h2><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135392.png" alt="image-20220228122245833"></p>
<p>注意项目要放在gopath目录下的src目录下，注意要把go111module设为off</p>
<p>##go mod方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init</span><br><span class="line"><span class="keyword">go</span> mod download</span><br><span class="line"><span class="keyword">go</span> mod tidy <span class="comment">//更新</span></span><br><span class="line"></span><br><span class="line">运行<span class="keyword">go</span> get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</span><br><span class="line"></span><br><span class="line">GOPROXY=https:<span class="comment">//mirrors.aliyun.com,direct.</span></span><br></pre></td></tr></table></figure>

<p>运行的</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135915.png" alt="image-20220221190349551"></p>
<p>这样最后下载的包会自动放在gopath目录下的与src同级的pkg目录（自动生成） ==因为设置了本项目的GOpath==</p>
<p>如果不设置这个的话gomod下载的依赖会自动放在全局GOPATH的pkg目录下</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135793.png" alt="image-20220227143912789"></p>
<p>为整个GOPATH编制索引得加上==会将当前项目作为GOPATH 这个是推荐的。这样各个项目彼此独立不会存在谁污染谁的问题。   暂时不知道啥用，加上和不加上好像没区别==，</p>
<p>点击爆红的import alt+enter可以让你在代码中同步依赖然后就能自动拉取已经在本地pkg中的包</p>
<p>GOPROXY=<a target="_blank" rel="noopener" href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135018.png" alt="image-20220221190415461"></p>
<p>然后控制端用go mod tidy就行</p>
<h2 id="实现导入自己的包"><a href="#实现导入自己的包" class="headerlink" title="实现导入自己的包"></a>实现导入自己的包</h2><p>#github和git的操作</p>
<ol>
<li><p>ctrl+shift+A 窗口搜索 克隆 ， 然后克隆项目</p>
</li>
<li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135880.png" alt="image-20220221000947454"></p>
</li>
<li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135902.png" alt="image-20220221001100085"></p>
</li>
<li><p>alt+9查看历史提交</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135692.png" alt="image-20220221001631443"></p>
</li>
</ol>
<p><strong>goland操作</strong></p>
<ol>
<li><p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212135065.png" alt="image-20220221175447112">按ctrl+i快速实现一个接口，会自动创建结构体和该结构体实现了这个接口</p>
</li>
<li><p>按F2直接跳到警告部分代码，对数字和字符串按个.直接能解析</p>
</li>
<li><p>ctrl+w</p>
</li>
</ol>
<p>#go的标准库</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://word.topgoer.com/">http://word.topgoer.com/</a> 查看标准库</p>
</blockquote>
<p>###strings</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">strings.EqualFold(<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;go&quot;</span>)<span class="comment">//判断是否忽略大小写相等 结果true</span></span><br><span class="line"></span><br><span class="line">strings.HasPrefix(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;你&quot;</span>)<span class="comment">//判断是否有前缀，结果true</span></span><br><span class="line"></span><br><span class="line">strings.HasSuffix(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;好&quot;</span>)<span class="comment">//判断后缀，结果true</span></span><br><span class="line"></span><br><span class="line">strings.Contains(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&quot;好&quot;</span>)<span class="comment">//结果true</span></span><br><span class="line"></span><br><span class="line">strings.ContainsRune(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&#x27;好&#x27;</span>)<span class="comment">//判断字符串s是否包含utf-8码值r。结果true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func ContainsAny(s, chars string) bool  </span></span><br><span class="line"><span class="comment">//判断字符串s是否包含字符串chars中的任一字符。</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;team&quot;</span>, <span class="string">&quot;i&quot;</span>)<span class="comment">//false</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;failure&quot;</span>, <span class="string">&quot;u &amp; i&quot;</span>)<span class="comment">//true</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="comment">//false</span></span><br><span class="line">strings.ContainsAny(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">strings.Count(<span class="string">&quot;你我我好我我&quot;</span>,<span class="string">&quot;我我&quot;</span>)<span class="comment">//返回字符串s中有几个不重复的sep子串。返回2</span></span><br><span class="line"></span><br><span class="line">strings.Index(<span class="string">&quot;chicken&quot;</span>, <span class="string">&quot;ken&quot;</span>)<span class="comment">//返回4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="type">string</span>, c <span class="type">byte</span>)</span></span> <span class="type">int</span><span class="comment">//字符c在s中第一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="type">string</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span><span class="comment">//unicode码值r在s中第一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span>   <span class="comment">//字符串chars中的任一utf-8码值在s中第一次出现的位置，如果不存在或者chars为空字符串则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep <span class="type">string</span>)</span></span> <span class="type">int</span>  <span class="comment">//子串sep在字符串s中最后一次出现的位置，不存在则返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="type">string</span>)</span></span> <span class="type">int</span>  <span class="comment">//字符串chars中的任一utf-8码值在s中最后一次出现的位置，如不存在或者chars为空字符串则返回-1。</span></span><br><span class="line">strings.LastIndexAny(<span class="string">&quot;你好呀啊&quot;</span>,<span class="string">&quot;d啊 你&quot;</span>)<span class="comment">//返回9.因为一个汉字占三个字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回s中每个单词的首字母都改为标题格式的字符串拷贝。<span class="doctag">BUG:</span> Title用于划分单词的规则不能很好的处理Unicode标点符号。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回将所有字母都转为对应的小写版本的拷贝。不会改变s的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将所有字母都转为对应的大写版本的拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="type">string</span>, count <span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">//返回count个s串联的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%q]&quot;</span>, strings.Trim(<span class="string">&quot; !!! Achtung! Achtung! !!! &quot;</span>, <span class="string">&quot;! &quot;</span>))</span><br><span class="line">Output:</span><br><span class="line">[<span class="string">&quot;Achtung! Achtung&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前后端所有空白（unicode.IsSpace指定）都去掉的字符串。</span></span><br><span class="line">fmt.Println(strings.TrimSpace(<span class="string">&quot; \t\n a lone gopher \n\t\r\n&quot;</span>))</span><br><span class="line">Output:</span><br><span class="line">a lone gopher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span> <span class="comment">//返回将s前端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回去除s可能的前缀prefix的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="type">string</span>, cutset <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回将s后端所有cutset包含的utf-8码值都去掉的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//返回去除s可能的后缀suffix的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span><span class="comment">//返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。</span></span><br><span class="line"></span><br><span class="line">strings.Split(<span class="string">&quot;a,b,c&quot;</span>,<span class="string">&quot;,&quot;</span>)<span class="comment">//返回值是一个字符串数组元素是abc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="type">string</span>, sep <span class="type">string</span>)</span></span> <span class="type">string</span><span class="comment">//将一系列字符串连接为一个字符串，之间用sep来分隔。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>###time</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time.Now().Year()<span class="comment">//获取当前年</span></span><br><span class="line">time.Now().Month()<span class="comment">//获取当前年</span></span><br><span class="line">time.Now().Unix()<span class="comment">//返回从1970到现在的秒值</span></span><br><span class="line">time.Now().UnixNano <span class="comment">//返回从1970到现在的纳秒值</span></span><br><span class="line"></span><br><span class="line">elapsed := time.Since(start)<span class="comment">//可以获得从start秒开始到现在的毫秒值</span></span><br></pre></td></tr></table></figure>



<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s))) <span class="comment">//逆序排</span></span><br></pre></td></tr></table></figure>





<h1 id="golang变量"><a href="#golang变量" class="headerlink" title="golang变量"></a>golang变量</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li><p>``` go<br>var i int //i此时是默认值0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` go</span><br><span class="line">   var i = 10.11 //根据值自行判断变量类型 （类型推导）</span><br></pre></td></tr></table></figure></li>
<li><p>``` go<br>i := “tom” //省略var，注意 := 左侧的变量不应该是已经声明过的，否则会编译错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ``` go</span><br><span class="line">   var n1 , n2 , n3 int //一次声明多个变量</span><br><span class="line">   var n1 , n2 , n2 = 100 , &quot;tom&quot; , 888</span><br><span class="line">   n1 , name , n3 := 100 , &quot;tom&quot; , 888</span><br></pre></td></tr></table></figure></li>
<li><p>一次性声明多个全局变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	n3 = <span class="number">300</span></span><br><span class="line">    n4 = <span class="number">900</span></span><br><span class="line">    n5 = <span class="string">&quot;mary&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>基本数据类型<ol>
<li>数值型<ol>
<li>整数类型（int,int8,int16,int32,int64,uint,uint8,uint16,uint64,byte）</li>
<li>浮点类型 (float32 , float64)</li>
</ol>
</li>
<li>布尔型 （bool）</li>
<li>字符串（string）</li>
</ol>
</li>
<li>派生复杂数据类型<ol>
<li>指针</li>
<li>数组</li>
<li>结构体 (struct)</li>
<li>管道（Channel）</li>
<li>函数</li>
<li>切片 （slice）</li>
<li>接口 （interface）</li>
<li>map</li>
</ol>
</li>
</ol>
<p>###整数类型</p>
<p>注意rune与int32一样范围，表示一个Unicode码</p>
<p>byte用于表示字符，</p>
<p>int uint的大小与系统有关</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 = <span class="number">100</span> <span class="comment">//n1默认是int型</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//unsafe.Sizeof(n1) 是unsafe包的一个函数，可以返回n1变量占用的字节数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2 的 类型 %T  n2占用的字节数是 %d &quot;</span>, n2, unsafe.Sizeof(n2))</span><br></pre></td></tr></table></figure>

<p>###浮点类型</p>
<blockquote>
<p>注意的是</p>
<p>golang的浮点型默认声明为float64</p>
<p>var n = 1.12 // n此时是float64的</p>
</blockquote>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示golang中字符类型使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1 <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">var</span> c2 <span class="type">byte</span> = <span class="string">&#x27;0&#x27;</span> <span class="comment">//字符的0</span></span><br><span class="line">   <span class="comment">//当我们直接输出byte值，就是输出了的对应的字符的码值</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c1=&quot;</span>, c1)<span class="comment">//c1= 97</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c2=&quot;</span>, c2)<span class="comment">//c2= 48</span></span><br><span class="line">   <span class="comment">//如果我们希望输出对应字符，需要使用格式化输出</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c1=%c c2=%c\n&quot;</span>, c1, c2)<span class="comment">//c1=a c2=0</span></span><br><span class="line">   <span class="comment">//var c3 byte = &#x27;北&#x27; //overflow溢出</span></span><br><span class="line">   <span class="keyword">var</span> c3 <span class="type">int</span> = <span class="string">&#x27;北&#x27;</span> </span><br><span class="line">   fmt.Printf(<span class="string">&quot;c3=%c c3对应码值=%d\n&quot;</span>, c3, c3)<span class="comment">//c3=北 c3对应码值=21271</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//可以直接给某个变量赋一个数字，然后按格式化输出时%c，会输出该数字对应的unicode 字符</span></span><br><span class="line">   <span class="keyword">var</span> c4 <span class="type">int</span> = <span class="number">22269</span> <span class="comment">// 22269 -&gt; &#x27;国&#x27; </span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c4=%c\n&quot;</span>, c4)<span class="comment">//c4=国</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//字符类型是可以进行运算的，相当于一个整数,运输时是按照码值运行</span></span><br><span class="line">   <span class="keyword">var</span> n1 = <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span> <span class="comment">//  10 + 97 = 107</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1)<span class="comment">//n1= 107</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ch = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ch的类似是%t,占用的字节是%d&quot;</span>,ch,unsafe.Sizeof(ch))<span class="comment">//ch的类似是%!t(int32=97),占用的字节是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go的字符串是由单个字节连接起来的。字节使用UTF-8编码识别Unicode文本，因此没有中文乱码问题</p>
<p>字符串一旦赋值，不能修改</p>
<p>可以用反引号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串遍历方式1-传统方式,注意这种方式对str2可以修改，但对str不能修改也就是说我们可以用str2[1]=&#x27;d&#x27;来修改值把‘北’改成‘d’</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;a北京&quot;</span></span><br><span class="line">	str2 := []<span class="type">rune</span>(str) <span class="comment">// 就是把 str 转成 []rune</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index = %d , %c \n&quot;</span>, i,str2[i]) <span class="comment">//使用到下标...</span></span><br><span class="line">        <span class="comment">//输出是index = 0 , a index = 1 , 北 ，index = 2 , 京 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串遍历方式2-for-range</span></span><br><span class="line">	<span class="keyword">for</span> index, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index=%d, val=%c \n&quot;</span>, index, val)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//index=0, val=a </span></span><br><span class="line"><span class="comment">//index=1, val=北 </span></span><br><span class="line"><span class="comment">//index=4, val=京 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>string底层是一个byte数组，如果需要修改字符串可以先将string转为[]byte 或者[]rune</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 := []<span class="type">rune</span>(str)</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">str = <span class="type">string</span>(arr1)</span><br></pre></td></tr></table></figure>

<hr>
<p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p>
<p><u><i>gopl.io/ch3/printints</i></u></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intsToString is like fmt.Sprint(values) but adds commas.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(intsToString([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)) <span class="comment">// &quot;[1, 2, 3]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似’[‘和’]’等ASCII字符则会更加有效。</p>
<p>bytes.Buffer类型有着很多实用的功能，我们在第七章讨论接口时将会涉及到，我们将看看如何将它用作一个I/O的输入和输出对象，例如当做Fprintf的io.Writer输出对象，或者当作io.Reader类型的输入源对象。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>###数组</p>
<ol>
<li><p>```go<br>var num [3]int = [3]int{1,2,3}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   var num = [3]int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>var num = […]int{1,2,3}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   var num = [...]int&#123;1:800, 0:900, 2:999&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>num := […]string{1:”tom”, 0:”jack”, 2:”mary”}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**数组的遍历方式**</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">for index,value := range array01&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>二维数组</strong></p>
<ol>
<li><p>```go<br>var arr [2][3]int //先声明再赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ``` go</span><br><span class="line">   var arr [2][3]int = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   var arr [2][3]int = [...][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   var arr = [2][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">   arr  := [...][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历方式</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(arr) ; i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr[i]); j++&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;%v\t&quot;</span>,arr[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span>(arr)&#123;</span><br><span class="line">		<span class="keyword">for</span> j , v2 := <span class="keyword">range</span>(v)&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;arr[%v][%v] = %v&quot;</span>,i,j,v2)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>###切片</p>
<p><strong>语法</strong></p>
<ol>
<li><p>```go<br>var arr [5]int = […]{1,22,33,65,99}<br>slice := arr[1:3]//得先有数组，然后让切片去引用一个已经创建好的数组<br>//注意这里引用的是1 2下标 。然后对slice和arr的里的元素的修改会互相影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   var slice []float64 = make([]float64,5,10)//make方式创建cap容量是10，len长度是5的切片，切片内各个元素使用默认值，</span><br><span class="line">   var slice = make([]float64,5,10)</span><br><span class="line">   slice := make([]float64,5,10)</span><br><span class="line">   //通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>var strSlice []string = []string{“tom”,”jack”,”mary”}<br>var strSlice  = []string{“tom”,”jack”,”mary”}<br>strSlice ：= []string{“tom”,”jack”,”mary”}<br>//方式3，定义一个切片，直接就指定具体数组，使用原理类似make的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过append（）来扩容</span><br><span class="line"></span><br><span class="line">1. 切片append操作的本质就是对数组扩容，go底层会创建一个新的数组newArr（安装扩容后大小），将slice原来包含的元素拷贝到新的数组newArr中，slice重新引用到newArr，注意newArr是在底层来维护的，程序员不可见，</span><br><span class="line">2. 因此append后两个数组的操作就独立开来了</span><br><span class="line">3. 切片之间的赋值需要通过copy函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ap的声</span><br><span class="line"></span><br><span class="line">### map</span><br><span class="line"></span><br><span class="line">当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</span><br><span class="line"></span><br><span class="line">map的声明</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">var mp map[string]string//注意声明不会分配内存，初始化需要make，分配内存后才能赋值和使用</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>具体使用</strong></p>
<ol>
<li><p>```go<br>var a map[string]string = make(map[string]string,10)<br>b := make(map[string]string)<br>c := map[string]string{“stu1”:”陈某”,”stu2”:”黄某”}</p>
<p>var m = map[string]Vertex{</p>
<pre><code>&quot;Bell Labs&quot;: Vertex&#123;
    40.68433, -74.39967,
&#125;,
&quot;Google&quot;: Vertex&#123;
    37.42202, -122.08408,
&#125;,
</code></pre>
<p>}<br>//若顶级类型只是一个类型名，你可以在文法的元素中省略它。<br>var m = map[string]Vertex{</p>
<pre><code>&quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,
&quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. 增删改查</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   city := make(map[string]string)</span><br><span class="line">   city[&quot;no1&quot;] = &quot;北京&quot;   //增加</span><br><span class="line">   city[&quot;no1&quot;] = &quot;深圳&quot;   //修改</span><br><span class="line">   delete(city,&quot;no1&quot;)//删除</span><br><span class="line">   </span><br><span class="line">   val , ok := city[&quot;no2&quot;]</span><br><span class="line">   if ok&#123;</span><br><span class="line">       fmt.Printf(&quot;有no1 key 值为%v \n&quot;,val) //查找</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       fmt.Printf(&quot;没有no1 key\n&quot;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>map的遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	city := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	city[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> city&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;k = %v  v = %v&quot;</span>,k,v)</span><br><span class="line">	&#125;</span><br><span class="line">----------------------------------</span><br><span class="line">capitals := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;France&quot;</span>: <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;Italy&quot;</span>: <span class="string">&quot;Rome&quot;</span>, <span class="string">&quot;Japan&quot;</span>: <span class="string">&quot;Tokyo&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> capitals &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Map item: Capital of&quot;</span>, key, <span class="string">&quot;is&quot;</span>, capitals[key])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>###map切片</p>
<p>切片的数据类型如果是map,则我们成为slice of map，map切片，这样使用则map个数可以动态变化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素（参见下面的例子 8.4）。</span></span><br><span class="line">sm := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) </span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">s := []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;n1&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n2&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;n3&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n4&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面代码很重要，要注意</p>
<p><strong>应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> items &#123; <span class="comment">//i是切片的索引下标</span></span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version A: Value of items: %v\n&quot;</span>, items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">    items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">        item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">        item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This &#x27;item&#x27; will be lost on the next iteration.</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Version A: Value of items: [<span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>]]</span><br><span class="line">Version B: Value of items: [<span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###sync.Map</p>
<p>Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n)</span><br><span class="line">			value, _ := m.Load(key)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>###map排序</p>
<ol>
<li>先将map的key的顺序进行排序输出</li>
<li>对切片排序</li>
<li>遍历切片，然后按照key来输出map的值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> k,_ := <span class="keyword">range</span> map1&#123;</span><br><span class="line">    keys = appen(keys,k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(keys)</span><br><span class="line"><span class="keyword">for</span> _,k := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;map1[%v] = %v \n&quot;</span> , k , map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意结构体没有给字段赋值，那么就用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面介绍创建结构体s的方式</span></span><br><span class="line">	<span class="keyword">type</span> s <span class="keyword">struct</span>&#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> s1 s <span class="comment">//此时用默认值</span></span><br><span class="line">	s2 := s&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> s4 *s = <span class="built_in">new</span>(s)</span><br><span class="line">	<span class="keyword">var</span> s5 *s = &amp;s&#123;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s6 = &amp;s&#123;</span><br><span class="line">    name : <span class="string">&quot;小李&quot;</span></span><br><span class="line">    age : <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Price <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TV <span class="keyword">struct</span> &#123; <span class="comment">//这个也叫多重继承</span></span><br><span class="line">	Goods   </span><br><span class="line">	Brand	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Goods</span><br><span class="line">	*Brand	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值</span></span><br><span class="line">	tv := TV&#123; Goods&#123;<span class="string">&quot;电视机001&quot;</span>, <span class="number">5000.99</span>&#125;,  Brand&#123;<span class="string">&quot;海尔&quot;</span>, <span class="string">&quot;山东&quot;</span>&#125;, &#125;</span><br><span class="line"></span><br><span class="line">tv4 := TV2&#123; </span><br><span class="line">			&amp;Goods&#123;</span><br><span class="line">				Name : <span class="string">&quot;电视机004&quot;</span>, </span><br><span class="line">				Price : <span class="number">9000.99</span>,</span><br><span class="line">			&#125;,  </span><br><span class="line">			&amp;Brand&#123;</span><br><span class="line">				Name : <span class="string">&quot;长虹&quot;</span>, </span><br><span class="line">				Address : <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">			&#125;, </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意访问要这样写</span></span><br><span class="line">fmt.Println(<span class="string">&quot;tv4&quot;</span>, *tv4.Goods, *tv4.Brand)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>###接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stu)</span></span> Say() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Say()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu Stu = Stu&#123;&#125;</span><br><span class="line"><span class="comment">// var u Usb = stu这样写会错误！ 会报 Stu类型没有实现Usb接口 ,</span></span><br><span class="line"><span class="comment">// 如果希望通过编译,  var u Usb = &amp;stu</span></span><br><span class="line"><span class="keyword">var</span> u Usb = &amp;stu</span><br><span class="line">u.Say()</span><br></pre></td></tr></table></figure>

<p>####值接收和指针接收</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Move() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Dog value run...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover    <span class="comment">// 声明一个Mover类型的变量x</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d1 = Dog&#123;&#125; <span class="comment">// d1是Dog类型</span></span><br><span class="line">	x = d1         <span class="comment">// 可以将d1赋值给变量x</span></span><br><span class="line">	x.Move()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; <span class="comment">// d2是Dog指针类型</span></span><br><span class="line">	x = d2          <span class="comment">// 也可以将d2赋值给变量x</span></span><br><span class="line">	x.Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p>
<p>==但是注意下面的情况==</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   Move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (d Dog) Move() &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Dog value run...&quot;)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> Move() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Dog Point run...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Mover </span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d1 = Dog&#123;&#125; </span><br><span class="line">   x = d1         <span class="comment">// 这里会编译错误</span></span><br><span class="line">   x.Move()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; </span><br><span class="line">   x = d2          </span><br><span class="line">   x.Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>####接口的底层结构</p>
<p><img src="https://tuchuangf0qw.oss-cn-fuzhou.aliyuncs.com/typora_images/202207212136842.png" alt="image-20220226114637512"></p>
<h3 id="自定义数据类型type"><a href="#自定义数据类型type" class="headerlink" title="自定义数据类型type"></a>自定义数据类型type</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span> <span class="comment">//这时myInt就等价int来使用了</span></span><br><span class="line"><span class="keyword">type</span> mySum <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span><span class="comment">//这时mySum就等价一个函数类型</span></span><br></pre></td></tr></table></figure>



<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>注意类型转化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int8</span> = <span class="type">int8</span>(num1) <span class="comment">//可以看成函数那样，并不会改变num1的结果和类型，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int32</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int</span> <span class="number">64</span></span><br><span class="line">n2 = n1 + <span class="number">20</span> <span class="comment">//int32的n1不能这样相加转int64的n2。必须强转 int64(n1) + 20</span></span><br></pre></td></tr></table></figure>

<p>##类型断言</p>
<p>​    为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure>

<p>​    若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。  </p>
<p>​    否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。  </p>
<p>​    请注意这种语法和读取一个映射时的相同之处。  </p>
<hr>
<p>​    <strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。  </p>
<p>​    类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值），     它们针对给定接口值所存储的值的类型进行比较。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。  </p>
<p>​    此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。  </p>
<h3 id="字符串和数字类型的转换"><a href="#字符串和数字类型的转换" class="headerlink" title="字符串和数字类型的转换"></a>字符串和数字类型的转换</h3><p>==<strong>strconv包下</strong>==</p>
<blockquote>
<h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4></blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4></blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p>ParseBool() 函数用于将字符串转换为 bool 类型的值，它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误，函数签名如下。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ParseInt() 函数用于返回字符串表示的整数值（可以包含正负号），参数说明：</p>
<ul>
<li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。</li>
<li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li>
<li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p>ParseFloat() 函数用于将一个表示浮点数的字符串转换为 float 类型，参数说明：</p>
<ul>
<li>如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。</li>
<li>bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64；</li>
<li>返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p>FormatBool() 函数可以一个 bool 类型的值转换为对应的字符串类型，函数签名如下。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，其中，参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line">------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">        str := strconv.FormatInt(num, <span class="number">16</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">        <span class="comment">//type:string,value:64</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p>FormatFloat() 函数用于将浮点数转换为字符串类型，参数说明：</p>
<ul>
<li>bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。</li>
<li>fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd  十进制指数、“E”表示 -d.ddddE±dd  十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li>prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 fmt 为“g”、“G”时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ol>
<li>值类型<ol>
<li>int系列</li>
<li>float系列</li>
<li>bool</li>
<li>string</li>
<li>数组</li>
<li>结构体</li>
</ol>
</li>
<li>引用类型<ol>
<li>指针</li>
<li>slice切片</li>
<li>map</li>
<li>管道chan</li>
<li>interface</li>
</ol>
</li>
</ol>
<blockquote>
<p>注意值类型参数默认就是值传递，而引用类型参数默认就是引用传递。但是不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小</p>
</blockquote>
<blockquote>
<p>引用类型默认是引用传递，变量存储的是一个地址，这个地址对应的空间才是真正存储数据值，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>注意下面几点</p>
<ol>
<li>golang没有三元运算符</li>
<li>只能写i++</li>
<li>取余的结果与被除数的符号一样</li>
<li>&amp;&amp;和||都具有短路效果</li>
</ol>
<h1 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a>分支和循环</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age := <span class="number">20</span> ; age &gt; <span class="number">18</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> key&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,n1:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    	<span class="keyword">fallthrough</span> <span class="comment">//默认只能穿透一层</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">	x = y</span><br><span class="line">	<span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;mox 的 类型是: %T&quot;</span>, i)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ol>
<li><p>``` go<br>var str string = “hello,wordld~”<br>for i := 0 ; i &lt; len(str) ; i++{</p>
<pre><code>fmt.Printf(&quot;%c \n&quot;,str[i])
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   i := 1</span><br><span class="line">   for i &lt;= 19&#123;</span><br><span class="line">       ///</span><br><span class="line">       i++</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>k := 1<br>for {</p>
<pre><code>if k &lt;= 19 &#123;
    
&#125;else&#123;
    break
&#125;
k++
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   //Golang提供for-range的方式可以方便遍历字符串和数组（能遍历中文）</span><br><span class="line">   str := &#x27;a北京&#x27;</span><br><span class="line">   for index , val := range str&#123;</span><br><span class="line">       fmt.Printf(&quot;index = %d,val = %c \n&quot;,index,val)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>//对于while的实现改成<br>for{</p>
<pre><code>if 循环条件表达式&#123;
    break
&#125;
//语句
循环遍历迭代
</code></pre>
<p>}</p>
<p>//对于dowhile的实现改成<br>for{</p>
<pre><code>//语句
循环遍历迭代
if 循环条件表达式&#123;
    break
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## break continue</span><br><span class="line"></span><br><span class="line">### 生成随机数</span><br><span class="line"></span><br><span class="line">``` go</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	intn := rand.Intn(3)//intn取值是0,1,2</span><br><span class="line">	println(intn)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>###break和continue</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里演示一下指定标签的形式来使用 break</span></span><br><span class="line">lable2: </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">         <span class="keyword">break</span> lable2 <span class="comment">// j=0 j=1</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;j=&quot;</span>, j) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lable2:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">   <span class="comment">//lable1: // 设置一个标签在这里设置等价于普通的continue</span></span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span> lable2</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;i=&quot;</span>,i,<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出如下</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">0</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">1</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">2</span> j= <span class="number">1</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">0</span></span><br><span class="line">i= <span class="number">3</span> j= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>###<strong>goto的使用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="type">int</span> = <span class="number">30</span></span><br><span class="line"><span class="comment">//演示goto的使用</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ok1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">20</span> &#123;</span><br><span class="line">   <span class="keyword">goto</span> label1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;ok2&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok4&quot;</span>)</span><br><span class="line">label1:</span><br><span class="line">fmt.Println(<span class="string">&quot;ok5&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok6&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ok7&quot;</span>)</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">ok1</span><br><span class="line">ok5</span><br><span class="line">ok6</span><br><span class="line">ok7</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="type">float64</span>, n2 <span class="type">byte</span>)</span></span> <span class="type">float64</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>,sub <span class="type">int</span>)&#123;&#125;<span class="comment">//支持对函数返回值命名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>,args... <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;&#125;<span class="comment">//args是slice切片，通过args[index]访问</span></span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ol>
<li>在给一个go文件打包时，该包对应一个文件夹，go文件的的包名通常和文件所在的文件夹名字一致，一般为小写字母</li>
<li>import包时，路径从$GOPATH的src下开始，不用带src，编译器会自动从src下开始引入</li>
<li>为了让其他包的文件可以访问到本包的函数，该函数名的首字母需要大写，类似其他语言的public，这样才能跨包访问</li>
<li>在访问其他包函数变量时，语法是包名.函数名</li>
<li>如果包名较长，Go支持给包取别名，注意细节：取别名之后，原来的包名就不能使用了</li>
</ol>
<h2 id="函数注意事项"><a href="#函数注意事项" class="headerlink" title="函数注意事项"></a>函数注意事项</h2><ol>
<li><p>基本数据类型和数组默认都是值传递的，即进行值拷贝，在函数内修改，不会影响原来的值</p>
</li>
<li><p>如果希望函数内的变量能修改函数外的变量（指的是默认以值传递的方式的数据类型），可以传入变量的地址&amp;。函数内以指针的方式操作变量</p>
</li>
<li><p>go函数不支持重载</p>
</li>
<li><p>函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用，同时既然是数据类型，因此函数也可以作为形参，并且调用</p>
</li>
<li><p>每个源文件都可以包含一个<code>init函数</code>，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用</p>
</li>
<li><p>==函数初始化的执行顺序==</p>
<ol>
<li>先导入其他包，执行被导入的包的初始化</li>
<li>初始化顺序是先执行全局变量的初始化</li>
<li>然后执行init函数</li>
</ol>
</li>
<li><p>匿名函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res1 := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;<span class="keyword">return</span> n1+n2&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;<span class="keyword">return</span> n1+n2&#125;</span><br><span class="line">res2 := a(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局匿名函数：将匿名函数赋给一个全局变量</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    Fun1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="type">int</span>,n2 <span class="type">int</span>)</span></span><span class="type">int</span>&#123;<span class="keyword">return</span> n1 + n2&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol>
<li><p>闭包就是一个函数和其相关的引用环境组合的一个整体</p>
</li>
<li><p>闭包的使用是通过返回一个匿名函数实现的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n <span class="type">int</span> = <span class="number">10</span> </span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      n = n + x</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := AddUpper()</span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">// 11 </span></span><br><span class="line">fmt.Println(f(<span class="number">2</span>))<span class="comment">// 13</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ol>
<li>当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数下一个语句</li>
<li>当函数执行完毕后，再从栈顶取出语句执行</li>
<li>在defer将语句放入到栈时，也会将相关的值拷贝同时入栈，</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">7</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	func1(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func1(&quot;Go&quot;) = 7, EOF</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;defer:&quot;</span>, i, y)</span><br><span class="line">	&#125;(x)</span><br><span class="line">	x += <span class="number">10</span></span><br><span class="line">	y += <span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是</span></span><br><span class="line">x= <span class="number">20</span> y= <span class="number">120</span> </span><br><span class="line"><span class="keyword">defer</span>: <span class="number">10</span> <span class="number">120</span></span><br></pre></td></tr></table></figure>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li>函数内部声明定义的变量叫局部变量，作用域仅限于函数内部</li>
<li>函数外部声明定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效</li>
<li>如果变量在一个代码块，比如for/if中，那么这个变量的作用域就在该代码块中</li>
</ol>
<p>#异常处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//使用defer + recover 来捕获和处理异常</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := <span class="built_in">recover</span>()  <span class="comment">// recover()内置函数，可以捕获到异常</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="comment">// 说明捕获到错误</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;err=&quot;</span>, err)</span><br><span class="line">         <span class="comment">//这里就可以将错误信息发送给管理员....</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;发送邮件给admin@sohu.com~&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   num1 := <span class="number">10</span></span><br><span class="line">   num2 := <span class="number">0</span></span><br><span class="line">   res := num1 / num2</span><br><span class="line">   fmt.Println(<span class="string">&quot;res=&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数去读取以配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">      <span class="comment">//读取...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//返回一个自定义错误</span></span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误..&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>工厂模式创建对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span>   <span class="comment">//其它包不能直接访问..</span></span><br><span class="line">	sal <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个工厂模式的函数，相当于构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		Name : name,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> age &gt;<span class="number">0</span> &amp;&amp; age &lt;<span class="number">150</span> &#123;</span><br><span class="line">		p.age = age</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;年龄范围不正确..&quot;</span>)</span><br><span class="line">		<span class="comment">//给程序员给一个默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span></span> GetAge() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##继承</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A    <span class="comment">//这样就表示内嵌，但是和java的继承有些许不同，不能父类指针指向子类对象，Go中的内嵌方法不算重载的概念，算是叫隐藏。 </span></span><br><span class="line">    <span class="comment">//后面var b B; 然后可以直接b.name.或者b.A.name访问方法和变量  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##组合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    a A    <span class="comment">//这样就表示组合， 后面var b B; 然后只能b.a.name访问方法和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h3><p>​    比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// 编译错误！</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>​    而以指针为接收者的方法被调用时，接收者既能为值又能为指针：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>​    对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。     也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">	p.Scale(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(v, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;	</span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(p.Abs())   <span class="comment">//方法调用可以这样</span></span><br><span class="line"></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br></pre></td></tr></table></figure>



<p>###基于指针对象的方法</p>
<p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实现是通过接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> b2 <span class="type">float32</span> = <span class="number">2.1</span></span><br><span class="line">	x = b2 <span class="comment">//空接口，可以接收任何类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> y, ok := x.(<span class="type">float32</span>); ok &#123; <span class="comment">//调用特有方法，需要类型断言来转型</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;y的类型是 %T 值是%v&quot;</span>, y, y)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;转换失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol>
<li><p>```go<br>file, err := os.Open(“d:/test.txt”) //打开文件<br>err = file.Close()  //关闭文件<br>if err != nil {</p>
<pre><code>fmt.Println(&quot;close file err=&quot;, err)
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 文件的读取有两种方式</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   	reader := bufio.NewReader(file)</span><br><span class="line">   	//循环的读取文件的内容</span><br><span class="line">   	for &#123;</span><br><span class="line">   		str, err := reader.ReadString(&#x27;\n&#x27;) // 读到一个换行就结束</span><br><span class="line">   		//输出内容</span><br><span class="line">   		fmt.Printf(str)</span><br><span class="line">   		</span><br><span class="line">   		if err == io.EOF &#123; // io.EOF表示文件的末尾</span><br><span class="line">   			break</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   -----------------------------------------</span><br><span class="line">   content, err := ioutil.ReadFile(&quot;d:/test.txt&quot;)</span><br><span class="line">   fmt.Printf(&quot;%v&quot;, string(content)) // content是[]byte需要强转。文件的Open和Close被封装到 ReadFile 函数内部，不需要我们写</span><br></pre></td></tr></table></figure></li>
<li><p>文件的写入也有两种方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">filePath := <span class="string">&quot;d:/abc.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//及时关闭file句柄</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	</span><br><span class="line">	str := <span class="string">&quot;hello,Gardon\n&quot;</span> <span class="comment">// \r\n 表示换行</span></span><br><span class="line">	</span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为writer是带缓存，因此在调用WriterString方法时，其实</span></span><br><span class="line">	<span class="comment">//内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据</span></span><br><span class="line">	<span class="comment">//真正写入到文件中， 否则文件中会没有数据!!!</span></span><br><span class="line">	writer.Flush()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//将d:/abc.txt 文件内容导入到  d:/kkk.txt</span></span><br><span class="line"></span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;d:/abc.txt&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	err = ioutil.WriteFile(<span class="string">&quot;d:/kkk.txt&quot;</span>, data, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判断文件是否存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span> <span class="comment">//文件或者目录存在</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span> <span class="comment">//文件或文件夹不存在</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err <span class="comment">//其他类型错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">len</span>(os.Args))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">   fmt.Println(i, <span class="string">&quot;---&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用flag解析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;user 就是接收用户命令行中输入的 -u 后面的参数值</span></span><br><span class="line">	<span class="comment">//&quot;u&quot; ,就是 -u 指定参数</span></span><br><span class="line">	<span class="comment">//&quot;&quot; , 默认值</span></span><br><span class="line">	<span class="comment">//&quot;用户名,默认为空&quot; 说明</span></span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名,默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码,默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名,默认为localhost&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为3306&quot;</span>)</span><br><span class="line">	<span class="comment">//这里有一个非常重要的操作,转换， 必须调用该方法</span></span><br><span class="line">	flag.Parse()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>)</span><br><span class="line"><span class="comment">//这样也能解析然后获取对应的参数到n和sep</span></span><br><span class="line"><span class="comment">//不过访问时要用 *n  *sep</span></span><br></pre></td></tr></table></figure>



<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>序列化和反序列化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将monster 序列化</span></span><br><span class="line">	data, err := json.Marshal(&amp;monster) <span class="comment">//..</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//反序列化</span></span><br><span class="line">	<span class="comment">//注意：反序列化map,不需要make,因为make操作被封装到 Unmarshal函数</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br></pre></td></tr></table></figure>



<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li><p>测试用例文件必须以 _test.go结尾。比如cal_test.go  其中cal不是固定的</p>
</li>
<li><p>测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAdd（注意A必须大写，即Test后的首字母必须大写） 同时测试用例函数的形参类型必须是*testing.T</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	addf := aaa.Addf(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">//测试aaa包下的Addf函数</span></span><br><span class="line">	<span class="keyword">if</span> addf == <span class="number">3</span> &#123;</span><br><span class="line">		t.Logf(<span class="string">&quot;测试成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;测试失败&quot;</span>) <span class="comment">//当出现错误时用这个输出错误信息并退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>cmd&gt;go test  <code>如果运行正确，无日志，错误时会输出日志</code></p>
<p>cmd &gt; go test -v <code> 运行正确或是错误，都会输出日志</code></p>
<p>测试单个文件，一定要带上被测试的原文件 go test -v cal_test.go cal.go</p>
<p>测试单个方法 go test -v -test.run TestAddUpper<code>(这个是方法名)</code></p>
</li>
</ol>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpuNum := runtime.NumCPU() <span class="comment">//系统CPU数量</span></span><br><span class="line"><span class="comment">//可以自己设置使用多个cpu</span></span><br><span class="line">runtime.GOMAXPROCS(cpuNum - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>协程goroutine运行要注意同时写的资源竞争问题，可以用 go build -race 来编译运行查看是否存在资源竞争问题</p>
<p>解决方法</p>
<ol>
<li><p>全局变量加锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="comment">// test 函数就是计算 n!, 让将这个结果放入到 myMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	myMap[n] = res <span class="comment">//concurrent map writes?</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> test(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//休眠10秒钟【第二个问题 】</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```go<br>var wg sync.WaitGroup</p>
<p>func hello(i int) {</p>
<pre><code>defer wg.Done() // goroutine结束就登记-1
fmt.Println(&quot;Hello Goroutine!&quot;, i)
</code></pre>
<p>}<br>func main() {</p>
<pre><code>for i := 0; i &lt; 10; i++ &#123;
    wg.Add(1) // 启动一个goroutine就登记+1
    go hello(i)
&#125;
wg.Wait() // 等待所有登记的goroutine都结束
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **读写锁**</span><br><span class="line"></span><br><span class="line">   读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   var (</span><br><span class="line">   	x      int64</span><br><span class="line">   	wg     sync.WaitGroup</span><br><span class="line">   	lock   sync.Mutex</span><br><span class="line">   	rwlock sync.RWMutex</span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line">   func write() &#123;</span><br><span class="line">   	// lock.Lock()   // 加互斥锁</span><br><span class="line">   	rwlock.Lock() // 加写锁</span><br><span class="line">   	x = x + 1</span><br><span class="line">   	time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒</span><br><span class="line">   	rwlock.Unlock()                   // 解写锁</span><br><span class="line">   	// lock.Unlock()                     // 解互斥锁</span><br><span class="line">   	wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func read() &#123;</span><br><span class="line">   	// lock.Lock()                  // 加互斥锁</span><br><span class="line">   	rwlock.RLock()               // 加读锁</span><br><span class="line">   	time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒</span><br><span class="line">   	rwlock.RUnlock()             // 解读锁</span><br><span class="line">   	// lock.Unlock()                // 解互斥锁</span><br><span class="line">   	wg.Done()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func main() &#123;</span><br><span class="line">   	start := time.Now()</span><br><span class="line">   	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">   		wg.Add(1)</span><br><span class="line">   		go write()</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   	for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">   		wg.Add(1)</span><br><span class="line">   		go read()</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   	wg.Wait()</span><br><span class="line">   	end := time.Now()</span><br><span class="line">   	fmt.Println(end.Sub(start))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol>
<li><p>channel</p>
<ol>
<li><p>channel本质就是一个数据结构-队列，数据先进先出</p>
</li>
<li><p>线程安全，多goroutine访问时，不需要加锁，就是说channel本身就是线程安全的</p>
</li>
<li><p>channel有类型的，一个string类型的channel只能存放string类型数据</p>
</li>
<li><p>channe的定义和初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//无缓冲的管道</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>) <span class="comment">//必须make才能用，而且还要指定len才能用</span></span><br><span class="line">b &lt;- <span class="string">&quot;dd&quot;</span></span><br><span class="line">b &lt;- <span class="string">&quot;aa&quot;</span></span><br><span class="line"></span><br><span class="line">val1 := &lt;-b</span><br></pre></td></tr></table></figure></li>
<li><p>channel的数据放满了后，就不能再放入了，若没有使用协程的情况下，如果channel的数据取完了，再取就会报  <code>fatal error: all goroutines are asleep - deadlock! </code> 错误</p>
</li>
<li><p>管道的遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//遍历管道</span></span><br><span class="line">	intChan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		intChan2 &lt;- i * <span class="number">2</span> <span class="comment">//放入100个数据到管道</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历管道不能使用普通的 for 循环</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intChan2); i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;v=&quot;</span>, &lt;-intChan2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在遍历时，如果channel没有关闭，则会出现deadlock的错误</span></span><br><span class="line">	<span class="comment">//在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</span></span><br><span class="line">	<span class="built_in">close</span>(intChan2)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;v=&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">//另一种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		num, ok := &lt;-intChan <span class="comment">//intChan 取不到..	</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123; </span><br><span class="line">			<span class="keyword">break</span>  <span class="comment">//没数据时退出循环</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>只读或者只写的管道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 在默认情况下下，管道是双向</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 声明为只写</span></span><br><span class="line">	<span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//两种写法都可以</span></span><br><span class="line">    chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">3</span>)</span><br><span class="line">-------------------------------------</span><br><span class="line">chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">chan2 &lt;- <span class="number">20</span></span><br><span class="line">	<span class="comment">//num := &lt;-chan2 //error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 声明为只读</span></span><br><span class="line">	chan3 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">	num2 := &lt;-chan3</span><br><span class="line">	<span class="comment">//chan3&lt;- 30 //err</span></span><br></pre></td></tr></table></figure></li>
<li><p>select的用法</p>
<p>​    <code>select</code> 语句使一个 Go 程可以等待多个通信操作。  </p>
<p>​    <code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题，在实际开发中，可能我们不好确定什么关闭该管道.</span></span><br><span class="line">	<span class="comment">//可以使用select 方式可以解决</span></span><br><span class="line">	label:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">//注意: 这里，如果intChan一直没有关闭，不会一直阻塞而deadlock</span></span><br><span class="line">			<span class="comment">//，会自动到下一个case匹配</span></span><br><span class="line">			<span class="keyword">case</span> v := &lt;-intChan : </span><br><span class="line">				fmt.Printf(<span class="string">&quot;从intChan读取的数据%d\n&quot;</span>, v)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-stringChan :</span><br><span class="line">				fmt.Printf(<span class="string">&quot;从stringChan读取的数据%s\n&quot;</span>, v)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">default</span> :</span><br><span class="line">				fmt.Printf(<span class="string">&quot;都取不到了，不玩了, 程序员可以加入逻辑\n&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">				<span class="keyword">break</span> label</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><ol>
<li><p>Dial函数和服务端建立连接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.191.2:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;client dial err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//功能一：客户端可以发送单行数据，然后就退出</span></span><br><span class="line">	reader := bufio.NewReader(os.Stdin) <span class="comment">//os.Stdin 代表标准输入[终端]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从终端读取一行用户输入，并准备发送给服务器</span></span><br><span class="line">		line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readString err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果用户输入的是 exit就退出</span></span><br><span class="line">		line = strings.Trim(line, <span class="string">&quot; \r\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出..&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//再将line 发送给 服务器</span></span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(line + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn.Write err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Listen函数创建的服务端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">//这里我们循环的接收客户端发送的数据</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close() <span class="comment">//关闭conn</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个新的切片</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		<span class="comment">//conn.Read(buf)</span></span><br><span class="line">		<span class="comment">//1. 等待客户端通过conn发送信息</span></span><br><span class="line">		<span class="comment">//2. 如果客户端没有wrtie[发送]，那么协程就阻塞在这里</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;服务器在等待客户端%s 发送信息\n&quot;, conn.RemoteAddr().String())</span></span><br><span class="line">		n , err := conn.Read(buf) <span class="comment">//从conn读取</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			</span><br><span class="line">			fmt.Printf(<span class="string">&quot;客户端退出 err=%v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">//!!!</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3. 显示客户端发送的内容到服务器的终端</span></span><br><span class="line">		fmt.Print(<span class="type">string</span>(buf[:n])) </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;服务器开始监听....&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;0.0.0.0:8888&quot;</span>)<span class="comment">//监听本机的端口</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;listen err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listen.Close() <span class="comment">//延时关闭listen</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环等待客户端来链接我</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//等待客户端链接</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端来链接....&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() err=&quot;</span>, err)</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Accept() suc con=%v 客户端ip=%v\n&quot;</span>, conn, conn.RemoteAddr().String())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里准备其一个协程，为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h4 id="判断种类"><a href="#判断种类" class="headerlink" title="判断种类"></a>判断种类</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	k := v.Kind()</span><br><span class="line">	<span class="keyword">switch</span> k &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Int64:</span><br><span class="line">		<span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>####修改值获取值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;tom&quot;</span>      </span><br><span class="line">   fs := reflect.ValueOf(&amp;str) <span class="comment">//修改值必须用&amp;传参</span></span><br><span class="line">    aa := reflect.ValueOf(str).String() + <span class="string">&quot;aa&quot;</span><span class="comment">//获取值用.String() .Interface()   .Int()</span></span><br><span class="line">   fmt.Println(aa, str) <span class="comment">//输出结果：tomaa tom</span></span><br><span class="line">    fs.Elem().SetString(<span class="string">&quot;jack&quot;</span>) <span class="comment">////修改值必须先.Elem()</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, str)     <span class="comment">// jack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####结构体获取方法和成员</p>
<p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   stu1 := student&#123;</span><br><span class="line">      Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">      Score: <span class="number">90</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t := reflect.TypeOf(stu1)</span><br><span class="line">   fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">   <span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">      field := t.Field(i)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">   <span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.NumMethod())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">		methodType := v.Method(i).Type()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">		<span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line">		<span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">		v.Method(i).Call(args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========================</span><br><span class="line">args = <span class="built_in">append</span>(args, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">args = <span class="built_in">append</span>(agrs, reflect.ValueOf(<span class="number">40</span>))<span class="comment">//通过这种方式添加参数</span></span><br></pre></td></tr></table></figure>





<h1 id="go中的数据结构"><a href="#go中的数据结构" class="headerlink" title="go中的数据结构"></a>go中的数据结构</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span> <span class="comment">// 姓名</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="comment">// 年纪</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 Person.Age 从大到小排序</span></span><br><span class="line"><span class="keyword">type</span> PersonSlice []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Len() <span class="type">int</span> &#123; <span class="comment">// 重写 Len() 方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123; <span class="comment">// 重写 Swap() 方法</span></span><br><span class="line">   a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="comment">// 重写 Less() 方法， 从小到大排序</span></span><br><span class="line">   res := a[i].Age - a[j].Age</span><br><span class="line">   <span class="keyword">if</span> res == <span class="number">0</span> &#123;</span><br><span class="line">      res = strings.Compare(a[i].Name, a[j].Name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> res &gt; <span class="number">0</span> &#123;  <span class="comment">//从大到小排序，当年龄数字一样时，名字也是从大到小排序</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   people := []Person&#123;</span><br><span class="line">      &#123;<span class="string">&quot;ahang san&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;li si&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;bang wu&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;zhao liu&quot;</span>, <span class="number">26</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">   sort.Sort(PersonSlice(people)) <span class="comment">// 按照 Age 的升序排序</span></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">   sort.Sort(sort.Reverse(PersonSlice(people))) <span class="comment">// 按照 Age 的降序排序</span></span><br><span class="line">   fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序正序，基本数据类型的切片用这几个函数	</span></span><br><span class="line">	sort.Sort(sort.IntSlice(intList))</span><br><span class="line">    sort.Sort(sort.Float64Slice(floatList))</span><br><span class="line">    sort.Sort(sort.StringSlice(stringList))</span><br></pre></td></tr></table></figure>



<p>##堆，优先队列</p>
<p>heap是常用的实现优先队列的方法。heap包对任意实现了heap接口的类型提供堆操作。堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：Len() int / Less(i, j int) bool / Swap(i, j  int) 再加上堆接口定义的两个方法：Push(x interface{}) / Pop()  interface{}。故只要实现了这五个方法，便定义了一个堆。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    heap.Push(h, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>==优先队列：==</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu []stu</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*t) <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*t)[i].age &lt; (*t)[j].age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*t)[i], (*t)[j] = (*t)[j], (*t)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *t = <span class="built_in">append</span>(*t, x.(stu))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Stu)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*t)</span><br><span class="line">    x := (*t)[n<span class="number">-1</span>]</span><br><span class="line">    *t = (*t)[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    student := &amp;Stu&#123;&#123;<span class="string">&quot;Amy&quot;</span>, <span class="number">21</span>&#125;, &#123;<span class="string">&quot;Dav&quot;</span>, <span class="number">15</span>&#125;, &#123;<span class="string">&quot;Spo&quot;</span>, <span class="number">22</span>&#125;, &#123;<span class="string">&quot;Reb&quot;</span>, <span class="number">11</span>&#125;&#125;</span><br><span class="line">    heap.Init(student)</span><br><span class="line">    one := stu&#123;<span class="string">&quot;hund&quot;</span>, <span class="number">9</span>&#125;</span><br><span class="line">    heap.Push(student, one)</span><br><span class="line">    <span class="keyword">for</span> student.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, heap.Pop(student))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h2><p>可以类比数据结构中线性表的删除</p>
<p>要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>下面的方式可以在LeetCode中使用，简单的实现栈和队列。但是在实际项目中不要这么使用，这么做会带来内存泄漏的风险。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入栈</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="number">1</span>)</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 出栈</span></span><br><span class="line">queue = queue[<span class="number">1</span>: <span class="built_in">len</span>(queue)]</span><br><span class="line">stack = stack[<span class="number">0</span>: <span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>



<p> golang 内置的 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://golang.org/pkg/container/list/"><code>container/list</code></a> 库提供了双向链表的数据结构。我们用这个也是很方便的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue := list.New()</span><br><span class="line">stack := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入栈</span></span><br><span class="line">queue.PushBack(<span class="number">123</span>)</span><br><span class="line">stack.PushBack(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 出栈 返回的数据是结构类型 Value 需要断言成相应的类型</span></span><br><span class="line">num1 = queue.Front() <span class="comment">//num1.Value才是具体值，不然是地址</span></span><br><span class="line">queue.Remove(num1)</span><br><span class="line"></span><br><span class="line">num2 = queue.Back()</span><br><span class="line">stack.Remove(num2)</span><br></pre></td></tr></table></figure>



<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span></span><br><span class="line"><span class="comment">// License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// See page 101.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package treesort provides insertion sort using an unbalanced binary tree.</span></span><br><span class="line"><span class="keyword">package</span> treesort</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+</span></span><br><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">   value       <span class="type">int</span></span><br><span class="line">   left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort sorts values in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> root *tree</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">      root = add(root, v)  <span class="comment">//建树</span></span><br><span class="line">   &#125;</span><br><span class="line">   appendValues(values[:<span class="number">0</span>], root)<span class="comment">//中序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues appends the elements of t to values in order</span></span><br><span class="line"><span class="comment">// and returns the resulting slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="type">int</span>, t *tree)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">      values = appendValues(values, t.left)</span><br><span class="line">      values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">      values = appendValues(values, t.right)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="type">int</span>)</span></span> *tree &#123;</span><br><span class="line">   <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class="line">      t = <span class="built_in">new</span>(tree)</span><br><span class="line">      t.value = value</span><br><span class="line">      <span class="keyword">return</span> t</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">      t.left = add(t.left, value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      t.right = add(t.right, value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!-</span></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %c %d&quot;</span>, &amp;a, &amp;b, &amp;c)</span><br><span class="line">---------------</span><br><span class="line"><span class="comment">//输入一行的话</span></span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line">	<span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">		counts[input.Text()]++</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b, c <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> d [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> e []<span class="type">string</span></span><br><span class="line">	fmt.Scanf(<span class="string">&quot;%d %d %d\n&quot;</span>, &amp;a, &amp;b, &amp;c)</span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入字符串的两行&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">		fmt.Scanf(<span class="string">&quot;%s\n&quot;</span>, &amp;s) <span class="comment">//后面的\n不加的话按Enter键的也被加入e</span></span><br><span class="line">		e = <span class="built_in">append</span>(e, s)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入数组的两行三列&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b; j++ &#123;</span><br><span class="line">			fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;d[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b; j++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d &quot;</span>, d[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(e[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>###for循环中的陷阱</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary! 这个不能省略，不然就出错原因是d是引用地址</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map的值是切片的陷阱"><a href="#map的值是切片的陷阱" class="headerlink" title="map的值是切片的陷阱"></a>map的值是切片的陷阱</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span></span><br><span class="line">   m := <span class="built_in">make</span>(Map)</span><br><span class="line">   s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">   s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)<span class="comment">//[1 2 3]</span></span><br><span class="line">   m[<span class="string">&quot;q1mi&quot;</span>] = s</span><br><span class="line">   s = <span class="built_in">append</span>(s[:<span class="number">1</span>], s[<span class="number">2</span>:]...)<span class="comment">//相当于删除s[1],  [1 3]</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])<span class="comment">//[1 3 3]</span></span><br><span class="line">   s = <span class="built_in">append</span>(s,<span class="number">4</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])<span class="comment">//[1 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="defer的陷阱"><a href="#defer的陷阱" class="headerlink" title="defer的陷阱"></a>defer的陷阱</h3><p>==暂时还看不懂==</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   x := <span class="number">5</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> (y <span class="type">int</span>) &#123;</span><br><span class="line">   x := <span class="number">5</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;(x)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(f1())</span><br><span class="line">   fmt.Println(f2())</span><br><span class="line">   fmt.Println(f3())</span><br><span class="line">   fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   ret := a + b</span><br><span class="line">   fmt.Println(index, a, b, ret)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x := <span class="number">1</span></span><br><span class="line">   y := <span class="number">2</span></span><br><span class="line">   <span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">   x = <span class="number">10</span></span><br><span class="line">   <span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">   y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>###牛客陷阱</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   a := <span class="number">12</span></span><br><span class="line">   &#123;</span><br><span class="line">      a := <span class="number">13</span></span><br><span class="line">      _ = a <span class="comment">// make compiler happy</span></span><br><span class="line">      fmt.Println(a)<span class="comment">//输出13</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)<span class="comment">//输出12</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于常量定义zero(const zero = 0.0)，zero是浮点型常量，这一说法是否正确。<code>错误</code>Go语言里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</li>
<li></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/07/21/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="java编程思想学习笔记">
      java编程思想学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.</span> <span class="nav-text">编写规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IDE%E6%8A%A5%E9%94%99"><span class="nav-number">1.3.</span> <span class="nav-text">IDE报错</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#command-line-arguments-undefined"><span class="nav-number">1.3.1.</span> <span class="nav-text">command-line-arguments undefined:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.4.</span> <span class="nav-text">传统模式建项目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85"><span class="nav-number">1.5.</span> <span class="nav-text">实现导入自己的包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sort"><span class="nav-number">1.5.1.</span> <span class="nav-text">sort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#golang%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">golang变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">使用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">字符类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.2.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">2.2.3.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.2.4.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btype"><span class="nav-number">2.2.5.</span> <span class="nav-text">自定义数据类型type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">类型转化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.3.1.</span> <span class="nav-text">字符串和数字类型的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Itoa-%EF%BC%9A%E6%95%B4%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">Itoa()：整型转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Atoi-%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%9E%8B"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">Atoi()：字符串转整型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParseBool"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">ParseBool()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParseFloat"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">ParseFloat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FormatBool"><span class="nav-number">2.3.1.5.</span> <span class="nav-text">FormatBool()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FormatInt"><span class="nav-number">2.3.1.6.</span> <span class="nav-text">FormatInt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FormatFloat"><span class="nav-number">2.3.1.7.</span> <span class="nav-text">FormatFloat()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">值类型和引用类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.</span> <span class="nav-text">分支和循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if"><span class="nav-number">4.1.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Switch"><span class="nav-number">4.2.</span> <span class="nav-text">Switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for"><span class="nav-number">4.3.</span> <span class="nav-text">for</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="nav-number">5.1.</span> <span class="nav-text">快速入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">5.2.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.3.</span> <span class="nav-text">函数注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">5.4.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer"><span class="nav-number">5.5.</span> <span class="nav-text">defer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">5.6.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">5.7.</span> <span class="nav-text">自定义异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">6.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8C%87%E9%92%88%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">6.2.1.</span> <span class="nav-text">方法与指针重定向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">6.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#json"><span class="nav-number">9.</span> <span class="nav-text">json</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">10.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#goroutine"><span class="nav-number">11.</span> <span class="nav-text">goroutine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="nav-number">12.1.</span> <span class="nav-text">TCP编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">13.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%A7%8D%E7%B1%BB"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">判断种类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">14.</span> <span class="nav-text">go中的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">14.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">14.2.</span> <span class="nav-text">切片的删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">14.3.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-number">14.4.</span> <span class="nav-text">二叉排序树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">15.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">15.1.</span> <span class="nav-text">输入输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1"><span class="nav-number">15.2.</span> <span class="nav-text">陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E7%9A%84%E5%80%BC%E6%98%AF%E5%88%87%E7%89%87%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">15.2.1.</span> <span class="nav-text">map的值是切片的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">15.2.2.</span> <span class="nav-text">defer的陷阱</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chen"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
